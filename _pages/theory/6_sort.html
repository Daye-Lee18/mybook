
<!DOCTYPE html>


<html lang="ko" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Lecture 6-1. 정렬 &#8212; 말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css?v=6644e6bb" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=9c59b310" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=ae323b5b"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="../../_static/translations.js?v=e33e7ba0"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_pages/theory/6_sort';</script>
    <script src="https://unpkg.com/jupyterquiz@1.1.8/dist/jupyterquiz.min.js"></script>
    <link rel="icon" href="../../_static/favicon.png"/>
    <link rel="index" title="색인" href="../../genindex.html" />
    <link rel="search" title="검색" href="../../search.html" />
    <link rel="next" title="Lecture 1-2. 구현 실습" href="../practice/1_implementationPS.html" />
    <link rel="prev" title="Lecture 5-1. Shortest Path" href="5_shortest_path.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="ko"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/mylogo.png" class="logo__image only-light" alt="말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업 - Home"/>
    <script>document.write(`<img src="../../_static/mylogo.png" class="logo__image only-dark" alt="말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업 - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="검색" aria-label="검색" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">검색</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Welcome to 말레이시아 5급 IT 수업
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">이론</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="0_tips.html">문제 풀이 순서 팁 (Tips)</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_implementation.html">Lecture 1-1. 구현</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_DFS_BFS.html">Lecture 2-1. DFS/BFS</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_backtracking.html">Lecture 3-1. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_DP.html">Lecture 4-1. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="5_shortest_path.html">Lecture 5-1. Shortest Path</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Lecture 6-1. 정렬</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">실습</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../practice/1_implementationPS.html">Lecture 1-2. 구현 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practice/2_DFS_BFSPS.html">Lecture 2-2. DFS/BFS 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practice/3_backtrackingPS.html">Lecture 3-2. Backtracking 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practice/4_DPPS.html">Lecture 4-2. DP 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practice/5_shortest_pathPS.html">Lecture 5-2. Shortest Path 실습</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">시험</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../exams/midterm_student.html">Midterm</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="이 페이지 다운로드">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/_pages/theory/6_sort.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="소스 파일 다운로드"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="PDF로 인쇄"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="전체 화면으로보기"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="검색" aria-label="검색" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Lecture 6-1. 정렬</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> 내용 </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#selection-sort">선택 정렬 (Selection Sort)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">선택 정렬 예시</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">선택 정렬 코드 및 시간 복잡도</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#insertion-sort">삽입 정렬 (Insertion Sort)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">삽입 정렬 예시</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">삽입 정렬 코드 및 시간 복잡도</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#quick-sort">퀵 정렬 (Quick Sort)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">파트 1</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">파트 2: 분할 완료된 피벗의 왼쪽 리스트</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">파트 3: 분할 완료된 피벗의 오른쪽 리스트</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">퀵 정렬 전체 정리 과정 그림</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">퀵 정렬 소스코드 및 시간 복잡도</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">계수 정렬</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">파이썬의 정렬 라이브러리</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">정리</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="lecture-6-1">
<h1>Lecture 6-1. 정렬<a class="headerlink" href="#lecture-6-1" title="Link to this heading">#</a></h1>
<p>정렬 (Sorting)이란 데이터를 특정한 기준에 따라서 순서대로 나열하는 것을 말한다. 정렬 알고리즘으로 데이터를 정렬하면 이후에 배울 이진 탐색 (Binary Search)이 가능해진다. 이번 수업에서는 총 4가지 정렬 (선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬)에 대해서 배운다. 이 장에서 다루는 예제는 모두 <strong>오름차순 (Increasing order)</strong> 정렬을 수행한다고 가정한다. 내림차순 정렬은 리스트의 원소를 뒤집는 (Reverse) 메서드를 제공하기 때문에 그 방법을 사용하여 O(N) 시간 복잡도로 만들 수 있다.</p>
<div class="dropdown admonition">
<p class="admonition-title">Reversing ways in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># method 1 </span>
<span class="n">list1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">reversed_list</span> <span class="o">=</span> <span class="n">list1</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">reversed_list</span><span class="p">)</span>

<span class="c1"># method 2 </span>
<span class="n">list2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">list2</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span> <span class="c1"># list의 built-in 함수인 reverse()를 사용하면 original data가 없어지는 단점이 존재. </span>
<span class="nb">print</span><span class="p">(</span><span class="n">list2</span><span class="p">)</span> 
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">slicing a list</p>
<p>슬라이싱이란, 리스트 아이템의 일부를 자르는 것이다. 형식은 다음과 같다.</p>
<div class="note admonition">
<p class="admonition-title">slicing 방법</p>
<p>리스트변수[start:end:step]</p>
</div>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>항목</p></th>
<th class="head"><p>의미</p></th>
<th class="head"><p>기본값 step &gt; 0</p></th>
<th class="head"><p>기본값 step &lt; 0</p></th>
<th class="head"><p>중요포인트</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>start</p></td>
<td><p>시작인덱스</p></td>
<td><p>0</p></td>
<td><p>-1</p></td>
<td><p>포함됨</p></td>
</tr>
<tr class="row-odd"><td><p>end</p></td>
<td><p>끝인덱스</p></td>
<td><p>len(arr)</p></td>
<td><p>-(len(arr)+1)</p></td>
<td><p>포함안됨</p></td>
</tr>
<tr class="row-even"><td><p>step</p></td>
<td><p>간격 (양수면 오른쪽, 음수면 왼쪽으로 이동)</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>방향 결정자</p></td>
</tr>
</tbody>
</table>
</div>
<ul class="simple">
<li><p>핵식 개념 정리</p>
<ul>
<li><p>start, end, step 모두 생략 가능하다.</p></li>
<li><p>start와 end의 상대적 방향이 step과 맞아야한다.</p>
<ul>
<li><p>오른쪽으로 갈때는 start &lt; end 여야 값이 생기고,</p></li>
<li><p>왼쪽으로 갈때는 start &gt; end여야 값이 생긴다.</p></li>
<li><p>이 조건이 안 맞는 경우 빈 리스트 ([ ])가 나온다.</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>슬라이싱의 예시를 이용하여, 실제 어떻게 동작하는지 알아보자</p>
<div class="toggle docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span> <span class="c1"># 인덱스 3 이전까지 오른쪽으로 1씩 이동하여 슬라이싱, 결과 [5, 7, 9]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:])</span> <span class="c1"># -3부터 끝까지 오른쪽으로 1씩 이동하여 슬라이싱, 결과 [2, 4, 8]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span> <span class="c1"># 0부터 인덱스 -3 이전까지 오른쪽으로 1씩 이동하여 슬라이싱, 결과 [5, 7, 9, 0, 3, 1, 6]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># 0부터 -3이전까지 왼쪽으로 1씩 이동하여 슬라이싱, 결과 [8, 4]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="c1"># 0부터 -3이전까지 왼쪽으로 2씩 이동하여 슬라이싱, 결과 [8]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="c1"># 0부터 -3이전까지 왼쪽으로 2씩 이동하여 슬라이싱, 결과 [8 ,2]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># 0부터 3이전까지 왼쪽으로 1씩 이동하여 슬라이싱, [8, 4, 2, 6, 1, 3]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># step의 방향과 start end의 방향이 다름. </span>
</pre></div>
</div>
</div>
</div>
<section id="selection-sort">
<h2>선택 정렬 (Selection Sort)<a class="headerlink" href="#selection-sort" title="Link to this heading">#</a></h2>
<p>선택 정렬은 매 스텝마다 가장 작은 것을 선택해 앞으로 보내는 과정을 반복 수행하는 알고리즘이다. 즉, 데이터가 무작위로 있을 때, ‘아직 정렬되지 않은 범위 속 가장 작은 데이터’를 선택해 ‘아직 정렬되지 않은 범위의 맨 앞에 있는 데이터’와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복한다. 이렇게 “데이터”를 “선택”하여 바꾸는 작업을 통해 정렬하는 알고리즘을 (데이터) 선택 정렬이라고 한다.</p>
<p>데이터의 개수를 N=10이라고 할때, 다음 예제를 확인해보자.</p>
<section id="id1">
<h3>선택 정렬 예시<a class="headerlink" href="#id1" title="Link to this heading">#</a></h3>
<p>앞으로 그림에서, 회색 카드는 ‘현재 정렬되지 않은 데이터 중에서 가장 작은 데이터’를 의미하며, 하늘색 카드는 ‘이미 정렬된 데이터’를 의미한다.</p>
<p><strong>Step 1</strong>
<img alt="1" src="../../_images/120.png" /></p>
<p>초기 단계에서는 모든 데이터가 정렬되어 있지 않으므로, 전체 중에서 가장 작은 데이터를 선택한다.
‘7’: current element to be swapped (the first element in the remaining unordered section)
‘0’: smallest element in the remaining unsorted section</p>
<p>위의 데이터 ‘0’과 ‘7’를 바꾼다.</p>
<p><strong>Step 2</strong></p>
<p><img alt="2" src="../../_images/217.png" /></p>
<p>데이터가 정렬되어 있지 않은 범위 중 가장 작은 데이터를 선택하여 현재 원소와 바꾼다.</p>
<p>‘5’: current element to be swapped (the first element in the remaining unordered section)
‘1’: smallest element in the remaining unsorted section</p>
<p><strong>Step 3</strong></p>
<p><img alt="3" src="../../_images/38.png" /></p>
<p>데이터가 정렬되어 있지 않은 범위 중 가장 작은 데이터를 선택하여 현재 원소와 바꾼다.</p>
<p>‘9’: current element to be swapped (the first element in the remaining unordered section)
‘2’: smallest element in the remaining unsorted section</p>
<p><strong>Step 4</strong></p>
<p><img alt="4" src="../../_images/46.png" /></p>
<p>데이터가 정렬되어 있지 않은 범위 중 가장 작은 데이터를 선택하여 현재 원소와 바꾼다.</p>
<p>‘7’: current element to be swapped (the first element in the remaining unordered section)
‘3’: smallest element in the remaining unsorted section</p>
<p><strong>Step 5</strong></p>
<p><img alt="5" src="../../_images/56.png" /></p>
<p>데이터가 정렬되어 있지 않은 범위 중 가장 작은 데이터를 선택하여 현재 원소와 바꾼다.</p>
<p>‘7’: current element to be swapped (the first element in the remaining unordered section)
‘4’: smallest element in the remaining unsorted section</p>
<p><strong>Step 6</strong></p>
<p><img alt="6" src="../../_images/65.png" /></p>
<p>데이터가 정렬되어 있지 않은 범위 중 가장 작은 데이터를 선택하여 현재 원소와 바꾼다.</p>
<p>‘5’: current element to be swapped (the first element in the remaining unordered section)
‘5’: smallest element in the remaining unsorted section</p>
<p><strong>Step 7</strong></p>
<p><img alt="7" src="../../_images/75.png" /></p>
<p>데이터가 정렬되어 있지 않은 범위 중 가장 작은 데이터를 선택하여 현재 원소와 바꾼다.</p>
<p>‘6’: current element to be swapped (the first element in the remaining unordered section)
‘6’: smallest element in the remaining unsorted section</p>
<p><strong>Step 8</strong></p>
<p><img alt="8" src="../../_images/84.png" /></p>
<p>데이터가 정렬되어 있지 않은 범위 중 가장 작은 데이터를 선택하여 현재 원소와 바꾼다.</p>
<p>‘9’: current element to be swapped (the first element in the remaining unordered section)
‘7’: smallest element in the remaining unsorted section</p>
<p><strong>Step 9</strong></p>
<p><img alt="9" src="../../_images/93.png" /></p>
<p>데이터가 정렬되어 있지 않은 범위 중 가장 작은 데이터를 선택하여 현재 원소와 바꾼다.</p>
<p>‘9’: current element to be swapped (the first element in the remaining unordered section)
‘8’: smallest element in the remaining unsorted section</p>
<p><strong>Step 10</strong></p>
<p><img alt="10" src="../../_images/103.png" /></p>
<p>데이터가 정렬되어 있지 않은 범위 중 가장 작은 데이터를 선택하여 현재 원소와 바꾼다.</p>
<p>‘9’: current element to be swapped (the first element in the remaining unordered section)
‘9’: smallest element in the remaining unsorted section</p>
</section>
<section id="id2">
<h3>선택 정렬 코드 및 시간 복잡도<a class="headerlink" href="#id2" title="Link to this heading">#</a></h3>
<div class="dropdown admonition">
<p class="admonition-title">selection sort source code</p>
<div class="literal-block-wrapper docutils container" id="id13">
<div class="code-block-caption"><span class="caption-number">예시 31 </span><span class="caption-text">selection sort python source code</span><a class="headerlink" href="#id13" title="Link to this code">#</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
  <span class="n">min_index</span> <span class="o">=</span> <span class="n">i</span> 
  <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
      <span class="n">min_index</span> <span class="o">=</span> <span class="n">j</span> 
  
  <span class="c1"># SWAP</span>
  <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_index</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> 

<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>위의 구현 방식으로 연산 횟수는 (N) + (N-1) + (N-2) + … + 2 로 볼 수 있다. 따라서 N(N+1)/2로 연산을 수행한다고 가능하면 이는 간단히 O(<span class="math notranslate nohighlight">\(N^2\)</span>)로 표현할 수 있다.
이러한 선택 정렬은 기본 정렬 라이브러리를 포함하여 뒤에서 다룰 알고리즘과 비교했을 때 매우 비효율적이다. 다만, 특정한 리스트에서 가장 적은 데이터를 찾는 일이 코딩 테스트에서 잦으므로 선택 정렬 소스코드 형태에 익숙해질 필요가 있다. 자주 작성하여서 선택 정렬 소스코드에 익숙해지자.</p>
</section>
</section>
<section id="insertion-sort">
<h2>삽입 정렬 (Insertion Sort)<a class="headerlink" href="#insertion-sort" title="Link to this heading">#</a></h2>
<p>삽입 정렬은 데이터를 하나씩 확인하여, 각 데이터를 삽입하기에 적절한 “위치”는 어디일까? 라는 접근 방법을 가진 알고리즘이다. 삽입 정렬은 필요할 때만 위치를 바꾸므로 ‘데이터가 거의 정렬되어 있을 때’ 훨씬 효율적이다. 위에서 살펴본 것처럼 선택 정렬은 현재 데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 위치를 바꾸지만 삽입 정렬은 아니다.</p>
<p>삽입 정렬 특징</p>
<ul class="simple">
<li><p>특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정</p></li>
<li><p>선택 정렬처럼 언제나 모든 원소를 비교하고 위치를 바꾸지 않는다.</p></li>
</ul>
<section id="id3">
<h3>삽입 정렬 예시<a class="headerlink" href="#id3" title="Link to this heading">#</a></h3>
<p><strong>Step 1</strong></p>
<p><img alt="11" src="../../_images/1110.png" /></p>
<p>삽입 정렬은 두 번째 데이터부터 시작한다. 왜냐하면 첫번째 데이터는 그 자체로 정렬되어 있다고 판단하기 때문이다.</p>
<p><strong>Step 2</strong>
<img alt="12" src="../../_images/123.png" /></p>
<p>첫 번째 데이터 ‘7’은 그 자체로 정렬되어 있다고 판단하고, 두 번째 데이터인 ‘5’가 어떤 위치가 들어갈지 판단한다. ‘7’의 왼쪽으로 들어가거나 (기존 ‘7’의 위치) 혹은 오른쪽으로 들어가는 두 경우 (현재 ‘5’의 위치)만 존재한다. 우리는 카드를 오름차순으로 정렬하고자 하므로 ‘7’의 왼쪽에 삽입한다.</p>
<p>** 그림에서 인덱스는 현재 수가 있는 자리의 왼쪽 화살표로 표시됨.</p>
<p><strong>Step 3</strong>
<img alt="13" src="../../_images/132.png" />
‘9’가 들어갈 위치를 판단해야한다. 삽입될 수 있는 총 위치는 3가지이며 파란색 화살표로 9가 들어갈 위치를 표시하지만, 원래 자리이기 때문에 그대로둔다.</p>
<p><strong>Step 4</strong>
<img alt="14" src="../../_images/142.png" />
‘0’이 들어갈 위치를 판단해야한다. 파란색 화살표 자리 즉, 현재 ‘5’가 있는 위치에 삽입한다.</p>
<p><strong>Step 5</strong>
<img alt="15" src="../../_images/152.png" />
‘3’이 들어갈 위치를 판단해야한다. 파란색 화살표 자리 즉, 현재 ‘5’가 있는 위치에 삽입한다.</p>
<p><strong>Step 6</strong>
<img alt="16" src="../../_images/162.png" />
‘1’이 들어갈 위치를 판단해야한다. 파란색 화살표 자리 즉, 현재 ‘3’이 있는 위치에 삽입한다.</p>
<p><strong>중략</strong>
중간 과정을 생략한다.</p>
<p><strong>Step 7</strong>
<img alt="17" src="../../_images/172.png" />
‘4’가 들어갈 위치를 판단한다. ‘5’의 자리에 삽입한다.</p>
<p><strong>Step 8</strong>
<img alt="18" src="../../_images/182.png" />
‘8’이 들어갈 위치를 판단한다. ‘9’의 자리에 삽입한다.</p>
<p><strong>Step 9</strong>
<img alt="19" src="../../_images/192.png" />
이와 같이 적절한 위치에 삽입하는 과정을 N-1번 반복하게 되면 위와 같이 모든 데이터가 정렬된 것을 확인할 수 있다.</p>
</section>
<section id="id4">
<h3>삽입 정렬 코드 및 시간 복잡도<a class="headerlink" href="#id4" title="Link to this heading">#</a></h3>
<p>삽입 정렬에서, 정렬이 이루어져 있는 원소들 (파란색)은 항상 오름차순을 유지하고 있기 땜누에, 현재 특정한 데이터가 삽입될 위치를 선정할때, (삽입될 위치를 찾기 위하여 왼쪽으로 한칸씩 이동할때) 삽입될 데이터보다 작은 데이터를 만나면 그 위치에서 멈추면 된다.</p>
<div class="dropdown admonition">
<p class="admonition-title">code for insertion sort</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># 인덱스 i부터 1까지 감소하며 반복하는 문법 </span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># 한 칸씩 왼쪽으로 이동 </span>
            <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># 자기보다 작은 데이터를 만나면 그 위치에서 멈춤 </span>
            <span class="k">break</span> 

<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>위의 코드에서 드는 질문은, 왜 list.insert(index, value) 함수를 쓰지 않는가?이다. 즉, 최종 위치를 찾아서 그곳에 현재 원소를 넣으면 안되는가? 아래 두 가지 이유를 들 수 있다.</p>
<p>(1) 시간 복잡도 면에서 비슷하거나 더 느림</p>
<ul class="simple">
<li><p>insert()를 쓰면 내부적으로 리스트의 모든 원소를 한 칸씩 뒤로 미는 연산(O(N)) 이 발생합니다.</p></li>
<li><p>그런데 어차피 삽입 정렬도 O(N²)이기 때문에, 굳이 insert()로 더 많은 내부 처리를 할 필요가 없어요.</p></li>
</ul>
<p>(2) 교환(swap) 기반 구현이 구조적으로 더 명확함</p>
<ul class="simple">
<li><p>삽입 정렬은 배열을 직접 순회하면서 인접 원소를 비교하고 교환하는 구조로 되어 있어요.</p></li>
<li><p>이 방식이 언어나 자료구조가 달라도 동일하게 동작하는 일반적인 알고리즘 형태라서, 교육·면접용 코드에서도 swap으로 표현합니다.</p></li>
</ul>
<p>삽입 정렬의 시간 복잡도는 O(N^2)으로, 선택 정렬과 마찬가지로 반복문이 2번 중첩되어 있다. 하지만 꼭 기억해야할 점은 선택 정렬과 다르게, 현재 리스트의 데이터가 거의 정렬 되어 있는 상태라면 최선의 경우 O(N)의 시간 복잡도를 가질 수 있다. 다음에 배울 퀵 정렬과 비교했을 때 보통은 삽입 정렬이 비효율적이나 정렬이 거의 되어 있는 상황에서는 퀵 정렬 알고리즘보다 더 강력하다.</p>
<div class="important admonition">
<p class="admonition-title">Algorithm summary of insertion sort</p>
<p>삽입 정렬 알고리즘 정리</p>
<ul class="simple">
<li><p>리스트의 두 번째 원소부터 시작해서, 그 앞쪽 부분(이미 정렬된 부분) 에서 자신이 들어갈 적절한 위치를 찾은 뒤 삽입하는 방식</p></li>
<li><p>즉, arr[0:i] 구간은 항상 정렬된 상태를 유지하면서 arr[i]를 그 안에 알맞게 “넣는” 과정을 반복합니다.</p></li>
<li><p>시간 복잡도: O(<span class="math notranslate nohighlight">\(N^2\)</span>)</p></li>
</ul>
</div>
</section>
</section>
<section id="quick-sort">
<h2>퀵 정렬 (Quick Sort)<a class="headerlink" href="#quick-sort" title="Link to this heading">#</a></h2>
<p>퀵 정렬은 정렬 알고리즘 중에서 가장 많이 사용되는 알고리즘이다. <em><strong>퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식</strong></em>으로 동작한다. 이해하는데 오래걸리지만, 원리를 이해하면 병합 정렬, 힙 정럴 등 다른 고급 정렬 기법에 비해 쉽게 소스코드를 작성할 수 있다.</p>
<p>피벗(Pivot)이라는 개념이 등장하는데, 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 ‘기준’을 바로 피벗이라고 표현한다. 퀵 정렬을 수행하기 전에는 피벗을 어떻게 설정할 것인지 미리 명시해야 한다. 사실 퀵 정렬은 피벗 설정, 리스트 분할 방법에 따라 여러 가지 방식으로 나뉘는데, 오늘 수업에서는 가장 대표적인 분할 방식인 **호어 분할(Hoare Partition) 방식을 기준으로 퀵 정렬을 설명하겠다.</p>
<p><strong>호어 분할 방식</strong></p>
<ul class="simple">
<li><p>피벗 설정: 리스트에서 첫 번째 데이터를 피벗으로 정한다.</p></li>
<li><p>정렬 방식: 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾는다. 그 다음 큰 데이터와 작은 데이터의 위치를 서로 교환해준다. 이 과정을 반복하면 ‘피벗’에 대하여 정렬이 수행된다.</p></li>
</ul>
<p>다음과 같이 초기 데이터가 구성되어있다고 가정해보자. 해당 알고리즘을 파트 1, 2, 3로 나누어서 살펴보겠다.</p>
<p><img alt="20" src="../../_images/201.png" /></p>
<section id="id5">
<h3>파트 1<a class="headerlink" href="#id5" title="Link to this heading">#</a></h3>
<p><strong>Step 1</strong>
<img alt="21" src="../../_images/218.png" /></p>
<p>피벗: 리스트의 첫 번째 데이터인 ‘5’
피벗의 왼쪽: 왼쪽에서부터 ‘5’보다 큰 데이터 선택 ‘7’
피벗의 오른쪽: 오른쪽에서부터 ‘5’보다 작은 데이터 선택 ‘4’
swap: 위에서 선택된 ‘7’과 ‘4’의 위치를 서로 변경</p>
<p><strong>Step 2</strong>
<img alt="22" src="../../_images/222.png" /></p>
<p>피벗: 리스트의 첫 번째 데이터인 ‘5’
피벗의 왼쪽: 아까 바꿨던 위치에서부터 ‘5’보다 큰 데이터 선택 ‘9’
피벗의 오른쪽: 아까 바꿨던 위치에서부터’5’보다 작은 데이터 선택 ‘2’
swap: 위에서 선택된 ‘9’과 ‘2’의 위치를 서로 변경</p>
<p><strong>Step 3</strong>
<img alt="23" src="../../_images/231.png" /></p>
<p>피벗: 리스트의 첫 번째 데이터인 ‘5’
피벗의 왼쪽: 아까 바꿨던 위치에서부터 ‘5’보다 큰 데이터 선택 ‘6’
피벗의 오른쪽: 아까 바꿨던 위치에서부터’5’보다 작은 데이터 선택 ‘1’
-&gt; 이 때 현재 왼쪽에서부터 찾는 값과 오른쪽에서부터 찾는 값의 위치가 서로 엇갈린 것을 알 수 있다. 이렇게 두 값의 위치가 엇갈린 경우에는 ‘작은 데이터’와 ‘피벗’의 위치를 서로 변경한다.
swap: 위에서 선택된 ‘9’과 ‘2’의 위치를 서로 변경</p>
<p><strong>Step 4: 분할 완료</strong>
<img alt="24" src="../../_images/241.png" /></p>
<p>이와 같이 ‘피벗’이 이동한 상태에 도달하면 분할 완료이다. 분할 완료 후에는 위의 그림처럼 피벗 데이터의 왼쪽 데이터는 모두 피벗 값인 ‘5’보다 작고, 오른쪽에 있는 데이터는 모두 ‘5’보다 크다.</p>
<p>즉, 분할 (Divide) 또는 파티션 (Partition)이란, 피벗의 왼쪽에는 피벗보다 작은 데이터가 위치하고, 피벗의 오른쪽에는 피벗보다 큰 데이터가 위치하도록 하는 작업을 일컫는다.</p>
</section>
<section id="id6">
<h3>파트 2: 분할 완료된 피벗의 왼쪽 리스트<a class="headerlink" href="#id6" title="Link to this heading">#</a></h3>
<p>분할 완료된 피벗의 왼쪽 리스트에서는 다음과 같이 정렬이 진행되며 구체적인 정렬과정은 동일하다.
<img alt="25" src="../../_images/251.png" /></p>
</section>
<section id="id7">
<h3>파트 3: 분할 완료된 피벗의 오른쪽 리스트<a class="headerlink" href="#id7" title="Link to this heading">#</a></h3>
<p>분할 완료된 피벗의 오른쪽 리스트에서는 다음과 같이 정렬이 진행되며 구체적인 정렬과정은 동일하다. 아래 그림에서는 첫 단계에서, 오른쪽과 왼쪽의 데이터가 서로 엇갈리는 지점에는 작은 데이터와 피벗의 데이터가 동일하다. 따라서, swap하고 난 후 분할 완료된 리스트는 첫 리스트와 동일함을 알 수 있다.
<img alt="26" src="../../_images/261.png" /></p>
<p>특정한 리스트에서 피벗을 설정하여 정렬을 수행한 이후, 피벗을 기준으로 왼쪽 리스트와 오른쪽 리스트에서 각각 다시 정렬 수행한다. 재귀 함수와 동작 원리가 같고, 따라서, 종료 조건이 필요하다. 퀵 정렬이 끝나는 조건은 <em><strong>리스트의 개수가 1개</strong></em>인 경우이다. 리스트의 원소가 1개라면, 이미 정렬되어 있다고 간주할 수 있으며 분할이 불가능하다.</p>
</section>
<section id="id8">
<h3>퀵 정렬 전체 정리 과정 그림<a class="headerlink" href="#id8" title="Link to this heading">#</a></h3>
<p><img alt="27" src="../../_images/271.png" /></p>
</section>
<section id="id9">
<h3>퀵 정렬 소스코드 및 시간 복잡도<a class="headerlink" href="#id9" title="Link to this heading">#</a></h3>
<div class="dropdown admonition">
<p class="admonition-title">source code for Quick sort</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">quick_sort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">:</span>  <span class="c1"># Stop when the subarray has one or zero elements</span>
        <span class="k">return</span>

    <span class="n">pivot</span> <span class="o">=</span> <span class="n">start</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">end</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Move left pointer until you find an element greater than the pivot</span>
        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="ow">and</span> <span class="n">array</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">array</span><span class="p">[</span><span class="n">pivot</span><span class="p">]:</span>
            <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Move right pointer until you find an element smaller than the pivot</span>
        <span class="k">while</span> <span class="n">right</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">array</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">array</span><span class="p">[</span><span class="n">pivot</span><span class="p">]:</span>
            <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">array</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">pivot</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">array</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>

    <span class="c1"># After partitioning, recursively sort the left and right subarrays</span>
    <span class="n">quick_sort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">quick_sort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

<span class="n">quick_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>퀵 정렬의 평균 시간 복잡도는 O(NlogN)이다. 앞선 두 정렬 알고리즘에 비해 매우 빠른 편이다. 간단히 이런 시간 복잡도를 가지는 이유에 대해서 설명해보자면, 데이터의 개수가 8개라고 가정하고 다음과 같이 정확히 절반씩 나눈다고 도식화를 해보자. 이때 ‘높이’를 확인해보면, 데이터의 개수가 N개일 때 높이는 약 logN이라고 판단할 수 있다. Here, the “height” of the recursion tree refers to the depth of recursive partitioning, not the number of swaps or partitions performed.</p>
<p>즉,</p>
<ol class="arabic simple">
<li><p>한 번의 분할(partition) 과정에서 모든 원소(N개) 를 한 번씩 비교하므로,한 단계(partition depth)당 O(N) 의 시간이 걸립니다.</p></li>
<li><p>이상적인 경우(매번 절반씩 나뉜다면), 전체 트리의 높이는 log₂N 단계가 됩니다.</p></li>
<li><p>따라서 총 수행 시간은 O(N) * O(log N) = O(N log N) 이 됩니다.</p></li>
</ol>
<p>즉, 아래 그림에서 “높이 = 재귀 깊이(분할 단계 수)”이고, 각 단계마다 N개의 비교가 일어나는 구조입니다.</p>
<p><img alt="28" src="../../_images/281.png" /></p>
<p>퀵 정렬의 재귀는 두 방향으로 뻗지만, 각 단계에서 처리되는 총 원소 수의 합은 항상 N이므로, 전체 시간은 O(N)(단계당) × O(log N)(단계 수) = O(N log N) 이 된다.</p>
<p>일반적으로 컴퓨터 과학에서 log의 의미는 밑이 2인 로그를 의미한다. 즉, <span class="math notranslate nohighlight">\(log_{2}N\)</span>을 의미하며 데이터의 개수 1000일 때, <span class="math notranslate nohighlight">\(log_{2}N\)</span>는 10 정도이다. 즉, N=1000일 때 10은 상대적으로 매우 작은 수이다. 데이터의 개수가 많을 수록 차이는 매우 극명하게 드러난다.</p>
</section>
</section>
<section id="id10">
<h2>계수 정렬<a class="headerlink" href="#id10" title="Link to this heading">#</a></h2>
</section>
<section id="id11">
<h2>파이썬의 정렬 라이브러리<a class="headerlink" href="#id11" title="Link to this heading">#</a></h2>
</section>
<section id="id12">
<h2>정리<a class="headerlink" href="#id12" title="Link to this heading">#</a></h2>
<div class="admonition-summary admonition">
<p class="admonition-title">Summary</p>
<ul class="simple">
<li><p>선택 정렬: swap할 “데이터”를 선택</p></li>
<li><p>삽입 정렬: Swap할 “인덱스”를 선택</p></li>
<li><p>퀵 정럴: 특정한 리스트에서 피벗을 설정하여 정렬을 수행한 이후, 피벗을 기준으로 왼쪽 리스트와 오른쪽 리스트에서 각각 다시 정렬 수행.</p></li>
</ul>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./_pages/theory"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="5_shortest_path.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">이전</p>
        <p class="prev-next-title">Lecture 5-1. Shortest Path</p>
      </div>
    </a>
    <a class="right-next"
       href="../practice/1_implementationPS.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">다음</p>
        <p class="prev-next-title">Lecture 1-2. 구현 실습</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> 내용
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#selection-sort">선택 정렬 (Selection Sort)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">선택 정렬 예시</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">선택 정렬 코드 및 시간 복잡도</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#insertion-sort">삽입 정렬 (Insertion Sort)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">삽입 정렬 예시</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">삽입 정렬 코드 및 시간 복잡도</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#quick-sort">퀵 정렬 (Quick Sort)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">파트 1</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">파트 2: 분할 완료된 피벗의 왼쪽 리스트</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">파트 3: 분할 완료된 피벗의 오른쪽 리스트</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">퀵 정렬 전체 정리 과정 그림</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">퀵 정렬 소스코드 및 시간 복잡도</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">계수 정렬</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">파이썬의 정렬 라이브러리</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">정리</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
으로 Daye Lee
</p>

  </div>
  
  <div class="footer-item">
    

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>