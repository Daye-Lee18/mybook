
<!DOCTYPE html>


<html lang="ko" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Lecture 6-1. 정렬 &#8212; 말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css?v=6644e6bb" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=9c59b310" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=ae323b5b"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="../../_static/translations.js?v=e33e7ba0"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_pages/theory/6_sort';</script>
    <script src="https://unpkg.com/jupyterquiz@1.1.8/dist/jupyterquiz.min.js"></script>
    <link rel="icon" href="../../_static/favicon.png"/>
    <link rel="index" title="색인" href="../../genindex.html" />
    <link rel="search" title="검색" href="../../search.html" />
    <link rel="next" title="Lecture 1-2. 구현 실습" href="../practice/1_implementationPS.html" />
    <link rel="prev" title="Lecture 5-1. Shortest Path" href="5_shortest_path.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="ko"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/mylogo.png" class="logo__image only-light" alt="말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업 - Home"/>
    <script>document.write(`<img src="../../_static/mylogo.png" class="logo__image only-dark" alt="말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업 - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="검색" aria-label="검색" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">검색</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Welcome to 말레이시아 5급 IT 수업
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">이론</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="0_tips.html">문제 풀이 순서 팁 (Tips)</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_implementation.html">Lecture 1-1. 구현</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_DFS_BFS.html">Lecture 2-1. DFS/BFS</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_backtracking.html">Lecture 3-1. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_DP.html">Lecture 4-1. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="5_shortest_path.html">Lecture 5-1. Shortest Path</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Lecture 6-1. 정렬</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">실습</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../practice/1_implementationPS.html">Lecture 1-2. 구현 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practice/2_DFS_BFSPS.html">Lecture 2-2. DFS/BFS 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practice/3_backtrackingPS.html">Lecture 3-2. Backtracking 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practice/4_DPPS.html">Lecture 4-2. DP 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practice/5_shortest_pathPS.html">Lecture 5-2. Shortest Path 실습</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">시험</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../exams/midterm_student.html">Midterm</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="이 페이지 다운로드">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/_pages/theory/6_sort.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="소스 파일 다운로드"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="PDF로 인쇄"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="전체 화면으로보기"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="검색" aria-label="검색" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Lecture 6-1. 정렬</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> 내용 </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#selection-sort">선택 정렬 (Selection Sort)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">선택 정렬 예시</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">선택 정렬 코드 및 시간 복잡도</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#insertion-sort">삽입 정렬 (Insertion Sort)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">삽입 정렬 예시</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">삽입 정렬 코드 및 시간 복잡도</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#quick-sort">퀵 정렬 (Quick Sort)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">파트 1</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">파트 2: 분할 완료된 피벗의 왼쪽 리스트</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">파트 3: 분할 완료된 피벗의 오른쪽 리스트</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">퀵 정렬 전체 정리 과정 그림</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">퀵 정렬 소스코드 및 시간 복잡도</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#merge-sort">병합 정렬 (Merge sort)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#source-code">병합 정렬 source code 및 시간 복잡도</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#count-sort">계수 정렬 (Count sort)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">계수 정렬 예시</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">계수 정렬 코드 및 시간 &amp; 공간 복잡도</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">파이썬의 정렬 라이브러리</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">정리</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">예시 문제</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#merge-sorted-array">1. Merge sorted array</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#majority-element">2. Majority Element</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#contains-duplicate">3. Contains Duplicate</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="lecture-6-1">
<h1>Lecture 6-1. 정렬<a class="headerlink" href="#lecture-6-1" title="Link to this heading">#</a></h1>
<p>정렬 (Sorting)이란 데이터를 특정한 기준에 따라서 순서대로 나열하는 것을 말한다. 정렬 알고리즘으로 데이터를 정렬하면 이후에 배울 이진 탐색 (Binary Search)이 가능해진다. 이번 수업에서는 총 4가지 정렬 (선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬)에 대해서 배운다. 이 장에서 다루는 예제는 모두 <strong>오름차순 (Increasing order)</strong> 정렬을 수행한다고 가정한다. 내림차순 정렬은 리스트의 원소를 뒤집는 (Reverse) 메서드를 제공하기 때문에 그 방법을 사용하여 O(N) 시간 복잡도로 만들 수 있다.</p>
<div class="dropdown admonition">
<p class="admonition-title">Reversing ways in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># method 1 </span>
<span class="n">list1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">reversed_list</span> <span class="o">=</span> <span class="n">list1</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">reversed_list</span><span class="p">)</span>

<span class="c1"># method 2 </span>
<span class="n">list2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">list2</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span> <span class="c1"># list의 built-in 함수인 reverse()를 사용하면 original data가 없어지는 단점이 존재. </span>
<span class="nb">print</span><span class="p">(</span><span class="n">list2</span><span class="p">)</span> 
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">slicing a list</p>
<p>슬라이싱이란, 리스트 아이템의 일부를 자르는 것이다. 형식은 다음과 같다.</p>
<div class="note admonition">
<p class="admonition-title">slicing 방법</p>
<p>리스트변수[start:end:step]</p>
</div>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>항목</p></th>
<th class="head"><p>의미</p></th>
<th class="head"><p>기본값 step &gt; 0</p></th>
<th class="head"><p>기본값 step &lt; 0</p></th>
<th class="head"><p>중요포인트</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>start</p></td>
<td><p>시작인덱스</p></td>
<td><p>0</p></td>
<td><p>-1</p></td>
<td><p>포함됨</p></td>
</tr>
<tr class="row-odd"><td><p>end</p></td>
<td><p>끝인덱스</p></td>
<td><p>len(arr)</p></td>
<td><p>-(len(arr)+1)</p></td>
<td><p>포함안됨</p></td>
</tr>
<tr class="row-even"><td><p>step</p></td>
<td><p>간격 (양수면 오른쪽, 음수면 왼쪽으로 이동)</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>방향 결정자</p></td>
</tr>
</tbody>
</table>
</div>
<ul class="simple">
<li><p>핵식 개념 정리</p>
<ul>
<li><p>start, end, step 모두 생략 가능하다.</p></li>
<li><p>start와 end의 상대적 방향이 step과 맞아야한다.</p>
<ul>
<li><p>오른쪽으로 갈때는 start &lt; end 여야 값이 생기고,</p></li>
<li><p>왼쪽으로 갈때는 start &gt; end여야 값이 생긴다.</p></li>
<li><p>이 조건이 안 맞는 경우 빈 리스트 ([ ])가 나온다.</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>슬라이싱의 예시를 이용하여, 실제 어떻게 동작하는지 알아보자</p>
<div class="toggle docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span> <span class="c1"># 인덱스 3 이전까지 오른쪽으로 1씩 이동하여 슬라이싱, 결과 [5, 7, 9]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:])</span> <span class="c1"># -3부터 끝까지 오른쪽으로 1씩 이동하여 슬라이싱, 결과 [2, 4, 8]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span> <span class="c1"># 0부터 인덱스 -3 이전까지 오른쪽으로 1씩 이동하여 슬라이싱, 결과 [5, 7, 9, 0, 3, 1, 6]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># 0부터 -3이전까지 왼쪽으로 1씩 이동하여 슬라이싱, 결과 [8, 4]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="c1"># 0부터 -3이전까지 왼쪽으로 2씩 이동하여 슬라이싱, 결과 [8]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="c1"># 0부터 -3이전까지 왼쪽으로 2씩 이동하여 슬라이싱, 결과 [8 ,2]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># 0부터 3이전까지 왼쪽으로 1씩 이동하여 슬라이싱, [8, 4, 2, 6, 1, 3]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># step의 방향과 start end의 방향이 다름. </span>
</pre></div>
</div>
</div>
</div>
<section id="selection-sort">
<h2>선택 정렬 (Selection Sort)<a class="headerlink" href="#selection-sort" title="Link to this heading">#</a></h2>
<p>선택 정렬은 매 스텝마다 가장 작은 것을 선택해 앞으로 보내는 과정을 반복 수행하는 알고리즘이다. 즉, 데이터가 무작위로 있을 때, ‘아직 정렬되지 않은 범위 속 가장 작은 데이터’를 선택해 ‘아직 정렬되지 않은 범위의 맨 앞에 있는 데이터’와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복한다. 이렇게 “데이터”를 “선택”하여 바꾸는 작업을 통해 정렬하는 알고리즘을 (데이터) 선택 정렬이라고 한다.</p>
<p>데이터의 개수를 N=10이라고 할때, 다음 예제를 확인해보자.</p>
<section id="id1">
<h3>선택 정렬 예시<a class="headerlink" href="#id1" title="Link to this heading">#</a></h3>
<p>앞으로 그림에서, 회색 카드는 ‘현재 정렬되지 않은 데이터 중에서 가장 작은 데이터’를 의미하며, 하늘색 카드는 ‘이미 정렬된 데이터’를 의미한다.</p>
<p><strong>Step 1</strong>
<img alt="1" src="../../_images/120.png" /></p>
<p>초기 단계에서는 모든 데이터가 정렬되어 있지 않으므로, 전체 중에서 가장 작은 데이터를 선택한다.</p>
<ul class="simple">
<li><p>‘7’: current element to be swapped (the first element in the remaining unordered section)</p></li>
<li><p>‘0’: smallest element in the remaining unsorted section</p></li>
</ul>
<p>위의 데이터 ‘0’과 ‘7’를 바꾼다.</p>
<p><strong>Step 2</strong></p>
<p><img alt="2" src="../../_images/217.png" /></p>
<p>데이터가 정렬되어 있지 않은 범위 중 가장 작은 데이터를 선택하여 현재 원소와 바꾼다.</p>
<ul class="simple">
<li><p>‘5’: current element to be swapped (the first element in the remaining unordered section)</p></li>
<li><p>‘1’: smallest element in the remaining unsorted section</p></li>
</ul>
<p><strong>Step 3</strong></p>
<p><img alt="3" src="../../_images/38.png" /></p>
<p>데이터가 정렬되어 있지 않은 범위 중 가장 작은 데이터를 선택하여 현재 원소와 바꾼다.</p>
<ul class="simple">
<li><p>‘9’: current element to be swapped (the first element in the remaining unordered section)</p></li>
<li><p>‘2’: smallest element in the remaining unsorted section</p></li>
</ul>
<p><strong>Step 4</strong></p>
<p><img alt="4" src="../../_images/46.png" /></p>
<p>데이터가 정렬되어 있지 않은 범위 중 가장 작은 데이터를 선택하여 현재 원소와 바꾼다.</p>
<ul class="simple">
<li><p>‘7’: current element to be swapped (the first element in the remaining unordered section)</p></li>
<li><p>‘3’: smallest element in the remaining unsorted section</p></li>
</ul>
<p><strong>Step 5</strong></p>
<p><img alt="5" src="../../_images/56.png" /></p>
<p>데이터가 정렬되어 있지 않은 범위 중 가장 작은 데이터를 선택하여 현재 원소와 바꾼다.</p>
<ul class="simple">
<li><p>‘7’: current element to be swapped (the first element in the remaining unordered section)</p></li>
<li><p>‘4’: smallest element in the remaining unsorted section</p></li>
</ul>
<p><strong>Step 6</strong></p>
<p><img alt="6" src="../../_images/65.png" /></p>
<p>데이터가 정렬되어 있지 않은 범위 중 가장 작은 데이터를 선택하여 현재 원소와 바꾼다.</p>
<ul class="simple">
<li><p>‘5’: current element to be swapped (the first element in the remaining unordered section)</p></li>
<li><p>‘5’: smallest element in the remaining unsorted section</p></li>
</ul>
<p><strong>Step 7</strong></p>
<p><img alt="7" src="../../_images/75.png" /></p>
<p>데이터가 정렬되어 있지 않은 범위 중 가장 작은 데이터를 선택하여 현재 원소와 바꾼다.</p>
<ul class="simple">
<li><p>‘6’: current element to be swapped (the first element in the remaining unordered section)</p></li>
<li><p>‘6’: smallest element in the remaining unsorted section</p></li>
</ul>
<p><strong>Step 8</strong></p>
<p><img alt="8" src="../../_images/84.png" /></p>
<p>데이터가 정렬되어 있지 않은 범위 중 가장 작은 데이터를 선택하여 현재 원소와 바꾼다.</p>
<ul class="simple">
<li><p>‘9’: current element to be swapped (the first element in the remaining unordered section)</p></li>
<li><p>‘7’: smallest element in the remaining unsorted section</p></li>
</ul>
<p><strong>Step 9</strong></p>
<p><img alt="9" src="../../_images/93.png" /></p>
<p>데이터가 정렬되어 있지 않은 범위 중 가장 작은 데이터를 선택하여 현재 원소와 바꾼다.</p>
<ul class="simple">
<li><p>‘9’: current element to be swapped (the first element in the remaining unordered section)</p></li>
<li><p>‘8’: smallest element in the remaining unsorted section</p></li>
</ul>
<p><strong>Step 10</strong></p>
<p><img alt="10" src="../../_images/103.png" /></p>
<p>데이터가 정렬되어 있지 않은 범위 중 가장 작은 데이터를 선택하여 현재 원소와 바꾼다.</p>
<ul class="simple">
<li><p>9’: current element to be swapped (the first element in the remaining unordered section)</p></li>
<li><p>‘9’: smallest element in the remaining unsorted section</p></li>
</ul>
</section>
<section id="id2">
<h3>선택 정렬 코드 및 시간 복잡도<a class="headerlink" href="#id2" title="Link to this heading">#</a></h3>
<div class="dropdown admonition">
<p class="admonition-title">selection sort source code</p>
<div class="literal-block-wrapper docutils container" id="id15">
<div class="code-block-caption"><span class="caption-number">예시 31 </span><span class="caption-text">selection sort python source code</span><a class="headerlink" href="#id15" title="Link to this code">#</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
  <span class="n">min_index</span> <span class="o">=</span> <span class="n">i</span> 
  <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
      <span class="n">min_index</span> <span class="o">=</span> <span class="n">j</span> 
  
  <span class="c1"># SWAP</span>
  <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_index</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> 

<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>위의 구현 방식으로 연산 횟수는 (N) + (N-1) + (N-2) + … + 2 로 볼 수 있다. 따라서 N(N+1)/2로 연산을 수행한다고 가능하면 이는 간단히 O(<span class="math notranslate nohighlight">\(N^2\)</span>)로 표현할 수 있다.
이러한 선택 정렬은 기본 정렬 라이브러리를 포함하여 뒤에서 다룰 알고리즘과 비교했을 때 매우 비효율적이다. 다만, 특정한 리스트에서 가장 적은 데이터를 찾는 일이 코딩 테스트에서 잦으므로 선택 정렬 소스코드 형태에 익숙해질 필요가 있다. 자주 작성하여서 선택 정렬 소스코드에 익숙해지자.</p>
</section>
</section>
<section id="insertion-sort">
<h2>삽입 정렬 (Insertion Sort)<a class="headerlink" href="#insertion-sort" title="Link to this heading">#</a></h2>
<p>삽입 정렬은 데이터를 하나씩 확인하여, 각 데이터를 삽입하기에 적절한 “위치”는 어디일까? 라는 접근 방법을 가진 알고리즘이다. 삽입 정렬은 필요할 때만 위치를 바꾸므로 ‘데이터가 거의 정렬되어 있을 때’ 훨씬 효율적이다. 위에서 살펴본 것처럼 선택 정렬은 현재 데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 위치를 바꾸지만 삽입 정렬은 아니다.</p>
<p>삽입 정렬 특징</p>
<ul class="simple">
<li><p>특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정</p></li>
<li><p>선택 정렬처럼 언제나 모든 원소를 비교하고 위치를 바꾸지 않는다.</p></li>
</ul>
<section id="id3">
<h3>삽입 정렬 예시<a class="headerlink" href="#id3" title="Link to this heading">#</a></h3>
<p><strong>Step 1</strong></p>
<p><img alt="11" src="../../_images/1110.png" /></p>
<p>삽입 정렬은 두 번째 데이터부터 시작한다. 왜냐하면 첫번째 데이터는 그 자체로 정렬되어 있다고 판단하기 때문이다.</p>
<p><strong>Step 2</strong>
<img alt="12" src="../../_images/123.png" /></p>
<p>첫 번째 데이터 ‘7’은 그 자체로 정렬되어 있다고 판단하고, 두 번째 데이터인 ‘5’가 어떤 위치가 들어갈지 판단한다. ‘7’의 왼쪽으로 들어가거나 (기존 ‘7’의 위치) 혹은 오른쪽으로 들어가는 두 경우 (현재 ‘5’의 위치)만 존재한다. 우리는 카드를 오름차순으로 정렬하고자 하므로 ‘7’의 왼쪽에 삽입한다.</p>
<p>** 그림에서 인덱스는 현재 수가 있는 자리의 왼쪽 화살표로 표시됨.</p>
<p><strong>Step 3</strong>
<img alt="13" src="../../_images/132.png" />
‘9’가 들어갈 위치를 판단해야한다. 삽입될 수 있는 총 위치는 3가지이며 파란색 화살표로 9가 들어갈 위치를 표시하지만, 원래 자리이기 때문에 그대로둔다.</p>
<p><strong>Step 4</strong>
<img alt="14" src="../../_images/142.png" />
‘0’이 들어갈 위치를 판단해야한다. 파란색 화살표 자리 즉, 현재 ‘5’가 있는 위치에 삽입한다.</p>
<p><strong>Step 5</strong>
<img alt="15" src="../../_images/152.png" />
‘3’이 들어갈 위치를 판단해야한다. 파란색 화살표 자리 즉, 현재 ‘5’가 있는 위치에 삽입한다.</p>
<p><strong>Step 6</strong>
<img alt="16" src="../../_images/162.png" />
‘1’이 들어갈 위치를 판단해야한다. 파란색 화살표 자리 즉, 현재 ‘3’이 있는 위치에 삽입한다.</p>
<p><strong>중략</strong>
중간 과정을 생략한다.</p>
<p><strong>Step 7</strong>
<img alt="17" src="../../_images/172.png" />
‘4’가 들어갈 위치를 판단한다. ‘5’의 자리에 삽입한다.</p>
<p><strong>Step 8</strong>
<img alt="18" src="../../_images/182.png" />
‘8’이 들어갈 위치를 판단한다. ‘9’의 자리에 삽입한다.</p>
<p><strong>Step 9</strong>
<img alt="19" src="../../_images/192.png" />
이와 같이 적절한 위치에 삽입하는 과정을 N-1번 반복하게 되면 위와 같이 모든 데이터가 정렬된 것을 확인할 수 있다.</p>
</section>
<section id="id4">
<h3>삽입 정렬 코드 및 시간 복잡도<a class="headerlink" href="#id4" title="Link to this heading">#</a></h3>
<p>삽입 정렬에서, 정렬이 이루어져 있는 원소들 (파란색)은 항상 오름차순을 유지하고 있기 땜누에, 현재 특정한 데이터가 삽입될 위치를 선정할때, (삽입될 위치를 찾기 위하여 왼쪽으로 한칸씩 이동할때) 삽입될 데이터보다 작은 데이터를 만나면 그 위치에서 멈추면 된다.</p>
<div class="dropdown admonition">
<p class="admonition-title">code for insertion sort</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># 인덱스 i부터 1까지 감소하며 반복하는 문법 </span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># 한 칸씩 왼쪽으로 이동 </span>
            <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># 자기보다 작은 데이터를 만나면 그 위치에서 멈춤 </span>
            <span class="k">break</span> 

<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>위의 코드에서 드는 질문은, 왜 list.insert(index, value) 함수를 쓰지 않는가?이다. 즉, 최종 위치를 찾아서 그곳에 현재 원소를 넣으면 안되는가? 아래 두 가지 이유를 들 수 있다.</p>
<p>(1) 시간 복잡도 면에서 비슷하거나 더 느림</p>
<ul class="simple">
<li><p>insert()를 쓰면 내부적으로 리스트의 모든 원소를 한 칸씩 뒤로 미는 연산(O(N)) 이 발생합니다.</p></li>
<li><p>그런데 어차피 삽입 정렬도 O(N²)이기 때문에, 굳이 insert()로 더 많은 내부 처리를 할 필요가 없어요.</p></li>
</ul>
<p>(2) 교환(swap) 기반 구현이 구조적으로 더 명확함</p>
<ul class="simple">
<li><p>삽입 정렬은 배열을 직접 순회하면서 인접 원소를 비교하고 교환하는 구조로 되어 있어요.</p></li>
<li><p>이 방식이 언어나 자료구조가 달라도 동일하게 동작하는 일반적인 알고리즘 형태라서, 교육·면접용 코드에서도 swap으로 표현합니다.</p></li>
</ul>
<p>삽입 정렬의 시간 복잡도는 O(N^2)으로, 선택 정렬과 마찬가지로 반복문이 2번 중첩되어 있다. 하지만 꼭 기억해야할 점은 선택 정렬과 다르게, 현재 리스트의 데이터가 거의 정렬 되어 있는 상태라면 최선의 경우 O(N)의 시간 복잡도를 가질 수 있다. 다음에 배울 퀵 정렬과 비교했을 때 보통은 삽입 정렬이 비효율적이나 정렬이 거의 되어 있는 상황에서는 퀵 정렬 알고리즘보다 더 강력하다.</p>
<div class="important admonition">
<p class="admonition-title">Algorithm summary of insertion sort</p>
<p>삽입 정렬 알고리즘 정리</p>
<ul class="simple">
<li><p>리스트의 두 번째 원소부터 시작해서, 그 앞쪽 부분(이미 정렬된 부분) 에서 자신이 들어갈 적절한 위치를 찾은 뒤 삽입하는 방식</p></li>
<li><p>즉, arr[0:i] 구간은 항상 정렬된 상태를 유지하면서 arr[i]를 그 안에 알맞게 “넣는” 과정을 반복합니다.</p></li>
<li><p>시간 복잡도: O(<span class="math notranslate nohighlight">\(N^2\)</span>)</p></li>
</ul>
</div>
</section>
</section>
<section id="quick-sort">
<h2>퀵 정렬 (Quick Sort)<a class="headerlink" href="#quick-sort" title="Link to this heading">#</a></h2>
<p>퀵 정렬은 정렬 알고리즘 중에서 가장 많이 사용되는 알고리즘이다. <em><strong>퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식</strong></em>으로 동작한다. 이해하는데 오래걸리지만, 원리를 이해하면 병합 정렬, 힙 정럴 등 다른 고급 정렬 기법에 비해 쉽게 소스코드를 작성할 수 있다.</p>
<p>피벗(Pivot)이라는 개념이 등장하는데, 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 ‘기준’을 바로 피벗이라고 표현한다. 퀵 정렬을 수행하기 전에는 피벗을 어떻게 설정할 것인지 미리 명시해야 한다. 사실 퀵 정렬은 피벗 설정, 리스트 분할 방법에 따라 여러 가지 방식으로 나뉘는데, 오늘 수업에서는 가장 대표적인 분할 방식인 <strong>호어 분할(Hoare Partition)</strong> 방식을 기준으로 퀵 정렬을 설명하겠다.</p>
<p><strong>호어 분할 방식</strong></p>
<ul class="simple">
<li><p>피벗 설정: 리스트에서 첫 번째 데이터를 피벗으로 정한다.</p></li>
<li><p>정렬 방식: 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾는다. 그 다음 큰 데이터와 작은 데이터의 위치를 서로 교환해준다. 이 과정을 반복하면 ‘피벗’에 대하여 정렬이 수행된다.</p></li>
</ul>
<p>다음과 같이 초기 데이터가 구성되어있다고 가정해보자. 해당 알고리즘을 파트 1, 2, 3로 나누어서 살펴보겠다.</p>
<p><img alt="20" src="../../_images/201.png" /></p>
<section id="id5">
<h3>파트 1<a class="headerlink" href="#id5" title="Link to this heading">#</a></h3>
<p><strong>Step 1</strong>
<img alt="21" src="../../_images/218.png" /></p>
<ul class="simple">
<li><p>피벗: 리스트의 첫 번째 데이터인 ‘5’</p></li>
<li><p>피벗의 왼쪽: 왼쪽에서부터 ‘5’보다 큰 데이터 선택 ‘7’</p></li>
<li><p>피벗의 오른쪽: 오른쪽에서부터 ‘5’보다 작은 데이터 선택 ‘4’</p></li>
<li><p>swap: 위에서 선택된 ‘7’과 ‘4’의 위치를 서로 변경</p></li>
</ul>
<p><strong>Step 2</strong>
<img alt="22" src="../../_images/222.png" /></p>
<ul class="simple">
<li><p>피벗: 리스트의 첫 번째 데이터인 ‘5’</p></li>
<li><p>피벗의 왼쪽: 아까 바꿨던 위치에서부터 ‘5’보다 큰 데이터 선택 ‘9’</p></li>
<li><p>피벗의 오른쪽: 아까 바꿨던 위치에서부터’5’보다 작은 데이터 선택 ‘2’</p></li>
<li><p>swap: 위에서 선택된 ‘9’과 ‘2’의 위치를 서로 변경</p></li>
</ul>
<p><strong>Step 3</strong>
<img alt="23" src="../../_images/231.png" /></p>
<ul class="simple">
<li><p>피벗: 리스트의 첫 번째 데이터인 ‘5’</p></li>
<li><p>피벗의 왼쪽: 아까 바꿨던 위치에서부터 ‘5’보다 큰 데이터 선택 ‘6’</p></li>
<li><p>피벗의 오른쪽: 아까 바꿨던 위치에서부터’5’보다 작은 데이터 선택 ‘1’ -&gt; 이 때 현재 왼쪽에서부터 찾는 값과 오른쪽에서부터 찾는 값의 위치가 서로 엇갈린 것을 알 수 있다. 이렇게 두 값의 위치가 엇갈린 경우에는 ‘작은 데이터’와 ‘피벗’의 위치를 서로 변경한다.</p></li>
<li><p>swap: 위에서 선택된 ‘9’과 ‘2’의 위치를 서로 변경</p></li>
</ul>
<p><strong>Step 4: 분할 완료</strong>
<img alt="24" src="../../_images/241.png" /></p>
<p>이와 같이 ‘피벗’이 이동한 상태에 도달하면 분할 완료이다. 분할 완료 후에는 위의 그림처럼 피벗 데이터의 왼쪽 데이터는 모두 피벗 값인 ‘5’보다 작고, 오른쪽에 있는 데이터는 모두 ‘5’보다 크다.</p>
<p>즉, 분할 (Divide) 또는 파티션 (Partition)이란, 피벗의 왼쪽에는 피벗보다 작은 데이터가 위치하고, 피벗의 오른쪽에는 피벗보다 큰 데이터가 위치하도록 하는 작업을 일컫는다.</p>
</section>
<section id="id6">
<h3>파트 2: 분할 완료된 피벗의 왼쪽 리스트<a class="headerlink" href="#id6" title="Link to this heading">#</a></h3>
<p>분할 완료된 피벗의 왼쪽 리스트에서는 다음과 같이 정렬이 진행되며 구체적인 정렬과정은 동일하다.
<img alt="25" src="../../_images/251.png" /></p>
</section>
<section id="id7">
<h3>파트 3: 분할 완료된 피벗의 오른쪽 리스트<a class="headerlink" href="#id7" title="Link to this heading">#</a></h3>
<p>분할 완료된 피벗의 오른쪽 리스트에서는 다음과 같이 정렬이 진행되며 구체적인 정렬과정은 동일하다. 아래 그림에서는 첫 단계에서, 오른쪽과 왼쪽의 데이터가 서로 엇갈리는 지점에는 작은 데이터와 피벗의 데이터가 동일하다. 따라서, swap하고 난 후 분할 완료된 리스트는 첫 리스트와 동일함을 알 수 있다.
<img alt="26" src="../../_images/261.png" /></p>
<p>특정한 리스트에서 피벗을 설정하여 정렬을 수행한 이후, 피벗을 기준으로 왼쪽 리스트와 오른쪽 리스트에서 각각 다시 정렬 수행한다. 재귀 함수와 동작 원리가 같고, 따라서, 종료 조건이 필요하다. 퀵 정렬이 끝나는 조건은 <em><strong>리스트의 개수가 1개</strong></em>인 경우이다. 리스트의 원소가 1개라면, 이미 정렬되어 있다고 간주할 수 있으며 분할이 불가능하다.</p>
</section>
<section id="id8">
<h3>퀵 정렬 전체 정리 과정 그림<a class="headerlink" href="#id8" title="Link to this heading">#</a></h3>
<p><img alt="27" src="../../_images/271.png" /></p>
</section>
<section id="id9">
<h3>퀵 정렬 소스코드 및 시간 복잡도<a class="headerlink" href="#id9" title="Link to this heading">#</a></h3>
<div class="dropdown admonition">
<p class="admonition-title">source code for Quick sort</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">quick_sort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">:</span>  <span class="c1"># Stop when the subarray has one or zero elements</span>
        <span class="k">return</span>

    <span class="n">pivot</span> <span class="o">=</span> <span class="n">start</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">end</span> <span class="c1"># inclusive </span>

    <span class="c1"># pivot(start) _ _ _ _ end </span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># range check: end position까지 pivot과 비교 필요 </span>
        <span class="c1"># value check: Move left pointer until you find an element greater than the pivot</span>
        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="ow">and</span> <span class="n">array</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">array</span><span class="p">[</span><span class="n">pivot</span><span class="p">]:</span>
            <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># range check: right의 range는 start보다 커야함. </span>
        <span class="c1"># value check: Move right pointer until you find an element smaller than the pivot</span>
        <span class="k">while</span> <span class="n">right</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">array</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">array</span><span class="p">[</span><span class="n">pivot</span><span class="p">]:</span>
            <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">array</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">pivot</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">array</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>

    <span class="c1"># After partitioning, recursively sort the left and right subarrays</span>
    <span class="c1"># partition이 끝난 시점에 right가 pivot이 들어갈 정확한 위치를 가리킵니다.</span>
    <span class="n">quick_sort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">quick_sort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

<span class="n">quick_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>퀵 정렬의 평균 시간 복잡도는 O(NlogN)이다. 앞선 두 정렬 알고리즘에 비해 매우 빠른 편이다. 간단히 이런 시간 복잡도를 가지는 이유에 대해서 설명해보자면, 데이터의 개수가 8개라고 가정하고 다음과 같이 정확히 절반씩 나눈다고 도식화를 해보자. 이때 ‘높이’를 확인해보면, 데이터의 개수가 N개일 때 높이는 약 logN이라고 판단할 수 있다. Here, the “height” of the recursion tree refers to the depth of recursive partitioning, not the number of swaps or partitions performed.</p>
<p>즉,</p>
<ol class="arabic simple">
<li><p>한 번의 분할(partition) 과정에서 모든 원소(N개) 를 한 번씩 비교하므로,한 단계(partition depth)당 O(N) 의 시간이 걸립니다.</p></li>
<li><p>이상적인 경우(매번 절반씩 나뉜다면), 전체 트리의 높이는 log₂N 단계가 됩니다.</p></li>
<li><p>따라서 총 수행 시간은 O(N) * O(log N) = O(N log N) 이 됩니다.</p></li>
</ol>
<p>즉, 아래 그림에서 “높이 = 재귀 깊이(분할 단계 수)”이고, 각 단계마다 N개의 비교가 일어나는 구조입니다.</p>
<p><img alt="28" src="../../_images/281.png" /></p>
<p>퀵 정렬의 재귀 각 단계에서 처리되는 총 원소 수의 합은 항상 N이므로, 전체 시간은 O(N)(단계당) × O(log N)(단계 수) = O(N log N) 이 된다.</p>
<p>아래의 재귀 트리 (recursion tree)로 보면 이해가 쉽다.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>깊이</p></th>
<th class="head"><p>부분 배열 개수</p></th>
<th class="head"><p>각 배열의 크기</p></th>
<th class="head"><p>그 깊이의 총 연산량</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>N/2</p></td>
<td><p>2 * (N/2) = N</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>4</p></td>
<td><p>N/4</p></td>
<td><p>4 * (N/4) = N</p></td>
</tr>
<tr class="row-odd"><td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>log N</p></td>
<td><p>N</p></td>
<td><p>1</p></td>
<td><p>N</p></td>
</tr>
</tbody>
</table>
</div>
<p>일반적으로 컴퓨터 과학에서 log의 의미는 밑이 2인 로그를 의미한다. 즉, <span class="math notranslate nohighlight">\(log_{2}N\)</span>을 의미하며 데이터의 개수 1000일 때, <span class="math notranslate nohighlight">\(log_{2}N\)</span>는 10 정도이다. 즉, N=1000일 때 10은 상대적으로 매우 작은 수이다. 데이터의 개수가 많을 수록 차이는 매우 극명하게 드러난다.</p>
<p>다만, 퀵 정렬의 시간 복잡도에 대하여 한 가지 기억해둘 점이 있다. 바로 평균적으로 시간 복잡도가 O(NlogN)이지만 최악의 경우 시간 복잡도가 O(<span class="math notranslate nohighlight">\(N^2\)</span>)라는 것이다. 데이터가 무작위로 입력되는 경우 퀵 정렬은 빠르게 동작할 확률이 높다. 하지만, 우리가 사용한 방법처럼 리스트의 가장 왼쪽 데이터를 피벗으로 삼을 때, ‘이미 데이터가 정렬되어 있는 경우’에는 매우 느리게 동작한다. 즉, 삽입 정렬은 이미 데이터가 정렬되어 있는 겨웅에는 매우 빠르게 동작하고, 퀵 정렬은 그와 반대이다.</p>
<p>실제로 파이썬에서 기본 정렬 라이브러리를 이용하면 O(NlogN)을 보장해주기 때문에 크게 걱정하지 않아도 된다.</p>
</section>
</section>
<section id="merge-sort">
<h2>병합 정렬 (Merge sort)<a class="headerlink" href="#merge-sort" title="Link to this heading">#</a></h2>
<p>우선 병합 정렬과 퀵 정렬을 비교하면 다음과 같다.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>구분</p></th>
<th class="head"><p>병합 정렬 (Merge Sort)</p></th>
<th class="head"><p>퀵 정렬 (Quick Sort)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>정렬방식</p></td>
<td><p>분할 정복 (Divide &amp; Conquer) -&gt; 반으로 나누고, 정렬된 결과를 병합 (merge)</p></td>
<td><p>분할 정복 (Divide &amp; Conquer) -&gt; 피벗(pivot)을 기준으로 작은 값/큰 값으로 분할</p></td>
</tr>
<tr class="row-odd"><td><p>기준</p></td>
<td><p>단순히 절반으로 나눔</p></td>
<td><p>피벗 값에 따라 나눔</p></td>
</tr>
<tr class="row-even"><td><p>정렬 과정</p></td>
<td><p>분할 후 -&gt; 병합하며 정렬</p></td>
<td><p>분할하면서 -&gt; 정렬</p></td>
</tr>
<tr class="row-odd"><td><p>시간 복잡도</p></td>
<td><p>항상 O(NlogN)</p></td>
<td><p>평균 O(NlogN), 최악 O(<span class="math notranslate nohighlight">\(N^2\)</span>)</p></td>
</tr>
<tr class="row-even"><td><p>공간 복잡도</p></td>
<td><p>O(N) (추가배열필요)</p></td>
<td><p>O(logN) (재귀 스택만 사용)</p></td>
</tr>
<tr class="row-odd"><td><p>정렬 안정성</p></td>
<td><p>Stable (동일 값의 순서 유지됨)</p></td>
<td><p>Unstable</p></td>
</tr>
<tr class="row-even"><td><p>적합한 경우</p></td>
<td><p>대용량 데이터, 외부 정렬 (파일 단위 정렬 등)</p></td>
<td><p>메모리 제한이 있는 경우, 평균 성능이 중요할 때</p></td>
</tr>
</tbody>
</table>
</div>
<p>위의 테이블을 요약하자면, 병합 정렬을 항상 O(NlogN)을 보장하지만, 안정 정렬이지만, 메모리 공간을 추가로 사용한다. 또한 퀵 정렬은 보통 더 빠르지만 (캐시 효율, in-place), 데이터가 편향되면 O(<span class="math notranslate nohighlight">\(N^2\)</span>)로 느려진다.</p>
<p>이때 <em><strong>Stable Sort</strong></em>의 의미는 동일한 값을 가진 원소의 기존 순서가 유지되는 것을 의미한다. 예를 들어, 아래처럼 정렬할 때,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">Alice</span><span class="p">,</span> <span class="mi">90</span><span class="p">),</span> <span class="p">(</span><span class="n">Bob</span><span class="p">,</span> <span class="mi">90</span><span class="p">),</span> <span class="p">(</span><span class="n">Chris</span><span class="p">,</span> <span class="mi">80</span><span class="p">)]</span>
</pre></div>
</div>
<p>점수를 기준으로 오름차순 정렬하면</p>
<ul class="simple">
<li><p>Stable sort라면 <code class="docutils literal notranslate"><span class="pre">[(Chris,</span> <span class="pre">80),</span> <span class="pre">(Alice,</span> <span class="pre">90),</span> <span class="pre">(Bob,</span> <span class="pre">90)]</span></code></p></li>
<li><p>Unstable sort라면 <code class="docutils literal notranslate"><span class="pre">[(Chris,</span> <span class="pre">80),</span> <span class="pre">(Bob,</span> <span class="pre">90),</span> <span class="pre">(Alice,</span> <span class="pre">90)]</span></code>로 순서가 바뀔수도 있음.</p>
<ul>
<li><p>병합 정렬: 비교할 때 <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>로 구현하면 Stable</p></li>
<li><p>퀵정렬: 피벗 swap과정에서 순서가 깨지므로 Unstable</p></li>
</ul>
</li>
</ul>
<p>알고리즘의 작동 순서는 다음과 같다. <em><strong>반으로 나누고 -&gt; 각각 정렬 -&gt; 다시 합치기</strong></em> 과정을 반복한다.</p>
<ol class="arabic simple">
<li><p>분할 (Divide): 리스트를 반으로 나눈다.</p>
<ul class="simple">
<li><p>[8, 3, 5, 4, 7, 6, 1, 2] → [8,3,5,4] + [7,6,1,2]</p></li>
</ul>
</li>
<li><p>정복 (Conquer): 각 부분리스트를 재귀적으로 병합 정렬한다.</p>
<ul class="simple">
<li><p>[8,3,5,4] → [3,4,5,8]</p></li>
<li><p>[7,6,1,2] → [1,2,6,7]</p></li>
</ul>
</li>
<li><p>결합 (Combine/Merge): 두 정렬된 리스트를 하나로 병합한다.</p>
<ul class="simple">
<li><p>[3,4,5,8] + [1,2,6,7] → [1,2,3,4,5,6,7,8]</p></li>
</ul>
</li>
</ol>
<section id="source-code">
<h3>병합 정렬 source code 및 시간 복잡도<a class="headerlink" href="#source-code" title="Link to this heading">#</a></h3>
</section>
</section>
<section id="count-sort">
<h2>계수 정렬 (Count sort)<a class="headerlink" href="#count-sort" title="Link to this heading">#</a></h2>
<p>계수 정렬 (count sort) 알고리즘은 <em><strong>특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘</strong></em>이다. 계수 정렬은 데이터의 크기가 제한되어 있을 때에 한해서, 데이터의 개수가 매우 많더라도 빠르게 동작한다. 다음은 특정 조건에 대한 기술이다.</p>
<ol class="arabic simple">
<li><p>데이터의 개수가 N, 데이터 중 최댓값이 K일때, 데이터의 크기 범위가 제한되어 ‘정수 형태’로 표현할 수 있을때만 사용할 수 있다.</p></li>
<li><p>가장 큰 데이터와 가장 작은 데이터의 차이가 너무 크다면 계수 정렬은 사용할 수 없다. (모든 범위를 담을 수 있는 크기의 리스트를 선언해야하기 때문, 그 차이가 예를 들어 1,000,000이라면 총 1,000,001개의 데이터가 들어갈 수 있는 리스트를 초기화해야한다.)</p></li>
</ol>
<p>위의 조건을 만족하는 예시는 예를 들어, 0이상 100이하인 성적 데이터를 정렬할때 계수 정렬이 효과적일 수 있다. 계수 정렬은 앞서 다루었던 3가지 정렬 알고리즘처럼 직접 데이터의 값을 비교한 뒤에 위치를 변경하며 정렬하는 방식 (비교 기반의 정렬 알고리즘)이 아니다.</p>
<section id="id10">
<h3>계수 정렬 예시<a class="headerlink" href="#id10" title="Link to this heading">#</a></h3>
<p><strong>Step 1</strong>
초기 단계: 7 5 9 0 3 1 6 2 9 1 4 8 0 5 2
먼저 가장 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있도록 하나의 리스트를 생성한다. 현재 예시에선 가장 큰 데이터는 ‘9’이고 가장 작은 데이터가 ‘0’이다. 우리가 정렬한 데이터의 범위를 모두 포함하도록 리스트를 생성해야하므로 크기가 10인 리스트를 선언하면 된다. 리스트의 모든 값이 0이 되도록 초기화한다.</p>
<p><strong>Step 2</strong>
<strong>7</strong> 5 9 0 3 1 6 2 9 1 4 8 0 5 2
<img alt="29" src="../../_images/291.png" /></p>
<p>데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스 데이터를 1씩 증가시킨다.</p>
<p><strong>Step 3</strong>
<strong>7 5</strong> 9 0 3 1 6 2 9 1 4 8 0 5 2
<img alt="30" src="../../_images/301.png" /></p>
<p><strong>Step 4</strong>
<strong>7 5 9</strong> 0 3 1 6 2 9 1 4 8 0 5 2
<img alt="31" src="../../_images/312.png" /></p>
<p><strong>Step 14</strong>
<strong>7 5 9 0 3 1 6 2 9 1 4 8 0 5 2</strong>
<img alt="32" src="../../_images/321.png" />
결과적으로 위의 리스트에는 각 데이터가 몇 번 등장했는지 그 횟수가 기록된다. 이 리스트에 저장된 데이터 자체가 정렬된 형태 그 자체라고 할 수 있다. 결과를 출력하고 싶으면 리스트의 첫 번째 데이터부터 하나씩 그 값만큼 인덱스를 출력하면 된다.</p>
</section>
<section id="id11">
<h3>계수 정렬 코드 및 시간 &amp; 공간 복잡도<a class="headerlink" href="#id11" title="Link to this heading">#</a></h3>
<div class="admonition-source-code-for-count-sort admonition">
<p class="admonition-title">source code for count sort</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 모든 원소의 값이 0보다 크거나 같다고 가정 </span>
<span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

<span class="c1"># 모든 범위를 포함하는 리스트 선언 (모든 값은 0으로 초기화)</span>
<span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
    <span class="n">count</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># 각 데이터에 해당하는 인덱스의 값 증가 </span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">count</span><span class="p">)):</span> <span class="c1"># 리스트에 기록된 정렬 정보 확인 </span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="c1"># 띄어쓰기를 구분으로 등장한 횟수만큼 인덱스 출력 </span>
</pre></div>
</div>
</div>
<p>모든 데이터가 양의 정수인 상황에서 데이터의 개수를 N, 데이터 중 최댓값의 크기를 K라고 할때, 계수 정렬의 시간복잡도는 O(N+K)이다. 계수 정렬은 앞에서부터 데이터를 하나씩 확인하면서 리스트에서 적절한 인덱스의 값을 1씩 증가시킬 뿐만 아니라, 추후에 리스트의 각 인덱스에 해당하는 값들을 확인할 때 데이터 중 최댓값의 크기만큼 반복을 수행해야하기 때문이다.</p>
<p>계수 정렬의 공간복잡도는 O(N+K)이다. 결과를 출력할 리스트를 따로 만들면 N + 각 정수값(0~K)의 등장 횟수 저장하는 카운트 배열(K)이 필요하기 때문이다.</p>
</section>
</section>
<section id="id12">
<h2>파이썬의 정렬 라이브러리<a class="headerlink" href="#id12" title="Link to this heading">#</a></h2>
<p>파이썬은 기본 정렬 라이브러리인 sorted() 함수를 제공한다. sorted() 는 퀵 정렬과 동작 방식이 비슷한 병합 정렬을 기반으로 만들어졌는데, 병합 정렬은 일반적으로 퀵 정렬보다 느리지만 최악의 경우에도 시간 복잡도 O(NlogN)을 보장한다. sorted() 함수는 리스트, 딕셔너리 자료형 등을 입력받아서 정렬된 결과를 출력한다. 집합 자료형이나 딕셔너리 자료형을 입력받아도 반환되는 결과는 <em><strong>리스트 자료형</strong></em>이다.</p>
<div class="dropdown admonition">
<p class="admonition-title">sorted() source code</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

<span class="n">result</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>또한, sorted()를 이용할때 key 매개변수를 입력으로 받을 수 있다. key 값으로는 하나의 <strong>함수</strong>가 들어가야 하며 이는 정렬 기준이 된다. 예를 들어, 리스트의 데이터가 튜플로 구성되어 있는 경우, 각 데이터의 두 번째 원소를 기준으로 정렬을 하고 싶다고 할때, 다음과 같이 소스코드를 작성할 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">array</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;바나나&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;사과&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;당근&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>

<span class="n">result</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>람다 함수에 대한 설명은 아래를 참고하자.</p>
<div class="dropdown admonition">
<p class="admonition-title">lambda function</p>
<p>파이썬의 람다 함수는 “한 줄짜리 함수”를 만들 때 자주 쓰이는 문법이다. 이 함수는 익명 함수 (anonymous function) 라고도 불린다. <strong><code class="docutils literal notranslate"><span class="pre">def</span></code> 키워드 대신 <code class="docutils literal notranslate"><span class="pre">lambda</span></code>를 써서 한 줄로 함수를 정의</strong>한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">lambda</span> <span class="n">매개변수들</span><span class="p">:</span> <span class="n">표현식</span> 
</pre></div>
</div>
<p>예를 들어,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span><span class="mi">10</span> 
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="c1"># 15 </span>
</pre></div>
</div>
<p>위의 코드에서 <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">x:</span> <span class="pre">x</span> <span class="pre">+10</span></code>은 def f(x): return x + 10`과 완전히 동일한 기능을 한다.</p>
<p>람다 함수는 짧고 일회성으로 쓸 때 유용한데, 특히 함수형 프로그래밍 도구 (map, sorted 등)에서 자주 사용된다. lambda는 “표현식(expression)”만 가능하고, 여러 줄 (if, for, return)은 불가하다.</p>
<p>아래의 활용 예시들을 간단히 살펴보자.</p>
<div class="literal-block-wrapper docutils container" id="id16">
<div class="code-block-caption"><span class="caption-number">예시 32 </span><span class="caption-text">sorted()와 key인자</span><a class="headerlink" href="#id16" title="Link to this code">#</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">students</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;Jane&quot;</span><span class="p">,</span> <span class="mi">22</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;Tom&quot;</span><span class="p">,</span> <span class="mi">19</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;Alice&quot;</span><span class="p">,</span> <span class="mi">24</span><span class="p">)]</span>

<span class="c1"># 나이를 기준으로 오름차순 정렬</span>
<span class="n">sorted_students</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">students</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sorted_students</span><span class="p">)</span>
<span class="c1"># [(&#39;Tom&#39;, 19), (&#39;Jane&#39;, 22), (&#39;Alice&#39;, 24)]</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id17">
<div class="code-block-caption"><span class="caption-number">예시 33 </span><span class="caption-text">map()과 함께</span><a class="headerlink" href="#id17" title="Link to this code">#</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">squared</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">numbers</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">squared</span><span class="p">)</span>  <span class="c1"># [1, 4, 9, 16, 25]</span>
</pre></div>
</div>
</div>
</div>
<p>리스트 변수의 경우 내부 원소를 바로 정렬할 수도 있는데, 리스트 객체의 내장 함수인 sort()를 사용하면 된다. 이를 이용하면 <em><strong>별도의 정렬된 리스트가 반환되지 않고 내부 원소가 바로 정렬된다.</strong></em> 리스트 객체의 내장함수 sort()도 key 매개변수를 입력으로 받을 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>

<span class="n">arr</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</pre></div>
</div>
<p>정렬 라이브러리는 항상 최악의 경우에도 시간 복잡도 O(NlogN)을 보장한다.</p>
</section>
<section id="id13">
<h2>정리<a class="headerlink" href="#id13" title="Link to this heading">#</a></h2>
<p>문제에서 별도의 요구가 없다면, 단순히 정렬해야하는 상황에서는 기본 정렬 라이브러리를 사용하고, 데이터의 범위가 한정되어 있으며 더 빠르게 동작해야하는 경우에는 계수 정렬을 이용하자.</p>
<p>코딩 테스트에서 정렬 알고리즘이 사용되는 경우를 일반적으로 3가지 문제 유형으로 나타낼 수 있다.</p>
<ol class="arabic simple">
<li><p><strong>정렬 라이브러리로 풀 수 있는 문제</strong>: 단순히 정렬 기법을 알고 있는 문제로 기본 정렬 라이브러리 사용법을 숙지하고 있으면 된다.</p></li>
<li><p><strong>정렬 알고리즘의 원리에 대해서 물어보는 문제</strong>: 선택, 삽입, 퀵 정렬 등의 원리를 숙지하자.</p></li>
<li><p><strong>더 빠른 정렬이 필요한 문제</strong>: 퀵 정렬 기반 기법이 아닌, 계수 정렬 등의 다른 정렬 알고리즘을 이용하거나 문제에서 기존에 알려진 알고리즘의 구조적인 개선을 거쳐야 풀 수 있다.</p></li>
</ol>
<div class="admonition-summary admonition">
<p class="admonition-title">Summary</p>
<p>ascending order를 기준으로,</p>
<ul class="simple">
<li><p>선택 정렬: swap할 가장 작은 “데이터”를 선택</p></li>
<li><p>삽입 정렬: swap할 “인덱스”를 선택</p></li>
<li><p>퀵 정럴: 특정한 리스트에서 피벗을 설정하여 정렬을 수행한 이후 (partitioning), 피벗을 기준으로 왼쪽 리스트와 오른쪽 리스트에서 각각 다시 정렬 수행.</p></li>
<li><p>계수 정렬: 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스 데이터를 1씩 증가시킨다.</p></li>
</ul>
</div>
</section>
<section id="id14">
<h2>예시 문제<a class="headerlink" href="#id14" title="Link to this heading">#</a></h2>
<section id="merge-sorted-array">
<h3>1. Merge sorted array<a class="headerlink" href="#merge-sorted-array" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/merge-sorted-array/description/?envType=problem-list-v2&amp;amp;envId=sorting">문제 링크</a></p>
<div class="dropdown admonition">
<p class="admonition-title">solution</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do not return anything, modify nums1 in-place instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize pointers for the last valid elements in nums1 and nums2</span>
        <span class="n">num1_r</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">num2_r</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># Pointer for the last position in the merged array</span>
        <span class="n">whole_idx</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># Merge nums1 and nums2 from the back</span>
        <span class="k">while</span> <span class="n">num1_r</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">num2_r</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Compare the last elements of both arrays</span>
            <span class="k">if</span> <span class="n">nums1</span><span class="p">[</span><span class="n">num1_r</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums2</span><span class="p">[</span><span class="n">num2_r</span><span class="p">]:</span>
                <span class="c1"># If nums2 element is larger, place it at the current last position</span>
                <span class="n">nums1</span><span class="p">[</span><span class="n">whole_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">num2_r</span><span class="p">]</span>
                <span class="n">num2_r</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise, place nums1 element at the current last position</span>
                <span class="n">nums1</span><span class="p">[</span><span class="n">whole_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">num1_r</span><span class="p">]</span>
                <span class="n">num1_r</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">whole_idx</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="c1"># If there are remaining elements in nums2,</span>
        <span class="c1"># copy them to the beginning of nums1.</span>
        <span class="c1"># (No need to handle nums1&#39;s remaining part since they are already in place)</span>
        <span class="k">if</span> <span class="n">num1_r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nums1</span><span class="p">[:(</span><span class="n">num2_r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[:(</span><span class="n">num2_r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
</pre></div>
</div>
</div>
<p>두 개의 array는 이미 ascending order로 정렬되어 있다. 이를 이용하여 아래처럼 풀 수 있다.</p>
<ul class="simple">
<li><p>이 코드는 뒤쪽에서부터 채워나가는 방식을 사용합니다.(whole_idx는 nums1의 맨 끝 인덱스부터 시작)</p></li>
<li><p>이렇게 하면 별도의 임시 배열을 만들지 않고 in-place 정렬이 가능합니다.</p></li>
<li><p>num1_r &lt; 0 인 경우는 nums2의 값이 모두 더 작았던 상황으로, 남은 nums2 원소들을 앞부분에 복사해야 합니다.</p></li>
<li><p>반대로 num2_r &lt; 0이면, nums1에 남은 값들은 이미 제자리에 있으므로 추가 작업이 필요 없습니다.</p></li>
</ul>
</section>
<section id="majority-element">
<h3>2. Majority Element<a class="headerlink" href="#majority-element" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/majority-element/?envType=problem-list-v2&amp;amp;envId=sorting">문제 링크</a></p>
<div class="dropdown admonition">
<p class="admonition-title">solution1</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">majorityElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">count_array</span> <span class="o">=</span> <span class="p">[]</span> 

        <span class="c1"># nums[i]는 음수 혹은 양수 </span>
        <span class="n">max_num</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">max_count</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">count_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">count_dict</span><span class="p">:</span>
                <span class="n">count_dict</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="n">count_dict</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> 
            
            <span class="k">if</span> <span class="n">max_count</span> <span class="o">&lt;</span> <span class="n">count_dict</span><span class="p">[</span><span class="n">num</span><span class="p">]:</span>
                <span class="n">max_count</span> <span class="o">=</span> <span class="n">count_dict</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>
                <span class="n">max_num</span> <span class="o">=</span> <span class="n">num</span> 
        <span class="k">return</span> <span class="n">max_num</span>
        
</pre></div>
</div>
</div>
<p>Boyer–Moore Voting 방식으로 최적으로 풀 수 있다. Boyer–Moore Voting Algorithm은 배열에서 다수 원소를 찾기 위해 투표 상쇄 원리를 이용한 O(N)·O(1) 알고리즘이다 최종적으로 남는 후보(candidate)는 “모든 원소들이 서로 상쇄된 뒤에도 표가 남는 유일한 원소”이기 때문에 majority element임이 보장된다.</p>
<ul class="simple">
<li><p>Time: O(N) / Space: O(1)</p></li>
<li><p>아이디어: 후보(candidate) 하나와 카운트만 유지. 같은 수 나오면 +1, 다른 수 나오면 -1, 0이 되면 후보 교체.</p></li>
<li><p>다수 원소가 ⌊n/2⌋ 초과 존재하므로 최종 후보가 다수 원소가 됨.</p></li>
<li><p>해시맵 대비 장점: 공간 O(1), 구현 간단, 최적.</p></li>
</ul>
<div class="dropdown admonition">
<p class="admonition-title">solution2</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">majorityElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">candidate</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">candidate</span>
</pre></div>
</div>
</div>
</section>
<section id="contains-duplicate">
<h3>3. Contains Duplicate<a class="headerlink" href="#contains-duplicate" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/contains-duplicate/description/?envType=problem-list-v2&amp;amp;envId=sorting">문제 링크</a></p>
<ul class="simple">
<li><p>set 자료형을 이용하여 풀기</p></li>
</ul>
<div class="dropdown admonition">
<p class="admonition-title">solution1</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">containsDuplicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">num_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> 
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">num_set</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span> 
            <span class="n">num_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="kc">False</span> 
</pre></div>
</div>
</div>
<ul class="simple">
<li><p>정렬을 이용하여 풀기 (더 느림)</p></li>
</ul>
<div class="dropdown admonition">
<p class="admonition-title">solution2</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 시간 복잡도: O(N log N)</span>
<span class="c1"># 공간 복잡도: O(1)~O(N)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">containsDuplicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">nums</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>  <span class="c1"># 정렬</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./_pages/theory"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="5_shortest_path.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">이전</p>
        <p class="prev-next-title">Lecture 5-1. Shortest Path</p>
      </div>
    </a>
    <a class="right-next"
       href="../practice/1_implementationPS.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">다음</p>
        <p class="prev-next-title">Lecture 1-2. 구현 실습</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> 내용
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#selection-sort">선택 정렬 (Selection Sort)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">선택 정렬 예시</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">선택 정렬 코드 및 시간 복잡도</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#insertion-sort">삽입 정렬 (Insertion Sort)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">삽입 정렬 예시</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">삽입 정렬 코드 및 시간 복잡도</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#quick-sort">퀵 정렬 (Quick Sort)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">파트 1</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">파트 2: 분할 완료된 피벗의 왼쪽 리스트</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">파트 3: 분할 완료된 피벗의 오른쪽 리스트</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">퀵 정렬 전체 정리 과정 그림</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">퀵 정렬 소스코드 및 시간 복잡도</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#merge-sort">병합 정렬 (Merge sort)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#source-code">병합 정렬 source code 및 시간 복잡도</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#count-sort">계수 정렬 (Count sort)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">계수 정렬 예시</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">계수 정렬 코드 및 시간 &amp; 공간 복잡도</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">파이썬의 정렬 라이브러리</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">정리</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">예시 문제</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#merge-sorted-array">1. Merge sorted array</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#majority-element">2. Majority Element</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#contains-duplicate">3. Contains Duplicate</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
으로 Daye Lee
</p>

  </div>
  
  <div class="footer-item">
    

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>