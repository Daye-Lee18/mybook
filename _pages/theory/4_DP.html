
<!DOCTYPE html>


<html lang="ko" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Lecture 4-1. Dynamic Programming &#8212; 말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css?v=6644e6bb" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=9c59b310" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=ae323b5b"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="../../_static/translations.js?v=e33e7ba0"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_pages/theory/4_DP';</script>
    <script src="https://unpkg.com/jupyterquiz@1.1.8/dist/jupyterquiz.min.js"></script>
    <link rel="icon" href="../../_static/favicon.png"/>
    <link rel="index" title="색인" href="../../genindex.html" />
    <link rel="search" title="검색" href="../../search.html" />
    <link rel="next" title="Lecture 5-1. 정렬" href="5_sort.html" />
    <link rel="prev" title="Lecture 3-1. Backtracking" href="3_backtracking.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="ko"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/mylogo.png" class="logo__image only-light" alt="말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업 - Home"/>
    <script>document.write(`<img src="../../_static/mylogo.png" class="logo__image only-dark" alt="말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업 - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="검색" aria-label="검색" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">검색</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Welcome to 말레이시아 5급 IT 수업
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">이론</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="0_tips.html">문제 풀이 순서 팁 (Tips)</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_implementation.html">Lecture 1-1. 구현</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_DFS_BFS.html">Lecture 2-1. DFS/BFS</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_backtracking.html">Lecture 3-1. Backtracking</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Lecture 4-1. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="5_sort.html">Lecture 5-1. 정렬</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">실습</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../practice/1_implementationPS.html">Lecture 1-2. 구현 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practice/2_DFS_BFSPS.html">Lecture 2-2. DFS/BFS 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practice/3_backtrackingPS.html">Lecture 3-2. Backtracking 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practice/4_DPPS.html">Lecture 4-2. DP 실습</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="이 페이지 다운로드">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/_pages/theory/4_DP.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="소스 파일 다운로드"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="PDF로 인쇄"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="전체 화면으로보기"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="검색" aria-label="검색" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Lecture 4-1. Dynamic Programming</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> 내용 </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#dp">DP 조건</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-2">DP 2가지 구현 방식</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">메모이제이션</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">시간복잡도</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#top-down">Top-Down 방식</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bottom-up">Bottom-Up 방식</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamic-programming-table-dp-table">Dynamic Programming Table (DP Table)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sequence-array-dp">1. Sequence / Array DP</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#subsequence-string-dp">2. Subsequence/String DP</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#knapsack-family">3. Knapsack Family</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#grid-dp">4. Grid DP</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#interval-dp">5. Interval DP</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tree-dp">6. Tree DP</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#summary">Summary</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">예시 문제</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#d-dp">1. 1D DP</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#climbing-stairs">Climbing Stairs</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#house-robber">House Robber</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#word-break">Word Break</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#coin-change">Coin Change</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#longest-increasing-subsequences">Longest Increasing Subsequences</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#number-of-lis">Number of LIS</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#is-subsequence">Is Subsequence</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multidimensional-dp">2. Multidimensional DP</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#russian-doll-envelope">Russian Doll Envelope</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#triangle">Triangle</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#minimum-path-sum">Minimum Path Sum</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#unique-path-ii">Unique Path II</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#longest-palindromic-substring">Longest Palindromic Substring</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#interleaving-string">Interleaving String</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#edit-distance">Edit Distance</a></li>
</ul>
</li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="lecture-4-1-dynamic-programming">
<h1>Lecture 4-1. Dynamic Programming<a class="headerlink" href="#lecture-4-1-dynamic-programming" title="Link to this heading">#</a></h1>
<p>컴퓨터는 연산 속도에 한계가 있고, 메모리 공간을 사용할 수 있는 데이터의 개수도 한정적이다. 따라서, 연산 속도와 메모리 공간을 최대한 효율적으로 활용하는 알고리즘을 작성해야한다. 다만, <strong>어떤 문제는 메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가</strong>시킬 수 있는 방법이 있다. 대표적으로 이번 장에서 다루는 다이나믹 프로그래밍 (Dynamic Programming, 동적 계획법)기법이다.</p>
<section id="dp">
<h2>DP 조건<a class="headerlink" href="#dp" title="Link to this heading">#</a></h2>
<p>DFS를 배울 때, 피보나치 수열을 구현하는 방법을 배웠다. 피보나치 수열은 다음 그림과 같은 형태로 끝없이 이어진다.</p>
<p><img alt="1" src="../../_images/115.png" /></p>
<p>점화식을 통해 인접한 항들 사이의 관계식을 의미하는데, 예를 들어 수열 <span class="math notranslate nohighlight">\({a_{n}}\)</span>이 있을 때 수열에서의 각 항을 <span class="math notranslate nohighlight">\(a_{n}\)</span>이라고 부른다고 가정하자. 우리는 점화식을 통해 현재의 항을 이전의 항에 대한 식으로 표현할 수 있다. 예를 들어, 피보나치 수열의 점화식은 다음과 같이 표현할 수 있다.</p>
<p><span class="math notranslate nohighlight">\(a_{n+2} = a_{n} + a_{n+1}, a_{1} =1, a_{2} = 2\)</span></p>
<p>위와 같은 점화식은 인접 3항간 점화식이라고 부르는데, 인접한 총 3개의 항에 대해서 식이 정의되기 때문이다.</p>
<p>프로그래밍에서는 이러한 수열을 <strong>배열</strong>이나 <strong>리스트</strong>로 표현할 수 있다. 수열 자체가 여러 개의 수가 규칙에 따라서 배열된 형태를 의미하는 것이기 때문이다. 파이썬에서는 리스트 자료형이 이를 처리하고, C/C++ 와 자바에서는 배열을 이용해 이를 처리한다.</p>
<p>위와 같은 점화식을 실제로 어떻게 구현할 수 있을까? n번째 피보나치 수를 f(n)이라고 표현할 때 4번째 피보나치 수 f(4)를 구하려면 다음과 같이 함수 f를 반복해서 호출할 것이다. 그런데 f(2)와 f(1)은 항상 1이기 때문에 f(1)이나 f(2)를 만났을 때는 호출을 정지한다.</p>
<p><img alt="2" src="../../_images/213.png" /></p>
<p>수학적 점화식을 프로그래밍으로 표현하려면 재귀 함수를 사용하면 간단하다. 예시를 소스코드로 바꾸면 다음과 같다.</p>
<div class="toggle docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 피보나치 함수(Fibonacci Function)을 재귀함수로 표현 </span>
<span class="k">def</span><span class="w"> </span><span class="nf">fibo</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span> 

  <span class="k">return</span> <span class="n">fibo</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibo</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">fibo</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>피보나치 수열의 소스코드를 위와 같이 작성하면 문제가 생길 수 있는데, f(n) 함수에서 n이 커지면 커질수록 수행 시간이 기하급수적으로 늘어나기 때문이다. 그림을 보면 동일한 함수가 반복적으로 호출되는 것을 알 수 있다. 이미 한 번 계산했지만, 계속 호출할 때마다 계산하는 것이다. 이처럼 피보나치 수열의 점화식을 재귀 함수를 사용해 만들 수 는 있지만, 단순히 매번 계산핟로로고 하면 문제를 효율적으로 해결할 수 없다. 이러한 문제는 다이나믹 프로그래밍을 사용하면 효율적으로 해결할 수 있다. 하지만 다이나믹 프로그래밍을 항상 사용할 수는 없으며, 다음 조건을 만족할 때 사용할 수 있다.</p>
<div class="important admonition">
<p class="admonition-title">DP 문제 조건</p>
<ol class="arabic simple">
<li><p>큰 문제를 작은 문제로 나눌 수 있다.</p></li>
<li><p>작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.</p></li>
</ol>
</div>
<p>피보나치 수열은 위의 조건을 만족하는 대표 문제로, 이 문제를 메모이제이션 (Memoization) 기법을 사용해서 해결해보자. 메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로, 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결ㄹ과를 그대로 가져오는 기법을 의미한다. 메모이제이션은 값을 저장는 방법이므로 캐싱 (Caching)이라고도 한다.</p>
<p>메모이제이션의 구현은 단순히, 한 번 구한 정보를 리스트에 저장하는 것이다. 다이나믹 프로그래밍을 재귀적으로 수행하다가 같은 정보가 필요할 때는 이미 구한 정답을 그대로 리스트에서 가져오면 된다.</p>
<div class="toggle docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">100</span> 

<span class="c1"># 피보나치 함수 (Fibonacci Function) 를 재귀함수로 구현 (탑다운 다이나믹 프로그래밍)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fibo</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="c1"># base case </span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span> 
    
    <span class="c1"># 이미 계산한 적 있는 문제라면 그대로 반환 </span>
    <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> 
    
    <span class="c1"># 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환 </span>
    <span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">fibo</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibo</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">fibo</span><span class="p">(</span><span class="mi">99</span><span class="p">))</span>
</pre></div>
</div>
</div>
</section>
<section id="dp-2">
<h2>DP 2가지 구현 방식<a class="headerlink" href="#dp-2" title="Link to this heading">#</a></h2>
<p>정리하자면, 다이나믹 프로그래밍이란 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법이다. 다이나믹 프로그래밍과 분할 정복 (Divide and Conquer)의 차이점은 다이나믹 프로그래밍은 문제들이 서로 영향을 미치고 있다는 점이다.
즉, 둘 다 큰 문제를 작은 문제로 쪼개 푸는 건 비슷하지만, 차이는 부분 문제의 관계에 있습니다.</p>
<ul class="simple">
<li><p>분할 정복 (예: 퀵정렬, 병합정렬)</p>
<ul>
<li><p>문제를 작은 문제로 나눔 → 각각 독립적으로 해결 → 결과를 합쳐서 큰 문제 해결.</p></li>
<li><p>각 부분 문제는 서로 영향을 주지 않음.</p></li>
<li><p>예시: merge sort에서 왼쪽 배열 정렬과 오른쪽 배열 정렬은 서로 간섭 없음.</p></li>
</ul>
</li>
<li><p>다이나믹 프로그래밍 (예: 피보나치, 최단 경로)</p>
<ul>
<li><p>문제를 작은 문제로 나눔 → 작은 문제들의 해가 서로 겹치거나 공유됨.</p></li>
<li><p>한 번 계산한 결과를 저장해놔야 효율적.</p></li>
<li><p>예시: 피보나치 수열을 단순 분할 정복으로 풀면 같은 계산을 수없이 반복하지만, DP로 풀면 한 번 계산한 값을 저장해서 재사용함.</p></li>
</ul>
</li>
</ul>
<div class="note admonition">
<p class="admonition-title">DP 개념 정리</p>
<ol class="arabic simple">
<li><p>큰 문제를 작은 문제로 나눔: 문제를 세분화해서 풀기</p></li>
<li><p>중복되는 작은 문제는 “한 번만” 계산: 계산이 반복되면 결과를 저장 (메모이제이션/테이블화)해서 재사용</p></li>
</ol>
<p>즉, “중복되는 부분 문제 (overlapping subproblems)”를 효율적으로 처리하는 방식</p>
</div>
<p>아래 그림을 보면, f(6)을 호출할 때는 다음 그림처럼 색칠된 노드만 방문하게 되어, 효율적으로 문제를 풀 수 있다.</p>
<p><img alt="3" src="../../_images/35.png" /></p>
</section>
<section id="id1">
<h2>메모이제이션<a class="headerlink" href="#id1" title="Link to this heading">#</a></h2>
<p>메모이제이션은 때에 따라서 다른 자료형, 예를 들어 사전 (Dict) 자료형을 이용할 수도 있다. 사전 자료형은 수열처럼 “연속적이지 않은 경우”에 유용한데, 예를 들어 <span class="math notranslate nohighlight">\(a_{n}\)</span>을 계산하고자 할 때 <span class="math notranslate nohighlight">\(a_{0} ~ a_{n-1}\)</span>모두가 아닌 일부의 작은 문제에 대한 해답만 필요한 경우가 존재할 수 있다. 이럴 때에는 사전 자료형을 사용하는게 더 효과적이다.</p>
<p>또한 가능하다면 재귀 함수를 이용하는 탑다운 방식보다는 보텀업 방식으로 구현하는 것을 권장한다. 시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있기 때문이다. 이 경우 sys 라이브러리에 포함되어 있는 <code class="docutils literal notranslate"><span class="pre">setrecursionlimit()</span></code> 함수를 호출하여 재귀 제한을 완화할 수 있다는 점만 기억하자.</p>
</section>
<section id="id2">
<h2>시간복잡도<a class="headerlink" href="#id2" title="Link to this heading">#</a></h2>
<p>피보나치 수열 알고리즘의 시간 복잡도는 O(N)이다. 왜냐하면 f(1)을 구한 다음 그 값이 f(2)를 푸는 데 사용도기, f(2)의 값이 f(3)를 푸는데 사용되는 방식으로 이어지기 때문이다. 한 번 구한 결과는 다시 구해지지 않는다.</p>
<section id="top-down">
<h3>Top-Down 방식<a class="headerlink" href="#top-down" title="Link to this heading">#</a></h3>
<p>이처럼 재귀 함수를 이용하여 다이나믹 프로그래밍 소스 코드를 작성하는 방법을, 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 top-down 방식이라 말한다.</p>
</section>
<section id="bottom-up">
<h3>Bottom-Up 방식<a class="headerlink" href="#bottom-up" title="Link to this heading">#</a></h3>
<p>단순히 반복문을 이용하여 소스 코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출한다고 하여 Bottom-Up 방식이라고 말한다.</p>
<div class="toggle docutils container">
<div class="literal-block-wrapper docutils container" id="id5">
<div class="code-block-caption"><span class="caption-number">예시 21 </span><span class="caption-text">피보나치 수열 소스코드 (Bottom-Up)</span><a class="headerlink" href="#id5" title="Link to this code">#</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화 </span>
<span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">100</span> 

<span class="c1"># 첫 번째 피보나치 수와 두 번째 피보나치 수는 1 </span>
<span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> 
<span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">99</span>

<span class="c1"># 피보나치 함수 반복문으로 구현 </span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="dynamic-programming-table-dp-table">
<h2>Dynamic Programming Table (DP Table)<a class="headerlink" href="#dynamic-programming-table-dp-table" title="Link to this heading">#</a></h2>
<p>What you choose to store in your DP table (list, dict, array, etc.) is the most important desing decision in solving a DP problem.</p>
<p>DP is about <code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">representation</span></code>. DP works by breaking a big problem into smaller overlapping subproblems. To reuse solutions, you must define a <code class="docutils literal notranslate"><span class="pre">state</span></code> that fully describes a subproblem. That “state” is exactly what you store in the DP table.</p>
<p>How can we decide <strong>what to store</strong>? You should ask yourself <strong>1. What subproblem do I need to solve repeatdly?</strong> and <strong>2. What result of that subproblem helps me build the next one?</strong>. The first question deinfes the state and the next question is the value you should store.</p>
<p>Here is a handy “what to store” cheat-sheet for the most popular DP problems. each line tells you the state, what to store, and a one-line transition hint so you know why the storage works.</p>
<section id="sequence-array-dp">
<h3>1. Sequence / Array DP<a class="headerlink" href="#sequence-array-dp" title="Link to this heading">#</a></h3>
<div class="dropdown admonition">
<p class="admonition-title">sequence 1D DP</p>
<ol class="arabic simple">
<li><p>Fibonacci / Stair Climbing</p></li>
</ol>
<ul class="simple">
<li><p>State: <code class="docutils literal notranslate"><span class="pre">n</span></code></p></li>
<li><p>Store: number of ways/value at <code class="docutils literal notranslate"><span class="pre">n</span></code></p></li>
<li><p>Transition: <code class="docutils literal notranslate"><span class="pre">dp[n]</span> <span class="pre">=</span> <span class="pre">dp[n-1]</span> <span class="pre">+</span> <span class="pre">dp[n-2]</span></code></p></li>
<li><p>Reference: LC 70 (Climbing Stairs), LC 509 (Fibonacci Number)</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>Maximum Subarray (Kadane)</p></li>
</ol>
<ul class="simple">
<li><p>State: end index <code class="docutils literal notranslate"><span class="pre">i</span></code></p></li>
<li><p>Store: best sum of subarray ending at <code class="docutils literal notranslate"><span class="pre">i</span></code></p></li>
<li><p>Transition: <code class="docutils literal notranslate"><span class="pre">dp[i]</span> <span class="pre">=</span> <span class="pre">max(a[i],</span> <span class="pre">dp[i-1]</span> <span class="pre">+</span> <span class="pre">a[i])</span></code></p></li>
<li><p>Reference: LC 53 (Maximum Subarray)</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>House Robber</p></li>
</ol>
<ul class="simple">
<li><p>State: first <code class="docutils literal notranslate"><span class="pre">i</span></code> houses</p></li>
<li><p>Store: max money using up to <code class="docutils literal notranslate"><span class="pre">i</span></code></p></li>
<li><p>Transition: <code class="docutils literal notranslate"><span class="pre">dp[i]</span> <span class="pre">=</span> <span class="pre">max(dp[i-1],</span> <span class="pre">dp[i-2]</span> <span class="pre">+</span> <span class="pre">val[i])</span></code></p></li>
<li><p>Reference: LC 198 (House Robber), LC 213 (House Robber II)</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>Longest Increasing Subsequence (LIS)</p></li>
</ol>
<ul class="simple">
<li><p>State: end index <code class="docutils literal notranslate"><span class="pre">i</span></code></p></li>
<li><p>Store: LIS length ending at <code class="docutils literal notranslate"><span class="pre">i</span></code></p></li>
<li><p>Transition: <code class="docutils literal notranslate"><span class="pre">dp[i]</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">max(dp[j])</span> <span class="pre">for</span> <span class="pre">j&lt;i</span> <span class="pre">&amp;</span> <span class="pre">a[j]&lt;a[i]</span></code></p></li>
<li><p>Reference: LC 300 (LIS), LC 354 (Russian Doll Envelopes)</p></li>
</ul>
<ol class="arabic simple" start="5">
<li><p>Partition Equal Subset / Subset Sum</p></li>
</ol>
<ul class="simple">
<li><p>State: capacity <code class="docutils literal notranslate"><span class="pre">s</span></code></p></li>
<li><p>Store: reachable boolean at sum <code class="docutils literal notranslate"><span class="pre">s</span></code></p></li>
<li><p>Transition: <code class="docutils literal notranslate"><span class="pre">dp[s]</span> <span class="pre">|=</span> <span class="pre">dp[s-w]</span></code></p></li>
<li><p>Reference: LC 416 (Partition Equal Subset Sum), LC 494 (Target Sum)</p></li>
</ul>
</div>
</section>
<section id="subsequence-string-dp">
<h3>2. Subsequence/String DP<a class="headerlink" href="#subsequence-string-dp" title="Link to this heading">#</a></h3>
<div class="dropdown admonition">
<p class="admonition-title">dp table</p>
<ol class="arabic simple">
<li><p>Longest Common Subsequence (LCS)</p></li>
</ol>
<ul class="simple">
<li><p>State: <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j)</span></code></p></li>
<li><p>Store: LCS length of <code class="docutils literal notranslate"><span class="pre">A[:i]</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">B[:j]</span></code></p></li>
<li><p>Transition: if match: <code class="docutils literal notranslate"><span class="pre">1+dp[i-1][j-1]</span></code> else <code class="docutils literal notranslate"><span class="pre">max(dp[i-1][j],</span> <span class="pre">dp[i][j-1])</span></code></p></li>
<li><p>Reference: LC 1143 (LCS)</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>Edit Distance (Levenshtein)</p></li>
</ol>
<ul class="simple">
<li><p>State: <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j)</span></code></p></li>
<li><p>Store: min edits to convert <code class="docutils literal notranslate"><span class="pre">A[:i]</span></code> → <code class="docutils literal notranslate"><span class="pre">B[:j]</span></code></p></li>
<li><p>Transition: <code class="docutils literal notranslate"><span class="pre">min(replace,</span> <span class="pre">insert,</span> <span class="pre">delete)</span></code></p></li>
<li><p>Reference: LC 72 (Edit Distance)</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>Longest Palindromic Subsequence (LPS)</p></li>
</ol>
<ul class="simple">
<li><p>State: <code class="docutils literal notranslate"><span class="pre">(l,</span> <span class="pre">r)</span></code></p></li>
<li><p>Store: LPS length in <code class="docutils literal notranslate"><span class="pre">s[l..r]</span></code></p></li>
<li><p>Transition: if <code class="docutils literal notranslate"><span class="pre">s[l]==s[r]</span></code> → <code class="docutils literal notranslate"><span class="pre">2+dp[l+1][r-1]</span></code> else <code class="docutils literal notranslate"><span class="pre">max(dp[l+1][r],</span> <span class="pre">dp[l][r-1])</span></code></p></li>
<li><p>Reference: LC 516 (Longest Palindromic Subsequence)</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>Longest Palindromic Substring</p></li>
</ol>
<ul class="simple">
<li><p>State: <code class="docutils literal notranslate"><span class="pre">(l,</span> <span class="pre">r)</span></code></p></li>
<li><p>Store: palindrome boolean or length</p></li>
<li><p>Transition: <code class="docutils literal notranslate"><span class="pre">dp[l][r]</span> <span class="pre">=</span> <span class="pre">(s[l]==s[r]</span> <span class="pre">&amp;&amp;</span> <span class="pre">(r-l&lt;2</span> <span class="pre">||</span> <span class="pre">dp[l+1][r-1]))</span></code></p></li>
<li><p>Reference: LC 5 (Longest Palindromic Substring)</p></li>
</ul>
<ol class="arabic simple" start="5">
<li><p>Distinct Subsequences (count ways A→B)</p></li>
</ol>
<ul class="simple">
<li><p>State: <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j)</span></code></p></li>
<li><p>Store: #ways <code class="docutils literal notranslate"><span class="pre">A[:i]</span></code> forms <code class="docutils literal notranslate"><span class="pre">B[:j]</span></code></p></li>
<li><p>Transition: <code class="docutils literal notranslate"><span class="pre">dp[i][j]</span> <span class="pre">=</span> <span class="pre">dp[i-1][j]</span> <span class="pre">+</span> <span class="pre">(A[i-1]==B[j-1]</span> <span class="pre">?</span> <span class="pre">dp[i-1][j-1]</span> <span class="pre">:</span> <span class="pre">0)</span></code></p></li>
<li><p>Reference: LC 115 (Distinct Subsequences)</p></li>
</ul>
</div>
</section>
<section id="knapsack-family">
<h3>3. Knapsack Family<a class="headerlink" href="#knapsack-family" title="Link to this heading">#</a></h3>
<div class="dropdown admonition">
<p class="admonition-title">DP table</p>
<ol class="arabic simple">
<li><p>0/1 Knapsack</p></li>
</ol>
<ul class="simple">
<li><p>State: <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">w)</span></code> or <code class="docutils literal notranslate"><span class="pre">w</span></code> in 1D</p></li>
<li><p>Store: max value at capacity <code class="docutils literal notranslate"><span class="pre">w</span></code></p></li>
<li><p>Transition: <code class="docutils literal notranslate"><span class="pre">dp[w]</span> <span class="pre">=</span> <span class="pre">max(dp[w],</span> <span class="pre">dp[w-weight]</span> <span class="pre">+</span> <span class="pre">value)</span></code></p></li>
<li><p>Reference: LC 474 (Ones and Zeroes)</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>Unbounded Knapsack / Coin Change (min coins)</p></li>
</ol>
<ul class="simple">
<li><p>State: capacity <code class="docutils literal notranslate"><span class="pre">w</span></code></p></li>
<li><p>Store: min coins for <code class="docutils literal notranslate"><span class="pre">w</span></code></p></li>
<li><p>Transition: <code class="docutils literal notranslate"><span class="pre">dp[w]</span> <span class="pre">=</span> <span class="pre">min(dp[w],</span> <span class="pre">dp[w-c]</span> <span class="pre">+</span> <span class="pre">1)</span></code></p></li>
<li><p>Reference: LC 322 (Coin Change)</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>Coin Change (count ways)</p></li>
</ol>
<ul class="simple">
<li><p>State: amount <code class="docutils literal notranslate"><span class="pre">a</span></code></p></li>
<li><p>Store: #ways to make <code class="docutils literal notranslate"><span class="pre">a</span></code></p></li>
<li><p>Transition: <code class="docutils literal notranslate"><span class="pre">dp[a]</span> <span class="pre">+=</span> <span class="pre">dp[a-c]</span></code></p></li>
<li><p>Reference: LC 518 (Coin Change II)</p></li>
</ul>
</div>
</section>
<section id="grid-dp">
<h3>4. Grid DP<a class="headerlink" href="#grid-dp" title="Link to this heading">#</a></h3>
<div class="dropdown admonition">
<p class="admonition-title">DP table for Grid DP</p>
<ol class="arabic simple">
<li><p>Unique Paths (with obstacles)</p></li>
</ol>
<ul class="simple">
<li><p>State: <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j)</span></code></p></li>
<li><p>Store: #ways to reach <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j)</span></code></p></li>
<li><p>Transition: <code class="docutils literal notranslate"><span class="pre">dp[i][j]</span> <span class="pre">=</span> <span class="pre">(obstacle?0</span> <span class="pre">:</span> <span class="pre">dp[i-1][j]</span> <span class="pre">+</span> <span class="pre">dp[i][j-1])</span></code></p></li>
<li><p>Reference: LC 62 (Unique Paths), LC 63 (Unique Paths II)</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>Minimum Path Sum</p></li>
</ol>
<ul class="simple">
<li><p>State: <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j)</span></code></p></li>
<li><p>Store: min cost to <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j)</span></code></p></li>
<li><p>Transition: <code class="docutils literal notranslate"><span class="pre">dp[i][j]</span> <span class="pre">=</span> <span class="pre">grid[i][j]</span> <span class="pre">+</span> <span class="pre">min(dp[i-1][j],</span> <span class="pre">dp[i][j-1])</span></code></p></li>
<li><p>Reference: LC 64 (Minimum Path Sum)</p></li>
</ul>
</div>
</section>
<section id="interval-dp">
<h3>5. Interval DP<a class="headerlink" href="#interval-dp" title="Link to this heading">#</a></h3>
<div class="dropdown admonition">
<p class="admonition-title">DP table for Interval DP</p>
<ol class="arabic simple">
<li><p>Matrix Chain Multiplication</p></li>
</ol>
<ul class="simple">
<li><p>State: <code class="docutils literal notranslate"><span class="pre">(l,</span> <span class="pre">r)</span></code></p></li>
<li><p>Store: min scalar multiplications for <code class="docutils literal notranslate"><span class="pre">l..r</span></code></p></li>
<li><p>Transition: split at <code class="docutils literal notranslate"><span class="pre">k</span></code></p></li>
<li><p>Reference: LC 1547 (Minimum Cost to Cut a Stick)</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>Burst Balloons</p></li>
</ol>
<ul class="simple">
<li><p>State: <code class="docutils literal notranslate"><span class="pre">(l,</span> <span class="pre">r)</span></code> open interval</p></li>
<li><p>Store: max coins from <code class="docutils literal notranslate"><span class="pre">(l,</span> <span class="pre">r)</span></code></p></li>
<li><p>Transition: pick last balloon <code class="docutils literal notranslate"><span class="pre">k</span></code></p></li>
<li><p>Reference: LC 312 (Burst Balloons)</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>Palindrome Partitioning (min cuts)</p></li>
</ol>
<ul class="simple">
<li><p>State: prefix <code class="docutils literal notranslate"><span class="pre">i</span></code></p></li>
<li><p>Store: min cuts for <code class="docutils literal notranslate"><span class="pre">s[:i]</span></code></p></li>
<li><p>Transition: <code class="docutils literal notranslate"><span class="pre">dp[i]</span> <span class="pre">=</span> <span class="pre">min(dp[j]+1)</span></code> for palindromic <code class="docutils literal notranslate"><span class="pre">s[j:i]</span></code></p></li>
<li><p>Reference: LC 132 (Palindrome Partitioning II)</p></li>
</ul>
</div>
</section>
<section id="tree-dp">
<h3>6. Tree DP<a class="headerlink" href="#tree-dp" title="Link to this heading">#</a></h3>
<div class="dropdown admonition">
<p class="admonition-title">DP table for Tree</p>
<ol class="arabic simple">
<li><p>Tree Diameter</p></li>
</ol>
<ul class="simple">
<li><p>State: node <code class="docutils literal notranslate"><span class="pre">u</span></code></p></li>
<li><p>Store: longest downward path from <code class="docutils literal notranslate"><span class="pre">u</span></code></p></li>
<li><p>Transition: combine two largest child depths</p></li>
<li><p>Reference: LC 543 (Diameter of Binary Tree), LC 124 (Binary Tree Max Path Sum)</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>Maximum Independent Set on Tree</p></li>
</ol>
<ul class="simple">
<li><p>State: <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">take)</span></code></p></li>
<li><p>Store: best sum if <code class="docutils literal notranslate"><span class="pre">u</span></code> is taken or skipped</p></li>
<li><p>Transition: if take <code class="docutils literal notranslate"><span class="pre">u</span></code>, skip children; else best of children</p></li>
<li><p>Reference: classic Tree DP (not direct LC, but similar to LC 337 House Robber III)</p></li>
</ul>
</div>
</section>
<section id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Link to this heading">#</a></h3>
<div class="important admonition">
<p class="admonition-title">Summary for DP table</p>
<p>Quick rules for “what to store”</p>
<ol class="arabic simple">
<li><p><strong>Smallest subproblem that lets you extend</strong>: e.g. LIS needs “best ending at i”, not “global max so far”.</p></li>
<li><p><strong>Exactly the quantity needed by the recurrence</strong>: value, count, boolean, min/max, probability, etc.</p></li>
<li><p><strong>Dimensions match dependencies</strong>: if you need two indices (like two strings), your state likely has two; if intervals matter, store by <code class="docutils literal notranslate"><span class="pre">(l,</span> <span class="pre">r)</span></code>; on trees, store per-node (optionally with a flag)</p></li>
<li><p><strong>Space-optimize later</strong>: once the state is right, compress (1D knapsack, rolling rows in grides, etc.)</p></li>
</ol>
</div>
</section>
</section>
<section id="id3">
<h2>예시 문제<a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<section id="d-dp">
<h3>1. 1D DP<a class="headerlink" href="#d-dp" title="Link to this heading">#</a></h3>
<section id="climbing-stairs">
<h4>Climbing Stairs<a class="headerlink" href="#climbing-stairs" title="Link to this heading">#</a></h4>
<p>문제 - <a class="reference external" href="https://leetcode.com/problems/climbing-stairs/?envType=study-plan-v2&amp;amp;envId=top-interview-150">Leetcode 70</a></p>
<div class="toggle docutils container">
<p>Bottom-up 방식으로 쉽게 풀 수 있다. 현재 선택지는 +1, +2칸이므로 f(n)을 계산하는 경우 n-1 칸에서 한 칸 오른 것 즉, f(n-1)과 n-2칸 에서 +2칸 오른 것 f(n-2)를 더한 것과 동일하다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">climbStairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        1 = 1</span>

<span class="sd">        N=2 </span>
<span class="sd">        1 + 1 </span>
<span class="sd">        2 </span>

<span class="sd">        N = 3 </span>
<span class="sd">        1 + 1 + 1 </span>
<span class="sd">        1 + 2 </span>
<span class="sd">        2 + 1 </span>
<span class="sd">        </span>
<span class="sd">        N = 4 </span>
<span class="sd">        1 + 1 + 1 + 1 </span>
<span class="sd">        1 + 2 + 1 </span>
<span class="sd">        2 + 1 + 1 </span>
<span class="sd">        1 + 1 + 2 </span>
<span class="sd">        2 + 2 </span>

<span class="sd">        즉, f(N) = f(N-1) + f(N-2)</span>
<span class="sd">        f(N-1)에서는 1만 더하면 되고 f(N-2)는 2를 더하면 됨. </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">climbStairs</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
</div>
</section>
<section id="house-robber">
<h4>House Robber<a class="headerlink" href="#house-robber" title="Link to this heading">#</a></h4>
<p>문제 - <a class="reference external" href="https://leetcode.com/problems/house-robber/description/?envType=study-plan-v2&amp;amp;envId=top-interview-150">Leetcode 198</a></p>
<div class="toggle docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span> 

<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">rob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

        
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># 해당 index까지 최고 dp 값 저장 </span>
        <span class="n">max_val</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># 해당 index까지 최고 dp 값 저장 </span>
            <span class="n">max_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_val</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">max_val</span>
        
        
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># nums = [10, 1 , 2 , 3] # 13 </span>
    <span class="c1"># nums = [10, 1 , 2 , 3, 12] # 24 </span>
    <span class="c1"># nums = [1, 2, 3, 1] # 4</span>
    <span class="c1"># nums = [2, 7, 9, 3, 1] # 12</span>
    <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span> <span class="c1"># 103</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">rob</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span>
</pre></div>
</div>
</div>
</section>
<section id="word-break">
<h4>Word Break<a class="headerlink" href="#word-break" title="Link to this heading">#</a></h4>
<p>문제 - <a class="reference external" href="https://leetcode.com/problems/word-break/description/?envType=study-plan-v2&amp;amp;envId=top-interview-150">Leetcode 139</a></p>
<div class="toggle docutils container">
<h2 class="rubric" id="id4">Bottom-Up</h2>
<p>아이디어:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dp[i]</span> <span class="pre">=</span> <span class="pre">s[:i]</span></code> 가 사전 단어들로 정확히 분해 가능하면 True.</p></li>
<li><p>시작 dp[0] = True (빈 문자열은 분해 가능)</p></li>
<li><p>각 i에 대해, 어떤 j &lt; i가 있어 dp[j] == True 이고 s[j:i] 가 단어면 dp[i] = True.</p></li>
</ul>
<p>효율 팁</p>
<ul class="simple">
<li><p>단어들을 set으로 만들어 O(1) 조회.</p></li>
<li><p>단어 길이의 최대값 L = max(len(w) for w in wordDict)를 구해 j를 i-L .. i-1로만 확인(큰 가지치기).</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span> 

<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">wordBreak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wordDict</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">word_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">wordDict</span><span class="p">)</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">word_set</span><span class="p">))</span> <span class="k">if</span> <span class="n">word_set</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># r에서 최대 max_len만큼만 거슬러 올라가 보기</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="n">max_len</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">f</span><span class="p">:</span><span class="n">r</span><span class="p">]</span> <span class="ow">in</span> <span class="n">word_set</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

            
        
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># s = &quot;abc&quot;; wordDict=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
    <span class="c1"># s = &quot;leetcode&quot;; wordDict = [&quot;leet&quot;, &quot;code&quot;]</span>
    <span class="c1"># s = &quot;applepenapple&quot;; wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span>
    <span class="c1"># s = &quot;catsandog&quot;; wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;catsand&quot;</span><span class="p">;</span> <span class="n">wordDict</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cats&quot;</span><span class="p">,</span> <span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="s2">&quot;sand&quot;</span><span class="p">]</span>

    <span class="n">sol</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">wordBreak</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">wordDict</span><span class="p">))</span>
</pre></div>
</div>
</div>
</section>
<section id="coin-change">
<h4>Coin Change<a class="headerlink" href="#coin-change" title="Link to this heading">#</a></h4>
<p>문제 - <a class="reference external" href="https://leetcode.com/problems/coin-change/description/?envType=study-plan-v2&amp;amp;envId=top-interview-150">Leetcode 322</a></p>
<div class="toggle docutils container">
<div class="literal-block-wrapper docutils container" id="id6">
<div class="code-block-caption"><span class="caption-number">예시 22 </span><span class="caption-text">Greedy로 찾을 수 없다. 가장 큰 동전을 일단 뽑는 선택이, 이후 남은 금액을 더 나쁘게 만들어 전체 개수를 늘려버릴 수 있어요. 예를 들어, coins = [1, 5, 11], amount = 15 일때, 그리디: 11 → (남은 4) → 1×4 ⇒ 5개, 정답인 최적: 5 + 5 + 5 ⇒ 3개 이다. Greedy가 통하는 경우는 동전 체계가 <code class="docutils literal notranslate"><span class="pre">canonical(정규)</span></code>한 경우에 가능하다. 예를 들어, 각 동전이 이전 동전의 배수인 경우 (예: [1, 2, 4, 8..])</span><a class="headerlink" href="#id6" title="Link to this code">#</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span> 

<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">in_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_idx</span><span class="p">,</span> <span class="n">dif</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">cur_idx</span> <span class="o">-</span> <span class="n">dif</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">coinChange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coins</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        
        <span class="n">MAX</span> <span class="o">=</span> <span class="mi">99999999</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">99999999</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">amount</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># basecase, when amount = 0</span>

        <span class="k">for</span> <span class="n">cur_dp_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">amount</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">coin</span> <span class="ow">in</span> <span class="n">coins</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cur_dp_idx</span> <span class="o">-</span> <span class="n">coin</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 현재 idx에 해당하는 coin이 있으면 무조건 1개로 끝낼 수 있음. </span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">cur_dp_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> 
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_range</span><span class="p">(</span><span class="n">cur_dp_idx</span><span class="p">,</span> <span class="n">coin</span><span class="p">):</span>
                    <span class="c1"># 가지고 있는 코인 &#39;하나&#39; 써서 만든 거 (dp[cur_dp_idx-coin] + 1)랑 이전 dp (dp[cur_dp_idx])랑 비교 </span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">cur_dp_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">cur_dp_idx</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">cur_dp_idx</span><span class="o">-</span><span class="n">coin</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># print(dp)</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MAX</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> 

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># coins = [1, 2, 5, 10]; amount = 11  # 2</span>
    <span class="c1"># coins = [1, 2, 5, 10]; amount = 11  # 3</span>
    <span class="c1"># coins = [2]; amount = 3 </span>
    <span class="n">coins</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># coins = [1, 2, 5]; amount = 20</span>
    <span class="c1"># coins = [186,419,83,408]; amount = 6249 # 20개 </span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">coinChange</span><span class="p">(</span><span class="n">coins</span><span class="p">,</span> <span class="n">amount</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="longest-increasing-subsequences">
<h4>Longest Increasing Subsequences<a class="headerlink" href="#longest-increasing-subsequences" title="Link to this heading">#</a></h4>
<p>문제 - <a class="reference external" href="https://leetcode.com/problems/longest-increasing-subsequence/?envType=study-plan-v2&amp;amp;envId=top-interview-150">Leetcode 300</a></p>
<div class="dropdown admonition">
<p class="admonition-title">O(<span class="math notranslate nohighlight">\(N^2\)</span>) solution</p>
<div class="literal-block-wrapper docutils container" id="id7">
<div class="code-block-caption"><span class="caption-number">예시 23 </span><span class="caption-text">state: dp[i] = length of LIS ending at index i. transition: dp[i] = 1 + max(dp[j]) for all j &lt; i with nums[j] &lt; nums[i]. answer: max(dp[i]) over all i.</span><a class="headerlink" href="#id7" title="Link to this code">#</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lengthOfLIS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="c1"># every single char.length = 1 </span>

        <span class="n">max_val</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">max_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">max_val</span><span class="p">)</span>
            
        <span class="c1"># print(dp)</span>
        <span class="k">return</span> <span class="n">max_val</span>
</pre></div>
</div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">bisect library, 위치 찾기 in LIS problem</p>
<p><code class="docutils literal notranslate"><span class="pre">bisect</span></code>는 파이썬 표준 라이브러리로, 정렬된 리스트에서 이진 탐색을 통해 원소를 삽입하거나 위치를 찾을 때 사용합니다.
정렬은 미리 되어 있어야 하고, 삽입 위치를 계산해줄 뿐 자동으로 정렬을 유지하지는 않습니다.</p>
<p>복잡도: O(logN)</p>
<ol class="arabic simple">
<li><p>bisect_left(arr, x)</p></li>
</ol>
<ul class="simple">
<li><p>정렬된 리스트 arr에서 x가 들어갈 가장 왼쪽 인덱스를 반환.</p></li>
<li><p>즉, x 이상의 원소가 처음 나타나는 위치</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">bisect</span>

<span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>  <span class="c1"># 2 (왼쪽 4의 위치)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>  <span class="c1"># 4 (8이 있는 자리)</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>bisect_right(arr, x)</p></li>
</ol>
<ul class="simple">
<li><p>정렬된 리스트 arr에서 x가 들어갈 가장 오른쪽 인덱스를 반환</p></li>
<li><p>즉, x보다 큰 원소가 처음 나타나는 위치</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">bisect</span><span class="o">.</span><span class="n">bisect_right</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="c1"># 4 (오른쪽 4 다음 위치)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">bisect</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>       <span class="c1"># 동일 (alias)</span>
</pre></div>
</div>
<p>복잡도: O(logN) (탐색) + log(N) (리스트에 삽입, 뒤 원소를 밀어야 함.)</p>
<ol class="arabic simple" start="3">
<li><p>insort_left(arr, x)</p></li>
</ol>
<ul class="simple">
<li><p>bisect_left로 위치를 찾은 뒤 x를 리스트에 삽입</p></li>
<li><p>정렬된 상태 유지</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bisect</span><span class="o">.</span><span class="n">insort_left</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># [1, 2, 4, 4, 4, 8]</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li><p>insort_right(arr, x)</p></li>
</ol>
<ul class="simple">
<li><p>bisect_right로 위치를 찾은 뒤 x를 리스트에 삽입</p></li>
<li><p>정렬된 상태 유지</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="n">bisect</span><span class="o">.</span><span class="n">insort_right</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># [1, 2, 4, 4, 4, 8]</span>
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">O(NlogN) solution</p>
<div class="literal-block-wrapper docutils container" id="id8">
<div class="code-block-caption"><span class="caption-number">예시 24 </span><span class="caption-text">시간 복잡도 O(NlogN)으로 푸는 전형적인 LIS 알고리즘은 “patience sorting (꼭대기 배열 tails 유지) + 이분 탐색”이다. 즉, <code class="docutils literal notranslate"><span class="pre">tails[k]</span></code> = “길이가 k+1인 증가 부분수열 중 마지막 값의 최소값” 을 저장한다. 배열을 왼 -&gt; 오 순서로 보며, 매 원소에 대해 <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">lower_bound(tails,</span> <span class="pre">x)</span></code> (즉, tails에서 x이상이 처음 나오는 위치)를 찾고 i == len(tails)면 tails뒤에 x를 붙이고, 아니면 tails[i] = x로 더 작은 끝값으로 갱신한다. 이렇게 하면 tails의 길이가 곧 LIS의 길이가 됨. 만약 비내림 (= 증가 허용, non-decreasing)인 경우에는 <code class="docutils literal notranslate"><span class="pre">bisect_right</span></code>을 사용하여 같은 값은 다음 길이로 넘겨 중복을 허용한다. cf) So “patience sorting” is not about fully sorting the array — it’s about simulating the pile-building strategy from the patience card game, which indirectly reveals LIS length.</span><a class="headerlink" href="#id8" title="Link to this code">#</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">bisect</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lengthOfLIS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">tails</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 길이가 idx+1인 수의 가장 작은 수를 저장 </span>

        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="c1"># strictly increasing </span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">tails</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tails</span><span class="p">):</span>
                <span class="n">tails</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tails</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span> 

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">tails</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">18</span><span class="p">]</span>
    <span class="c1"># nums = [0, 1, 0, 3, 2, 3] # 4 </span>
    <span class="c1"># nums = [7, 7, 7] # 1</span>
    <span class="c1"># nums = [7] # 1</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">lengthOfLIS</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">bisect_left implementation</p>
<ul class="simple">
<li><p><strong>Boundary definition with <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">l</span> <span class="pre">&lt;</span> <span class="pre">r</span></code> (Step 1)</strong></p>
<ul>
<li><p>Always maintain the interval [l, r) (left-inclusive, right-exclusive)</p>
<ul>
<li><p>ex. arr = [7], x = 7</p>
<ul>
<li><p>the final value of l = 0</p></li>
<li><p>the interval [l, r) changes as follows: [0, 1) -&gt; [0, 0) return 0</p></li>
</ul>
</li>
<li><p>ex. arr = [1, 7, 8], x = 7</p>
<ul>
<li><p>the final value of l = 1</p></li>
<li><p>the interval [l, r) changes as follows: [0, 3) -&gt; [0, 1) -&gt; [1, 1) return 1</p></li>
</ul>
</li>
<li><p>ex. arr = [1, 2, 5, 8], x = 5</p>
<ul>
<li><p>the final value of l = 2</p></li>
<li><ul>
<li><p>the interval [l, r) changes as follows: [0, 4) -&gt; [0, 2) -&gt; [2, 2) return 2</p></li>
</ul>
</li>
</ul>
</li>
<li><p>ex. arr = [1, 2, 2, 2, 3, 4], x = 2</p>
<ul>
<li><p>the final value of l = 1</p></li>
<li><p>the interval [l, r) changes as follows: [0, 6) -&gt; [0, 3) -&gt; [0, 2)  -&gt; [0, 1) -&gt; [1, 1) return l=1</p></li>
<li><p>if the midpoint number is equal to the target x, it should excluded from the possible interval where the target x can be inserted</p></li>
</ul>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code> is always a candidate position, and <code class="docutils literal notranslate"><span class="pre">r</span></code> is always the boundary (one step beyond the last possible position).</p></li>
<li><p>The search terminates when <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">==</span> <span class="pre">r</span></code> → no interval left to search.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code> = “the minimum candidate position to insert”</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> = “the first position where insertion is impossible (exclusive right boundary)”</p></li>
</ul>
</li>
<li><p>When they become equal, the insertion position is fixed.</p></li>
<li><p>Hence the condition must always be <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">l</span> <span class="pre">&lt;</span> <span class="pre">r</span></code>.</p></li>
<li><p>If we use <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">l</span> <span class="pre">&lt;=</span> <span class="pre">r</span></code>, then <code class="docutils literal notranslate"><span class="pre">r</span></code> must be treated as inclusive, and the code logic changes.</p></li>
</ul>
</li>
<li><p><strong>Example</strong></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">arr</span> <span class="pre">=</span> <span class="pre">[2,</span> <span class="pre">5,</span> <span class="pre">6]</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">4</span></code></p></li>
<li><p>Initial: <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">=</span> <span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">=</span> <span class="pre">3</span></code>, <code class="docutils literal notranslate"><span class="pre">mid</span> <span class="pre">=</span> <span class="pre">1</span></code></p>
<ul>
<li><p>Think of <code class="docutils literal notranslate"><span class="pre">mid</span></code> as the current comparison candidate.</p></li>
</ul>
</li>
<li><p>Step 1: <code class="docutils literal notranslate"><span class="pre">mid</span> <span class="pre">=</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">arr[mid]</span> <span class="pre">=</span> <span class="pre">5</span> <span class="pre">&gt;=</span> <span class="pre">4</span></code> → <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">=</span> <span class="pre">mid</span></code></p>
<ul>
<li><p>For <code class="docutils literal notranslate"><span class="pre">bisect_left</span></code>, when the target is equal to or smaller than the midpoint, we shrink the search interval to the left.</p></li>
</ul>
</li>
<li><p>Step 2: <code class="docutils literal notranslate"><span class="pre">mid</span> <span class="pre">=</span> <span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">arr[mid]</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">&lt;</span> <span class="pre">4</span></code> → <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">=</span> <span class="pre">mid</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">=</span> <span class="pre">1</span></code></p></li>
<li><p>Termination: <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">=</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">=</span> <span class="pre">1</span></code> → <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">l</span> <span class="pre">(1)</span></code></p></li>
<li><p>Indeed, inserting <code class="docutils literal notranslate"><span class="pre">4</span></code> at <code class="docutils literal notranslate"><span class="pre">arr[1]</span></code> keeps the array sorted.</p></li>
</ul>
</li>
</ul>
<div class="toggle docutils container">
<div class="literal-block-wrapper docutils container" id="id9">
<div class="code-block-caption"><span class="caption-number">예시 25 </span><span class="caption-text">bisect_left() implementation code</span><a class="headerlink" href="#id9" title="Link to this code">#</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">bisect_left</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="c1"># r = right-exclusive boundary</span>
    <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> 

        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span> 
    <span class="k">return</span> <span class="n">l</span> <span class="c1"># l = the &#39;first&#39; insertion position of x </span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="toggle docutils container">
<div class="literal-block-wrapper docutils container" id="id10">
<div class="code-block-caption"><span class="caption-number">예시 26 </span><span class="caption-text">수열까지 복원하기. prev_idx로 연결 리스트를 만들어 마지막 인덱스에서 거꾸로 따라가면 됩니다.</span><a class="headerlink" href="#id10" title="Link to this code">#</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">bisect</span>

<span class="k">def</span><span class="w"> </span><span class="nf">lis_with_path</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="n">tails</span> <span class="o">=</span> <span class="p">[]</span>            <span class="c1"># 값 기준(이분탐색용)</span>
    <span class="n">tails_idx</span> <span class="o">=</span> <span class="p">[]</span>        <span class="c1"># 각 길이의 꼬리 원소가 있는 nums의 인덱스</span>
    <span class="n">prev_idx</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>   <span class="c1"># 각 원소의 LIS에서의 이전 원소 인덱스</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">tails</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tails</span><span class="p">):</span>
            <span class="n">tails</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">tails_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tails</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">tails_idx</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">prev_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tails_idx</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># 복원</span>
    <span class="n">lis_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tails</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">tails_idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">k</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">prev_idx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="n">seq</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">lis_len</span><span class="p">,</span> <span class="n">seq</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="number-of-lis">
<h4>Number of LIS<a class="headerlink" href="#number-of-lis" title="Link to this heading">#</a></h4>
<p>문제 - <a class="reference external" href="https://leetcode.com/problems/number-of-longest-increasing-subsequence/description/">Leetcode 673</a></p>
<div class="dropdown admonition">
<p class="admonition-title">solution O(<span class="math notranslate nohighlight">\(N^2\)</span>)</p>
<div class="literal-block-wrapper docutils container" id="id11">
<div class="code-block-caption"><span class="caption-number">예시 27 </span><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">len[i]</span></code>: length of the LIS ending at i, <code class="docutils literal notranslate"><span class="pre">cnt[i]</span></code>: the number of LIS of that length that end at i</span><a class="headerlink" href="#id11" title="Link to this code">#</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span> 

<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">findNumberOfLIS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span>
        <span class="n">length</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="n">count</span>  <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">length</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">length</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">length</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="o">=</span> <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">length</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">length</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="n">L</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="is-subsequence">
<h4>Is Subsequence<a class="headerlink" href="#is-subsequence" title="Link to this heading">#</a></h4>
<p>문제 - <a class="reference external" href="https://leetcode.com/problems/is-subsequence/description/?envType=problem-list-v2&amp;amp;envId=dynamic-programming">Leetcode 392</a></p>
<div class="dropdown admonition">
<p class="admonition-title">Time complexity and Algorithm Implementation</p>
<ul class="simple">
<li><p>Constraints:</p>
<ul>
<li><p>0 &lt;= s.length &lt;= 100</p></li>
<li><p>0 &lt;= t.length &lt;= <span class="math notranslate nohighlight">\(10^4\)</span></p></li>
<li><p>s and t consist only of lowercase English letters</p></li>
</ul>
</li>
</ul>
<p>Based on constraints stated above,
Follow up: Suppose there are lots of incoming s, say <span class="math notranslate nohighlight">\(s_{1}, s_{2}, s{3}, ..., s_{k}\)</span> where k &gt;= <span class="math notranslate nohighlight">\(10^9\)</span>, and you want to check one by one to see if t has its subsequence. In this scenario, how would you change your code?</p>
<ul class="simple">
<li><p>Single query: Use tow pointers. Time <code class="docutils literal notranslate"><span class="pre">O(|s|</span> <span class="pre">+</span> <span class="pre">|t|)</span></code>, space O(1)</p></li>
<li><p>Follow-up (many s): Preprocess <code class="docutils literal notranslate"><span class="pre">t</span></code></p>
<ul>
<li><p>Positions + binary search: preprocess <code class="docutils literal notranslate"><span class="pre">O(|t|)</span></code>, per query <code class="docutils literal notranslate"><span class="pre">O(|s|log|t|)</span></code></p></li>
</ul>
</li>
</ul>
</div>
<div class="dropdown admonition">
<p class="admonition-title">single query solution</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">isSubsequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span> 
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">ch</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">Follow-up (many s) solution</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">bisect</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">preprocess_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="n">pos</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pos</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">isSubsequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span><span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preprocess_positions</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        
        <span class="n">cur</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">cur</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span> 
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">True</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="multidimensional-dp">
<h3>2. Multidimensional DP<a class="headerlink" href="#multidimensional-dp" title="Link to this heading">#</a></h3>
<section id="russian-doll-envelope">
<h4>Russian Doll Envelope<a class="headerlink" href="#russian-doll-envelope" title="Link to this heading">#</a></h4>
<p>문제 - <a class="reference external" href="https://leetcode.com/problems/russian-doll-envelopes/description/">Leetcode 354</a></p>
<div class="dropdown admonition">
<p class="admonition-title">O(<span class="math notranslate nohighlight">\(N^2\)</span>) solution: Time limit error</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w1</span><span class="p">,</span> <span class="n">h1</span><span class="p">,</span> <span class="n">w2</span><span class="p">,</span> <span class="n">h2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">w1</span> <span class="o">&lt;</span> <span class="n">w2</span> <span class="ow">and</span> <span class="n">h1</span> <span class="o">&lt;</span> <span class="n">h2</span> <span class="c1"># 같을 때도 다 False </span>

    <span class="k">def</span><span class="w"> </span><span class="nf">maxEnvelopes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">envelopes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">envelopes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span> 
        <span class="c1"># print(envelopes)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">envelopes</span><span class="p">)</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="n">max_val</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">prev</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">w1</span><span class="p">,</span> <span class="n">h1</span> <span class="o">=</span> <span class="n">envelopes</span><span class="p">[</span><span class="n">prev</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">envelopes</span><span class="p">[</span><span class="n">prev</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">cur_w</span><span class="p">,</span> <span class="n">cur_h</span> <span class="o">=</span> <span class="n">envelopes</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">envelopes</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">w1</span><span class="p">,</span> <span class="n">h1</span><span class="p">,</span> <span class="n">cur_w</span><span class="p">,</span> <span class="n">cur_h</span><span class="p">):</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">prev</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">max_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">max_val</span><span class="p">)</span>
        <span class="c1"># print(dp)</span>
        <span class="k">return</span> <span class="n">max_val</span>
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">O(nlogn) solution</p>
<div class="literal-block-wrapper docutils container" id="id12">
<div class="code-block-caption"><span class="caption-number">예시 28 </span><span class="caption-text">정렬할 때, <code class="docutils literal notranslate"><span class="pre">width</span></code>는 오름차순, <code class="docutils literal notranslate"><span class="pre">height</span></code>는 내림차순 (동일한 width끼리는 겹치지 않도록)-&gt; 이렇게 하면 같은 width끼리 height가 증가로 잡히는 일을 막아서, 나중에 heigh만 보고 LIS를 구해도 “width 증가” 조건이 자동으로 보장됨. height 배열만 뽑아 LIS를 하면 LIS는 이진 탐색으로 tails 배열을 유지하여 O(NlogN)에 가능</span><a class="headerlink" href="#id12" title="Link to this code">#</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">bisect</span><span class="w"> </span><span class="kn">import</span> <span class="n">bisect_left</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">maxEnvelopes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">envelopes</span><span class="p">):</span>
        <span class="c1"># 1) 정렬: w 오름차순, w 같으면 h 내림차순</span>
        <span class="n">envelopes</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># 2) height만 뽑아서 LIS (strictly increasing)</span>
        <span class="n">tails</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">envelopes</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">tails</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>  <span class="c1"># h가 들어갈 위치</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tails</span><span class="p">):</span>
                <span class="n">tails</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tails</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">tails</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="triangle">
<h4>Triangle<a class="headerlink" href="#triangle" title="Link to this heading">#</a></h4>
<p>문제 - <a class="reference external" href="https://leetcode.com/problems/triangle/description/?envType=study-plan-v2&amp;amp;envId=top-interview-150">Leetcode 120</a></p>
<div class="dropdown admonition">
<p class="admonition-title">Memory Space O(N)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">minimumTotal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">triangle</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">num_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">triangle</span><span class="p">)</span>
    
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># dp[row] = store the minimum path sum at row with 2D array </span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">triangle</span><span class="p">:</span>
            <span class="n">dp</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)))</span>

        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">triangle</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="c1"># base case </span>
        <span class="c1"># print(dp)</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># 오른쪽위만 있는 경우</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># print(type(row), type(i), type(dp), type(triangle))</span>
                    <span class="c1"># print(row, i, dp, triangle)</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">triangle</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="c1"># 왼쪽 위만 있는 경우 (row에는 index row까지만 숫자가 존재함.)</span>
                <span class="k">elif</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">triangle</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="c1"># 둘다 있는 경우 </span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">triangle</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">dp</span><span class="p">[</span><span class="n">num_rows</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
</section>
<section id="minimum-path-sum">
<h4>Minimum Path Sum<a class="headerlink" href="#minimum-path-sum" title="Link to this heading">#</a></h4>
<p>문제 - <a class="reference external" href="https://leetcode.com/problems/minimum-path-sum/description/?envType=study-plan-v2&amp;amp;envId=top-interview-150">Leetcode 64</a></p>
<div class="dropdown admonition">
<p class="admonition-title">O(MxN) time complexity solution</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">minPathSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>

        <span class="c1"># directions </span>
        <span class="n">DIRS</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># base case : edges </span>
        <span class="c1"># the lowest right dp[m-1][n-1]</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># 1. bottom line </span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># inside the dp grids </span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">y</span><span class="o">+</span><span class="n">DIRS</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]][</span><span class="n">x</span><span class="o">+</span> <span class="n">DIRS</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dp</span><span class="p">[</span><span class="n">y</span><span class="o">+</span><span class="n">DIRS</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]][</span><span class="n">x</span> <span class="o">+</span> <span class="n">DIRS</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>


        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</section>
<section id="unique-path-ii">
<h4>Unique Path II<a class="headerlink" href="#unique-path-ii" title="Link to this heading">#</a></h4>
<p>문제 - <a class="reference external" href="https://leetcode.com/problems/unique-paths-ii?envType=study-plan-v2&amp;amp;envId=top-interview-150">Leetcode 63</a></p>
</section>
<section id="longest-palindromic-substring">
<h4>Longest Palindromic Substring<a class="headerlink" href="#longest-palindromic-substring" title="Link to this heading">#</a></h4>
<p>문제 - <a class="reference external" href="https://leetcode.com/problems/longest-palindromic-substring/description/?envType=study-plan-v2&amp;amp;envId=top-interview-150">Leetcode 5</a></p>
</section>
<section id="interleaving-string">
<h4>Interleaving String<a class="headerlink" href="#interleaving-string" title="Link to this heading">#</a></h4>
<p>문제 - <a class="reference external" href="https://leetcode.com/problems/interleaving-string/description/?envType=study-plan-v2&amp;amp;envId=top-interview-150">Leetcode 97</a></p>
</section>
<section id="edit-distance">
<h4>Edit Distance<a class="headerlink" href="#edit-distance" title="Link to this heading">#</a></h4>
<p>문제 - <a class="reference external" href="https://leetcode.com/problems/edit-distance/description/?envType=study-plan-v2&amp;amp;envId=top-interview-150">Leetcode 72</a></p>
</section>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./_pages/theory"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="3_backtracking.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">이전</p>
        <p class="prev-next-title">Lecture 3-1. Backtracking</p>
      </div>
    </a>
    <a class="right-next"
       href="5_sort.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">다음</p>
        <p class="prev-next-title">Lecture 5-1. 정렬</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> 내용
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#dp">DP 조건</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-2">DP 2가지 구현 방식</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">메모이제이션</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">시간복잡도</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#top-down">Top-Down 방식</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bottom-up">Bottom-Up 방식</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamic-programming-table-dp-table">Dynamic Programming Table (DP Table)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sequence-array-dp">1. Sequence / Array DP</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#subsequence-string-dp">2. Subsequence/String DP</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#knapsack-family">3. Knapsack Family</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#grid-dp">4. Grid DP</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#interval-dp">5. Interval DP</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tree-dp">6. Tree DP</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#summary">Summary</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">예시 문제</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#d-dp">1. 1D DP</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#climbing-stairs">Climbing Stairs</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#house-robber">House Robber</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#word-break">Word Break</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#coin-change">Coin Change</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#longest-increasing-subsequences">Longest Increasing Subsequences</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#number-of-lis">Number of LIS</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#is-subsequence">Is Subsequence</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multidimensional-dp">2. Multidimensional DP</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#russian-doll-envelope">Russian Doll Envelope</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#triangle">Triangle</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#minimum-path-sum">Minimum Path Sum</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#unique-path-ii">Unique Path II</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#longest-palindromic-substring">Longest Palindromic Substring</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#interleaving-string">Interleaving String</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#edit-distance">Edit Distance</a></li>
</ul>
</li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
으로 Daye Lee
</p>

  </div>
  
  <div class="footer-item">
    

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>