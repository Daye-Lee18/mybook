1. BFS에서 도착지점에 있는 수가 명확하다면, 굳이 graph에서 먼저 찾을 필요 없음 
   - 예를 들어, 단면도의 도착지점 graph[y][x] = 4 로 이미 있으므로, 굳이 시간들여 찾을 필요 없음 
   - bfs의 while loop에서 graph[cury][curx] == 4 이면 멈추면 되기 때문
   - 하지만 시간의 벽에서는 탈출구가 명확하지 않으므로 단면도에서 시작점을 찾아 그 시간의 벽쪽방향에 위치한 옆의 셀을 3D상에서의 도착지점으로 찾아놓을 필요가 있다. 
  
2. 시간의 벽 5개의 단면도를 3*M x 3*M 으로 그릴때 아래처럼 변환해서 붙여야함. 
   1. 동: 90도 rotation 
   2. 서: 270도 rotation 
   3. 남: 그대로 
   4. 북: 180도 rotation 

```python
N = len(original_graph) # 정방형 행렬일 때 
new_graph[N-x-1][y] = original_graph[y][x]
```

3. cur_time 이 지나면 시간이상자 확산 
   - while loop안에서 돌면, 같은 시간에 여러 time 이 있을 수 있게 되는데
   - time % f_v == 0이라고 해서 무조건 확산하게 되면 큰 오류가 된다. 
   - 예를 들어, f_v = 14이고 cur_time = 14여서 한 번만 확산해야하는데, BFS의 특성상 같은 시간에 여러 좌표에 있을 수 있어 확산이 2, 3번 더 되는 것이다. 
   - 또한, BFS를 돌릴때 q.popleft() 직후에도 현재 위치에 시간 이상자가 있는지 확인해줘야 함. 
     - T=13일때 다음 t=14에 대한 타임머신 위치가 업데이트되는데, 이에 대해서 우선적으로 시간이상자가 그쪽까지 도달했는지 확인하는 
  
4. 단면도 -> 시간의 벽에 대한 좌표로 변환 `transform_2D_to_3D_wall()`
   1. 시간이상자가 확산될 때 단면도에서 시간의 벽으로 이동 가능 
   2. 단면도에서의 시작점 -> 시간의 벽에서의 도착점으로 변환해야함. 

![](../../assets/img/DFS_BFSPS/17.png)


1.  `find_next_cell()` 시간의 벽 (3M x 3M )그래프에서 4방향 말고, 변끼리 닿는 격자끼리 이동할 수 있도록 해야함. 

![](../../assets/img/DFS_BFSPS/16.png)

6. `debug()` : test case에서 잘못 된 경우, 디버깅을 한 후 코드 제출할 때 debug() 실행만 지워서 편하게 코드 제출할 수 있도록 print() 명령들을 모아놓음. 