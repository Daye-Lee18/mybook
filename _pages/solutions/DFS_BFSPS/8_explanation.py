'''
NxM 격자 
- 모든 위치에 포탑 존재 (총 포탑 개수 NxM) <= 10 
- 1~N (1-indexed)
- 포탑 
    - 공격력: 줄어들거나 늘 수 있음 
    - 공격력이 0 이하가 되면 (음수도 가능), 해당 포탑은 부서지며 더 이상 공격 불가능 
    - 최초에 공격력이 0인, 부서진 포탑도 존재할 수 있다. 

총 K번의 턴  <= 1000
한 턴당 4가지 액션을 순서대로 수행하며 NOTE: 부서지지 않은 포탑이 1개가 되면 그 즉시 중지된다. 
액션 1. 공격자 선정 
- 부서지지 않은 포탑 중 가장 약한 포탑이 공격자가 됨. 
- 이 포탑의 공격력이 N+M만큼 증가함 
- 선정 기준 
    - 공격력이 가장 낮음 
    - 같은 공격력이면, 가장 최근에 공격한 포탑 (모든 포탑은 시점 0에는 공격한 경험이 있다고 가정)
    - 그래도 같다면, 행+열의 합이 가장 큰 포탑 (y+x) 
    - 그래도 같다면, 열 값이 가장 큰 포탑 (x) 

액션 2. 공격자 공격 : 
- XXX: 공격을 당한 "피공격자"의 정보를 모두 가지고 있어야 공격력들을 뺄 수 있음. 
- 공격자는 "자신을 제외한" 가장 강한 포탑을 공격 
- 선정 기준 
    - 공격력이 가장 높음 (NOTE: max_heap은 - 값을 붙여야함.)
    - 같으면, 공격한지 가장 오래된 포탑 (모든 포탑은 시점 0에는 공격한 경험 존재)
    - 그래도 같다면, 행 + 열의 합이 가장 작은 포탑 
    - 그래도 같다면 열 값이 가장 작은 포탑 (x) 

NOTE: 공격자와 피공격자은 완전히 반대되는 입장임. 
근데, class Top은 하나의 __lt__를 가질 수 있어서, 클래스 기반으로 이중 pq를 구현하기에는 어려울 것 같음. 
sort()로 하면 좋긴한데, 삭제되고 난 이후에 검색을 할 때 최대 O(N^2)이 걸릴 수 있음. 
따라서, 이중 pq로 진행하된, class를 구현하기보다 Tuple로 데이터를 운용하는게 좋을 수도 있겠음. 

- 레이저 공격 먼저 시도하고 안되면 -> 포탄 공격 (XXX: 두개다 하면 안됨. )
- 1. 최단 경로 설정  XXX: 여기가 bottleneck일것같음. 
- 레이저는 
    - 상하좌우의 4개 방향으로 움직일 수 있음 
    - 부서진 포탑이 있는 위치는 지날 수 없음 
    - 가장자리에서 막힌 방향으로 진행하고자 하면, 반대편으로 나옴 (오른쪽 -> 맨 처음, 맨 왼쪽 -> 맨 뒤, 맨 위-> 맨아래, 맨 아래 -> 맨위)
- 위의 방향대로 최단 경로가 존재하면, 이 경로대로 공격 
    - 만약 최단경로가 2개 이상이면, 
        - NOTE: 우/하/좌/상의 우선순위대로 먼저 움직인 경로가 선택됨. 
- NOTE: 최단 경로를 tracking해놔야함. 
    - 포탑이 죽은 경우에는 미리 tracking해놓은 걸 쓸 수 없어서, 
    - 그때그때 경로 추적해야할 것 같음. 
2. 최단 경로 설정 후에, 
    - 공격대상은 공격자의 공격력 만큼의 피해를 입으며, 공격력이 줄어듦. 
    - 공격 대상을 제외한 "경로"에 있는 포탑도 공격을 받게 되는데, 이 포탑은 공격자의 공격력의 "절반"만큼의 공격을 받은 
        - 절반: 2로 나는 몫 (//)
3.  존재하지 않으면, 포탄 공격 진행. 
- 공격 대상에 포탄을 던짐. 
- 추가적으로 주위 8개 의 방향에 있는 포탑도 피해를 입음 (피해 반경). 
- 공격자의 절반 만큼의 피해를 받음. 
- 공격자 자신은 해당 공격의 영향을 받지 않음. 
- 만약, 가장자리의 경우에는 포탄의 추가 피해가 반대편 격자에 미치게 됨. 
    - 즉, 격자는 NxN 2D graph라기 보다, 서로 연결된 지구같은 느낌임. 
    - NOTE: 이때도 공격받은 포탑들의 위치를 알아야함. 



액션 3: 
- 공격을 받아 공격력이 0 이하가 된 포탑은 부서진다. 
- 이미 graph안에 정보가 저장되어 있음. 

액션 4: 포탑 정비 
- 공격 후에 부서지지 않은 포탑 중 "공격과 무관했던 포탑"은 공격력이 1씩 올라감. 
    - 공격자와 공격에 피해를 입은 포탑도 아님 
    - 즉, 공격자 + 피공격자 + 레이저의 경우 그 경로에 있던 포탑들  + 포탄 공격의 경우 주위 8개 피해 반경 


Return: 
- 전체 과정이 종료된 후, 남아잇는 포탑 중 가장 강한 포탑의 공격력을 출력하는 프로그램. 

constraints: 
K <= 1000 : 1000개의 turn이 있어서, 포탑 선정 -> 공격자 선정 -> 공격 (레이저 -> 포탄)
'''

class Top: # 26 KM (최대 100개)
    def __init__(self, id, y, x, p):
        self.id = id 
        self.y = y 
        self.x = x 
        self.p = p 
        self.attack_time = 0

top1 = Top(1, 2, 3, 4)
import sys 

N = 10 
print(sys.getsizeof(top1) + sys.getsizeof(top1.__dict__) + sys.getsizeof(top1.id) + sys.getsizeof(top1.y)+sys.getsizeof(top1.x)+sys.getsizeof(top1.p)   )
print(264*10*10)