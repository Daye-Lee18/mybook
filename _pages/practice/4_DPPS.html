
<!DOCTYPE html>


<html lang="ko" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Lecture 4-2. DP 실습 &#8212; 말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css?v=6644e6bb" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/proof.css?v=b4b7a797" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=8127ecf8" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=ae323b5b"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="../../_static/translations.js?v=e33e7ba0"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_pages/practice/4_DPPS';</script>
    <script src="https://unpkg.com/jupyterquiz@1.1.8/dist/jupyterquiz.min.js"></script>
    <link rel="icon" href="../../_static/favicon.png"/>
    <link rel="index" title="색인" href="../../genindex.html" />
    <link rel="search" title="검색" href="../../search.html" />
    <link rel="next" title="Lecture 5-2. Shortest Path &amp; Heap" href="5_shortest_pathPS.html" />
    <link rel="prev" title="Lecture 3-2. Backtracking 실습" href="3_backtrackingPS.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="ko"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/mylogo.png" class="logo__image only-light" alt="말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업 - Home"/>
    <script>document.write(`<img src="../../_static/mylogo.png" class="logo__image only-dark" alt="말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업 - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="검색" aria-label="검색" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">검색</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Welcome to 말레이시아 5급 IT 수업
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">기초</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../basics/Input.html">입력</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basics/oop.html">객체 지향 프로그래밍 (OOP)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basics/oop-classes_instances_objects.html">클래스, 인스턴스, 객체</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basics/regex.html">정규표현식</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basics/variable_scope.html">Variable Scope</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">이론</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../theory/0_tips.html">문제 풀이 순서 팁 (Tips)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/1_implementation.html">Lecture 1-1. 구현</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/2_DFS_BFS.html">Lecture 2-1. DFS/BFS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/3_backtracking.html">Lecture 3-1. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/4_DP.html">Lecture 4-1. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/5_shortest_path.html">Lecture 5-1. Shortest Path</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/6_sort.html">Lecture 6-1. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/7_binarysearch.html">Lecture 7-1. Binary Search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/8_graph.html">Lecture 8-1. Graph Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/9_greedy.html">Lecture 9-1. Greedy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/10_prefix.html">Lecture 10-1. Prefix Sum (누적 합)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/11_LinkedList.html">Lecture 11-1. Linked List</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">실습</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="1_implementationPS.html">Lecture 1-2. 구현 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_DFS_BFSPS.html">Lecture 2-2. DFS/BFS 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_backtrackingPS.html">Lecture 3-2. Backtracking 실습</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Lecture 4-2. DP 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="5_shortest_pathPS.html">Lecture 5-2. Shortest Path &amp; Heap</a></li>
<li class="toctree-l1"><a class="reference internal" href="6_sortPS.html">Lecture 6-2. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_linked_listPS.html">Lecture 11-2. Linked List</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">시험</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../exams/midterm_student.html">Midterm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../exams/final_student.html">Final</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="이 페이지 다운로드">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/_pages/practice/4_DPPS.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="소스 파일 다운로드"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="PDF로 인쇄"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="전체 화면으로보기"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="검색" aria-label="검색" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Lecture 4-2. DP 실습</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> 내용 </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#treedp">TreeDP</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">서브트리의 정점 개수 세기</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">우수 마을</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">사회망 서비스</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diameter-of-binary-tree">Diameter of Binary Tree</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#binary-tree-max-path-sum">Binary Tree Max Path Sum</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">코테 기출</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">색깔 트리</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#string-compression-ii">3번: String Compression II</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="lecture-4-2-dp">
<h1>Lecture 4-2. DP 실습<a class="headerlink" href="#lecture-4-2-dp" title="Link to this heading">#</a></h1>
<p>들어가기전, DP 문제를 풀 때 아래 정보들에 유념해서 문제를 푼다면 훨씬 도움이 될 것이다.</p>
<div class="important admonition">
<p class="admonition-title">Things to think for a DP problem</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 6개 checklist </span>
<span class="c1"># 1) State: dp[...]</span>
<span class="c1"># 2) What to store: min/max/count/bool/value (필요시 prev/choice)</span>
<span class="c1"># 3) Base case init</span>
<span class="c1"># 4) Fill order: 작은 상태 → 큰 상태 (Top-down/Bottom-up)</span>
<span class="c1"># 5) Transition</span>
<span class="c1"># 6) Read answer</span>

<span class="k">def</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="c1"># 예: 2D (i, j)</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="n">INF</span><span class="p">]</span><span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="c1"># base cases</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">f</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="o">...</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">g</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">...</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
</div>
<ul class="simple">
<li><p>DP 고득점 Kit</p>
<ul>
<li><p><a class="reference external" href="https://school.programmers.co.kr/learn/courses/30/lessons/42895">N으로 표현</a></p></li>
<li><p><a class="reference external" href="https://school.programmers.co.kr/learn/courses/30/lessons/43105">정수 삼각형</a></p></li>
<li><p><a class="reference external" href="https://school.programmers.co.kr/learn/courses/30/lessons/42898">등굣길</a></p></li>
<li><p><a class="reference external" href="https://school.programmers.co.kr/learn/courses/30/lessons/1843">사칙연산</a></p></li>
<li><p><a class="reference external" href="https://school.programmers.co.kr/learn/courses/30/lessons/42897">도둑질</a></p></li>
</ul>
</li>
<li><p>Tree DP</p>
<ul>
<li><p><a class="reference external" href="https://www.acmicpc.net/problem/15681">서브트리에 포함된 정점의 개수 세기</a>: <a class="reference external" href="https://wikidocs.net/272872">정답</a></p></li>
<li><p><a class="reference external" href="https://www.acmicpc.net/problem/1949">우수 마을</a>: <a class="reference external" href="https://wikidocs.net/274552">정답</a></p></li>
<li><p><a class="reference external" href="https://www.acmicpc.net/problem/2533">사회망 서비스</a>: <a class="reference external" href="https://wikidocs.net/273100">정답</a></p></li>
<li><p><a class="reference external" href="https://leetcode.com/problems/diameter-of-binary-tree/description/">Diameter of Binary Tree</a></p></li>
<li><p><a class="reference external" href="https://leetcode.com/problems/longest-path-with-different-adjacent-characters/description/">Longest Path with Different Adjacent Character</a></p></li>
<li><p><a class="reference external" href="https://leetcode.com/problems/binary-tree-maximum-path-sum/description/">Binary Tree Max Path Sum</a></p></li>
<li><p><a class="reference external" href="https://leetcode.com/problems/binary-tree-maximum-path-sum/description/">Difference Between Maximum and Minimum Price Sum</a></p></li>
<li><p><a class="reference external" href="https://leetcode.com/problems/house-robber-iii/description/">House Robber 3</a></p></li>
</ul>
</li>
<li><p>코테 기출</p>
<ul>
<li><p><a class="reference external" href="https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/color-tree/description">색깔 트리</a></p></li>
<li><p><a class="reference external" href="https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/codetree-messenger/description">코드트리 메신저</a></p></li>
<li><p><a class="reference external" href="https://leetcode.com/problems/string-compression-ii/description/">String Compression II</a></p></li>
</ul>
</li>
</ul>
<section id="treedp">
<h2>TreeDP<a class="headerlink" href="#treedp" title="Link to this heading">#</a></h2>
<section id="id1">
<h3>서브트리의 정점 개수 세기<a class="headerlink" href="#id1" title="Link to this heading">#</a></h3>
<div class="dropdown admonition">
<p class="admonition-title">Tree DP에서 Bottom-up 방식으로 구현하는 이유</p>
<ul class="simple">
<li><p><strong>Tree DP는 보통 Bottom-up(post-order DFS)으로 구현한다.</strong><br />
→ 자식들의 값을 모두 구한 뒤 부모 값을 계산하는 구조이기 때문.</p></li>
<li><p>경우에 따라 부모 정보를 자식에게 넘겨야 하는 문제는 Top-down(pre-order DFS)을 병행하기도 한다.</p></li>
<li><p>따라서 Tree DP에서는 보통 <code class="docutils literal notranslate"><span class="pre">dfs(curr,</span> <span class="pre">parent)</span></code> 형태로 구현해,<br />
parent-child 관계를 유지하며 DP 값을 계산한다.</p></li>
<li><p>또한 기본적으로 “parent”와 “children”정보는 그래프를 받을 때 저장을 해놓야하는 정보이다.</p></li>
</ul>
<p>기본 post-order dfs는 다음과 같다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># u: 현재 노드, p: parent node </span>
<span class="k">def</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="n">dp</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>   <span class="c1"># 자신도 자신을 루트로 하는 서브트리에 포함되므로 0이 아닌 1에서 시작한다.</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
        <span class="c1"># tree에서 현재 노드와 연결되어 있는 노드 중 p (부모)빼고는 모두 children이다.</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">p</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>             <span class="c1"># 자식 처리</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>        <span class="c1"># 자식 값 합치기</span>
</pre></div>
</div>
<p>아래의 그림처럼, acyclic graph를 트리로 변환하는 함수를 구현할 수 있다.</p>
<p><img alt="1" src="../../_images/14.png" /></p>
<div class="toggle docutils container">
<p>‘’’
예시)
9 5 8
1 3
4 3
5 4
5 6
6 7
2 3
9 6
6 8</p>
<p>‘’’
n, r, e = map(int, input().split())</p>
<p>graph = [[] for _ in range(n+1)]
children_list = [[] for _ in range(n+1)]
parent_list = [0] * (n+1)
visited = [False] * (n+1)
for _ in range(e):
a, b= map(int, input().split())
graph[a].append(b)
graph[b].append(a)</p>
<h1 class="rubric" id="parent-node-r-tree-top-down-pre-order-dfs">parent node가 r인경우 tree로 만들기, top-down (pre-order dfs)</h1>
<p>def makeTree(cur_node, parent):
visited[cur_node] = True</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for node in graph[cur_node]:
    if node != parent and not visited[node]:
        makeTree(node, cur_node)
        children_list[cur_node].append(node)
        parent_list[node] = cur_node
</pre></div>
</div>
<h1 class="rubric" id="root">root에서 시작</h1>
<p>makeTree(r, 0)</p>
<p>print(f”parent list: {parent_list}”)
print(f”children list: {children_list}”)</p>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">makeTree and count_subtree</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># f = open(&#39;Input.txt&#39;, &#39;r&#39;)</span>
<span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

<span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="n">children_list</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="n">parent_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># print(_)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
    <span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">graph</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="c1"># parent node가 r인경우 tree로 만들기, top-down (pre-order dfs)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">makeTree</span><span class="p">(</span><span class="n">cur_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">cur_node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> 

    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">cur_node</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">node</span> <span class="o">!=</span> <span class="n">parent</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="n">makeTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cur_node</span><span class="p">)</span>
            <span class="n">children_list</span><span class="p">[</span><span class="n">cur_node</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">parent_list</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_node</span>

<span class="c1"># root에서 시작 </span>
<span class="n">makeTree</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># print(f&quot;parent list: {parent_list}&quot;)</span>
<span class="c1"># print(f&quot;children list: {children_list}&quot;)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">count_subtree</span><span class="p">(</span><span class="n">cur_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
   <span class="n">dp</span><span class="p">[</span><span class="n">cur_node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> 

   <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">children_list</span><span class="p">[</span><span class="n">cur_node</span><span class="p">]:</span>
       <span class="n">count_subtree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cur_node</span><span class="p">)</span>
       <span class="n">dp</span><span class="p">[</span><span class="n">cur_node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>

<span class="n">count_subtree</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="n">root</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">root</span><span class="p">])</span>
    
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">solution</p>
<p>문제는 위에처럼 maketree와 count_subtree를 따로 만들면, 두번의 dfs를 거쳐야해서 타임 아웃이 된다. 이미 데이터를 받을 때, graph정보안에 하나의 parent빼고 모두 children을 담고 있으므로 이를 이용하여, maketree함수를 따로 만드는 대신, count_tree함수만 사용할 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="mi">1_000_000</span><span class="p">)</span>
<span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span>

<span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

<span class="n">g</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
    <span class="n">g</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">g</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
    <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">p</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">dp</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>
    <span class="k">return</span> <span class="n">size</span>

<span class="n">dfs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="n">u</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">u</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>
</pre></div>
</div>
</div>
</section>
<section id="id2">
<h3>우수 마을<a class="headerlink" href="#id2" title="Link to this heading">#</a></h3>
<div class="dropdown admonition">
<p class="admonition-title">Top-down Solution</p>
<p>이것을 DP로 구현하기 위해서 두 가지 경우를 생각하면 됩니다. 자신이 우수 마을인 경우와, 자신이 일반 마을인 경우 입니다.
첫 번째로 자신이 우수 마을이라면 자신의 자식 마을은 무조건 일반 마을이어야 합니다. 우수 마을끼리는 인접할 수 없기 때문에 자식 마을이 우수 마을일 수는 없습니다. 반대로 자신이 일반 마을이라면 자식 마을이 꼭 우수 마을일 필요는 없습니다. 부모 마을이 우수 마을이면 되기 때문 입니다.</p>
<p><img alt="2" src="../../_images/23.png" /></p>
<p>위 그림에서 회색 우수 마을, 파란색은 흰색을 마을이라 생각해 보겠습니다. 1번이 우수 마을이라면 자신의 자식 마을인 2번은 반드시 일반 마을이어야 합니다. 반대로 2번이 일반 마을인 경우에는 자식 마을 3번, 6번이 우수 마을일 필요는 없습니다. 이와 같은 규칙으로 우리는 인구수가 최대한 많은 경우만 따져주면 됩니다.</p>
<p>즉, 아래의 규칙을 따르는 프로그램을 구현하면 된다.</p>
<ul class="simple">
<li><p>현재 노드가 우수마을이면 자식 마을은 반드시 일반 마을</p></li>
<li><p>현재 노드가 일반 마을이라면, 자식 마을은 일반 마을/우수 마을 둘 다 가능</p></li>
<li><p>state: dp[node] = the node id</p></li>
<li><p>what to store: (현재 노드가 우수 마을인 경우 ‘subtree’의 전체 인구수 , 현재 노드가 일반 마을인 경우 ‘subtree’의 전체 인구수)</p></li>
<li><p>init: (num people of the node, 0)</p></li>
<li><p>recurrence relation:
dp[parent][0] += dp[child][1]
dp[parent][1] += max(dp[child][0], dp[child][1])</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span> 

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">1-indexed (1~N)나라 </span>
<span class="sd">- N-1개 길 (edge): tree</span>
<span class="sd">- 방향성 없음 </span>

<span class="sd">우수마을 선정 </span>
<span class="sd">- 우수 마을로 선정된 마을 주민 수의 총 합을 최대로 함 </span>
<span class="sd">- 우수 마을끼리는 서로 인접하지 않음 </span>
<span class="sd">- 우수 마을로 선정되지 못한 마을은 적어도 &#39;하나의&#39; 우수 마을과는 인접해 있다. </span>

<span class="sd">constraints </span>
<span class="sd">1 &lt;= N &lt;= 1e4 </span>
<span class="sd">마을주민수 &lt;= 1e4 </span>

<span class="sd">- 마을끼리 그룹을 이루어서 떨어져있다면? </span>
<span class="sd">-&gt; 불가능. 문제에서 마을과 마을사이를 직접 잇는 N-1개의 길이 있다고 하였음. 즉, 이 문제는 트리 문제이고, 떨어져있는 마을들이 없다고 가정함. </span>
<span class="sd">-&gt; cycle도 없음. N개의 마을을 N-1개의 선으로 이을때 cycle을 만들 수 없음. </span>

<span class="sd">문제를 읽어보면, 작은 subtree를 먼저 계산해야 최종적으로 큰 트리에서 최대 합을 구할 수 있으므로, DFS (top-down)방식을 이용해 문제를 푼다. </span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span> 

<span class="c1"># sys.stdin = open(&#39;Input.txt&#39;)</span>
<span class="n">sys</span><span class="o">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">1e4</span><span class="p">))</span> <span class="c1"># 마을의 개수가 최대 1e4개 이므로 재귀를 N까지 올려줌. </span>

<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="n">populations</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">populations</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())))</span>
<span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
    <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="c1"># status: each node </span>
<span class="c1"># (현재 노드가 우수노드, 현재 노드가 우수노드아님.)</span>
<span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="n">populations</span><span class="p">[</span><span class="n">_</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">dp</span> 
    <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> 

    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">child</span><span class="p">]:</span>
            <span class="k">continue</span> 

        <span class="n">dfs</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">child</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">child</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">child</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

<span class="n">dfs</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 아무 노드나 root로 선정 </span>
<span class="nb">print</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
</div>
</section>
<section id="id3">
<h3>사회망 서비스<a class="headerlink" href="#id3" title="Link to this heading">#</a></h3>
<div class="dropdown admonition">
<p class="admonition-title">Idea</p>
<p><img alt="" src="../../_images/315.png" /></p>
<p>Top-down으로 풀 경우, 트리에 3개의 노드가 있는 경우 위의 그림처럼 경우의수를 구할 수 있다.
즉, 현재 노드가 early adopter여야만 하는 경우는 딱 한 가지 경우이다.
반면, 현재 노드가 early adopter인 경우에는 children노드가 어떤 상황인지 전혀 상관없고, 그저 최소한의 경우를 가지고 오면 된다.</p>
<p>그러나, 재귀함수를 이용해 답안을 적으면, 겨우 통과되는데, 파이썬으로는 재귀를 이용하여 문제를 풀면, 잘 메모리나 재귀횟수때문에 통과가 안되는 일이 많다. 따라서, 위의 DFS 방식을 BFS 방식으로 바꿔야한다.</p>
<p>&lt;DFS를 BFS로 바꾸는 스텝&gt;</p>
<ul class="simple">
<li><p>먼저 BFS로 모든 트리를 탐색하며 부모와 자식 노드들을 stack에 넣어준다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stack.pop()</span></code>을 하면서 자연스럽게 말단 노드의 값부터 가져온다.</p></li>
<li><p>DFS()의 로직을 그대로 따라한다.</p></li>
</ul>
</div>
<div class="dropdown admonition">
<p class="admonition-title">DFS Solution</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">사람-노드, 에지-친구 </span>
<span class="sd">- SNS에 속한 사람은 얼리 어답터/얼리 어답터가 아니다. </span>
<span class="sd">- 가능한 한 최소의 수의 얼리 어답터를 확보하여 &#39;모든 사람이&#39; 이 아이디어를 받아들이게 하기 위한 &quot;최소한의&quot; 얼리 어답터의 수를 구하라.  </span>
<span class="sd">- SNS가 트리임을 가정 (graph without a cycle)</span>

<span class="sd">constraints </span>
<span class="sd">- N: 정점의 수 2 &lt;= N &lt;= 1e6 , 1-indexed </span>
<span class="sd">- 엣지수: N-1 </span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span> 
<span class="n">sys</span><span class="o">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="mi">1_000_001</span><span class="p">)</span>
<span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span> 

<span class="c1"># sys.stdin = open(&#39;Input.txt&#39;)</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
    <span class="n">graph</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">graph</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># dp[node][0] = 현재 node가 early adopter가 아닐때, 필요한 최소한의 얼리어답터 수 </span>
<span class="c1"># dp[node][1] = 현재 node가 early adopter일 때, 필요한 최소한의 얼리어답터 수 </span>
<span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> 
<span class="n">visited</span><span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> 

    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">child</span><span class="p">]:</span>
            <span class="k">continue</span> 

        <span class="n">dfs</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">child</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># subtree의 root가 얼리어답터가 아닌 경우, child nodes들이 다 얼리어답터여야함. </span>
        <span class="n">dp</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">child</span><span class="p">])</span> <span class="c1"># subtree의 root가 얼리어답터인 경우, 모든 경우의 수인 경우에서 가능하므로, 가장 작은 것을 더해주면 됨. </span>
    
<span class="n">dfs</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="c1"># print(dp)</span>
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">DFS Solution</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">사람-노드, 에지-친구 </span>
<span class="sd">- SNS에 속한 사람은 얼리 어답터/얼리 어답터가 아니다. </span>
<span class="sd">- 가능한 한 최소의 수의 얼리 어답터를 확보하여 &#39;모든 사람이&#39; 이 아이디어를 받아들이게 하기 위한 &quot;최소한의&quot; 얼리 어답터의 수를 구하라.  </span>
<span class="sd">- SNS가 트리임을 가정 (graph without a cycle)</span>

<span class="sd">constraints </span>
<span class="sd">- N: 정점의 수 2 &lt;= N &lt;= 1e6 , 1-indexed </span>
<span class="sd">- 엣지수: N-1 </span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span> 
<span class="n">sys</span><span class="o">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="mi">1_000_001</span><span class="p">)</span>
<span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span> 

<span class="c1"># sys.stdin = open(&#39;Input.txt&#39;)</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
    <span class="n">graph</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">graph</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># dp[node][0] = 현재 node가 early adopter가 아닐때, 필요한 최소한의 얼리어답터 수 </span>
<span class="c1"># dp[node][1] = 현재 node가 early adopter일 때, 필요한 최소한의 얼리어답터 수 </span>
<span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> 
<span class="n">visited</span><span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> 

    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">child</span><span class="p">]:</span>
            <span class="k">continue</span> 

        <span class="n">dfs</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">child</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># subtree의 root가 얼리어답터가 아닌 경우, child nodes들이 다 얼리어답터여야함. </span>
        <span class="n">dp</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">child</span><span class="p">])</span> <span class="c1"># subtree의 root가 얼리어답터인 경우, 모든 경우의 수인 경우에서 가능하므로, 가장 작은 것을 더해주면 됨. </span>
    
<span class="n">dfs</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="c1"># print(dp)</span>
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">BFS Solution</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span> 
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span> 

<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="n">tree</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
    <span class="n">tree</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">tree</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">solve</span><span class="p">():</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span> 
    <span class="n">que</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">start</span><span class="p">])</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="n">que</span><span class="p">:</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">que</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> 

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">[</span><span class="n">parent</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">child</span><span class="p">]:</span>
                <span class="n">que</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">])</span>
    
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">parent</span><span class="p">,</span> <span class="n">child</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">parent</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">child</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">parent</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">child</span><span class="p">])</span>

<span class="n">solve</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
</div>
</section>
<section id="diameter-of-binary-tree">
<h3>Diameter of Binary Tree<a class="headerlink" href="#diameter-of-binary-tree" title="Link to this heading">#</a></h3>
<div class="dropdown admonition">
<p class="admonition-title">Solution</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">The diameter</span>
<span class="sd">- is the length of the &quot;longest path&quot; between any two nodes in a tree </span>
<span class="sd">- the length of a path between two nodes is represented by the number of edges between them</span>
<span class="sd">- This path may or may not pass through the root</span>

<span class="sd">Idea</span>
<span class="sd">- 현재 노드의 height를 dp에 다 저장한다. </span>
<span class="sd">- 현재 노드에서 최대 diameterd의 후보는 현재 노드의 양쪽 children의 높이를 더한 것이 된다.</span>

<span class="sd">Constarints </span>
<span class="sd">- 1 &lt;= the number of nodes &lt;= 1e4 </span>
<span class="sd">- -100 &lt;= Node.val &lt;= 100 </span>


<span class="sd">-&gt; 노드의 개수는 최대 1e4인데, node.val은 최대 201개이므로, 다른 위치에 있는 노드라도 중복된 값을 가질 수 있다. </span>
<span class="sd">-&gt; 따라서, visited를 설정할 때, node.val은 unique하지 않으므로 object별로 방문해는지 확인해야한다. </span>

<span class="sd">Time Complexity:</span>
<span class="sd">- O(N): 모든 노드를 정확히 한 번 방문 </span>
<span class="sd">Space Complexity:</span>
<span class="sd">- O(H): 재귀 호출 스택, H=트리 높이, 최악의 경우 O(N)</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span> 
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span> 

<span class="c1"># dp = defaultdict(int) # INIT to 0, node height (the # of edges)</span>

<span class="c1"># Definition for a binary tree node.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Node(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s2">)&quot;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">diameterOfBinaryTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        
        <span class="n">subtree_size</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">max_diameter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">calculate_subtree_size</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">subtree_size</span><span class="p">,</span> <span class="n">max_diameter</span> 
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            
            <span class="c1"># 이거 없어도 DFS는 맨 아래서부터 위로 올라감. </span>
            <span class="c1"># if node in subtree_size: </span>
            <span class="c1">#     return subtree_size[node]</span>

            
            <span class="n">left</span> <span class="o">=</span> <span class="n">calculate_subtree_size</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">calculate_subtree_size</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            
            <span class="n">subtree_size</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> 
            <span class="c1"># node를 가운데로 했을 때의 지름 후보 left + right </span>
            <span class="n">max_diameter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_diameter</span><span class="p">,</span> <span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">subtree_size</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
        
        <span class="n">calculate_subtree_size</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="c1"># print(subtree_size)</span>
        <span class="k">return</span> <span class="n">max_diameter</span>

<span class="k">def</span><span class="w"> </span><span class="nf">build_tree</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span> 
    <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span> 

    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">q</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span> 
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span> 

    <span class="k">return</span> <span class="n">root</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">tree_to_arr</span><span class="p">(</span><span class="n">root</span><span class="p">:</span><span class="n">TreeNode</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">continue</span> 
        
        <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">result</span> <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">result</span> 

    
<span class="c1"># tree = [1,None, 2,None, None, 3,4] </span>
<span class="c1"># tree = [1, 2, 3, 4, 5] # 3 </span>
<span class="c1"># tree = [1, 2] # 1 </span>
<span class="n">tree</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span> <span class="c1"># 6</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">build_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="c1"># print(tree_to_arr(root))</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">diameterOfBinaryTree</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
</section>
<section id="binary-tree-max-path-sum">
<h3>Binary Tree Max Path Sum<a class="headerlink" href="#binary-tree-max-path-sum" title="Link to this heading">#</a></h3>
</section>
</section>
<section id="id4">
<h2>코테 기출<a class="headerlink" href="#id4" title="Link to this heading">#</a></h2>
<section id="id5">
<h3>색깔 트리<a class="headerlink" href="#id5" title="Link to this heading">#</a></h3>
</section>
</section>
<section id="string-compression-ii">
<h2>3번: String Compression II<a class="headerlink" href="#string-compression-ii" title="Link to this heading">#</a></h2>
<div class="dropdown admonition">
<p class="admonition-title">Problems</p>
<div class="highlight-md notranslate"><div class="highlight"><pre><span></span>String Compression with Removal 

Strings with long blocks of repeating characters take up much less space if stored in a compressed representation. To obtain the  compressed representation, we replace each segment of equal characters in the string with the number of characters in the segment followed by the character. 

For example, 
<span class="k">-</span><span class="w"> </span>&quot;CCCC&quot; -&gt; &quot;4C&quot; 
<span class="k">-</span><span class="w"> </span>A single character is left unchanged (e.g. &quot;B&quot; -&gt; &quot;B&quot;)
<span class="k">-</span><span class="w"> </span>&quot;BC&quot; -&gt; &quot;BC&quot; (since there are no repeats)

&lt;Example&gt;
<span class="k">-</span><span class="w"> </span>The compressed representation of &quot;ABBCCDDCCC&quot; is &quot;A3B2C2D3C&quot;.
<span class="k">-</span><span class="w"> </span>The compressed representation of &quot;AAAAAAAAAABXXAAAAAAAAAA&quot; is &quot;11AB2X10A&quot;.

&lt;Observation&gt;
In the second example above, if we removed the &quot;BXX&quot; segment from the middle of the word before compression, we would obtain a much shorter compressed representation &quot;21A&quot;. 

To take advantage of this, we modify our compression algorithm:
<span class="k">-</span><span class="w"> </span>Before compressing, we remove <span class="gs">**exactly K consecutive letters**</span> from the input string. 
<span class="k">-</span><span class="w"> </span>Then we compress the remaining stirng. 

We want to know the shortest compressed length possible after this operation. 

&lt;Task&gt;

Write a function <span class="sb">`def solution(S, K):`</span> that, given:

<span class="k">-</span><span class="w"> </span>a string S of length N,
<span class="k">-</span><span class="w"> </span>and an integer K,

return <span class="gs">**the shortest possible length of the compressed representation of S**</span> after removing exactly K consecutive characters. 

&lt;Examples&gt;

<span class="k">1.</span> S = &quot;ABBCCDDCCC&quot;, K = 3
<span class="w">    </span><span class="k">-</span><span class="w"> </span>Remove &quot;DDC&quot; → string becomes &quot;ABBCCCC&quot;.
<span class="w">    </span><span class="k">-</span><span class="w"> </span>Compressed form = &quot;A3B4C&quot;, length = 5.
<span class="w">    </span><span class="k">-</span><span class="w"> </span>Function should return 5.

<span class="k">2.</span> S = &quot;AAAAAAAAAABXXAAAAAAAAAA&quot;, K = 3
<span class="w">    </span><span class="k">-</span><span class="w"> </span>Remove &quot;BXX&quot; → string becomes &quot;AAAAAAAAAAAAAAAAAAAAAA&quot;.
<span class="w">    </span><span class="k">-</span><span class="w"> </span>Compressed form = &quot;21A&quot;, length = 3.
<span class="w">    </span><span class="k">-</span><span class="w"> </span>Function should return 3.

<span class="k">3.</span> S = &quot;ABCDDDDEFG&quot;, K = 2
<span class="w">    </span><span class="k">-</span><span class="w"> </span>Remove &quot;EF&quot; → string becomes &quot;ABCDDDDG&quot;.
<span class="w">    </span><span class="k">-</span><span class="w"> </span>Compressed form = &quot;ABC3DG&quot;, length = 6.
<span class="w">    </span><span class="k">-</span><span class="w"> </span>Function should return 6.

&lt;Constraints&gt;
<span class="k">-</span><span class="w"> </span>N is an integer within the range [1 .. 100,000]
<span class="k">-</span><span class="w"> </span>K is an integer within the range [0 .. 100,000]
<span class="k">-</span><span class="w"> </span>K &lt;= N
<span class="k">-</span><span class="w"> </span>S consists only of uppercase English letters (A-Z)
</pre></div>
</div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./_pages/practice"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="3_backtrackingPS.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">이전</p>
        <p class="prev-next-title">Lecture 3-2. Backtracking 실습</p>
      </div>
    </a>
    <a class="right-next"
       href="5_shortest_pathPS.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">다음</p>
        <p class="prev-next-title">Lecture 5-2. Shortest Path &amp; Heap</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> 내용
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#treedp">TreeDP</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">서브트리의 정점 개수 세기</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">우수 마을</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">사회망 서비스</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diameter-of-binary-tree">Diameter of Binary Tree</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#binary-tree-max-path-sum">Binary Tree Max Path Sum</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">코테 기출</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">색깔 트리</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#string-compression-ii">3번: String Compression II</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
으로 Daye Lee
</p>

  </div>
  
  <div class="footer-item">
    

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>