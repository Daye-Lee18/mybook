
<!DOCTYPE html>


<html lang="ko" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Lecture 1-2. 구현 실습 &#8212; 말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css?v=6644e6bb" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=9c59b310" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=ae323b5b"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="../../_static/translations.js?v=e33e7ba0"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_pages/practice/1_implementationPS';</script>
    <script src="https://unpkg.com/jupyterquiz@1.1.8/dist/jupyterquiz.min.js"></script>
    <link rel="icon" href="../../_static/favicon.png"/>
    <link rel="index" title="색인" href="../../genindex.html" />
    <link rel="search" title="검색" href="../../search.html" />
    <link rel="next" title="Lecture 2-2. DFS/BFS 실습" href="2_DFS_BFSPS.html" />
    <link rel="prev" title="Lecture 3-1. Backtracking" href="../theory/3_backtracking.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="ko"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/mylogo.png" class="logo__image only-light" alt="말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업 - Home"/>
    <script>document.write(`<img src="../../_static/mylogo.png" class="logo__image only-dark" alt="말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업 - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="검색" aria-label="검색" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">검색</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Welcome to 말레이시아 5급 IT 수업
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">이론</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../theory/0_tips.html">문제 풀이 순서 팁 (Tips)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/1_implementation.html">Lecture 1-1. 구현</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/2_DFS_BFS.html">Lecture 2-1. DFS/BFS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/3_backtracking.html">Lecture 3-1. Backtracking</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">실습</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Lecture 1-2. 구현 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_DFS_BFSPS.html">Lecture 2-2. DFS/BFS 실습</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="이 페이지 다운로드">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/_pages/practice/1_implementationPS.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="소스 파일 다운로드"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="PDF로 인쇄"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="전체 화면으로보기"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="검색" aria-label="검색" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Lecture 1-2. 구현 실습</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> 내용 </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">1번: 마법의 숲 탐색 문제 풀이</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">3번: 미생물 연구</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="lecture-1-2">
<h1>Lecture 1-2. 구현 실습<a class="headerlink" href="#lecture-1-2" title="Link to this heading">#</a></h1>
<p>예시 문제 링크</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/magical-forest-exploration/description">1번: 코드트리 마법의 숲 탐색</a></p></li>
<li><p><a class="reference external" href="https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/cleaning-is-joyful/description">2번: 코드트리 청소는 즐거워</a></p></li>
<li><p><a class="reference external" href="https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/microbial-research/description">3번: 코드트리 미생물 연구</a></p></li>
<li><p><a class="reference external" href="https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/mint-choco-milk/description">4번: 코드트리 민트초코 우유</a></p></li>
<li><p><a class="reference external" href="https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/medusa-and-warriors/description">5번: 코드트리 메두사와 전사들</a></p></li>
</ul>
<section id="id1">
<h2>1번: 마법의 숲 탐색 문제 풀이<a class="headerlink" href="#id1" title="Link to this heading">#</a></h2>
<div class="dropdown admonition">
<p class="admonition-title">문제 정리</p>
<ol class="arabic">
<li><p>격좌/좌표: RxC를 HXC로 변환 (O, R-1) -&gt; (0, H-1)까지</p></li>
<li><p>move_golem(): 아래로 최대한 내려갈 수 있는 (move as far south as possible) 함수 구현</p>
<ol class="arabic simple">
<li><p>Step 2-1: rolling downward -&gt; collision check 3 cells</p></li>
<li><p>Step 2-2: rotating left while moving downward -&gt; collision check 5 cells</p></li>
<li><p>Step 2-3: rotating right while moving downward -&gt; collision check 5 cells</p></li>
</ol>
</li>
<li><p>settle_or_reset():</p>
<ol class="arabic simple">
<li><p>정착 실패: 골렘이 멈췄을 때 십자 5칸 중 한 칸이라도 숲 밖(상단 패딩 포함 관점)이라면, 지금까지 놓인 모든 골렘을 전부 지우고 이번 시도는 0점 처리 후 다음 시도로 넘어간다.</p></li>
<li><p>정착 성공 시 배치: 정지 위치에 중심+팔 4칸을 기록하고, 출구 방향도 함께 저장한다(다음 단계 탐색에 필요).</p></li>
</ol>
</li>
<li><p>spirits 탐색 (explore)</p>
<ol class="arabic simple">
<li><p>골렘의 출구와 가까운 골렘을 통해 seed max값을 초기화 -&gt; 8가지 가능한 방향으로 같은 component의 값들에 큰 값 -&gt; 작은 값으로 value propagation(BFS사용)</p></li>
<li><p>관련하여 <a class="reference external" href="https://colab.research.google.com/github/Daye-Lee18/mybook/blob/main/assets/ipynb/propagation_demo.ipynb"><img alt="Open In Colab" src="https://colab.research.google.com/assets/colab-badge.svg" /></a> 시드의 최대값 초기화가 중요한 이유 확인</p></li>
</ol>
</li>
<li><p>solve(): 위의 함수들을 사용하여, input을 받고 결과 출력하는 함수</p>
<ol class="arabic simple">
<li><p>격자/좌표:</p></li>
</ol>
<ul class="simple">
<li><p>숲은 R×C 격자. 문제 기준으로 가장 위가 1행, 가장 아래가 R행(좌표는 1-based). 정령(골렘)은 북쪽(격자 위쪽) 바깥에서 진입한다.</p>
<ul>
<li><p>(구현 팁) 진입·회전 동작을 편하게 처리하려고 상단에 3행을 더 붙인 격자(R+3×C) 로 두고 시뮬레이션하는 전형적인 방식이 많이 쓰인다.</p></li>
</ul>
</li>
<li><p>입력 &amp; 골렘 정의 (총 K번)</p>
<ul>
<li><p>한 번의 시도마다 열 c(1…C), 출구 방향 d(0:북, 1:동, 2:남, 3:서) 가 주어진다. 골렘은 십자(+) 모양(중심+상하좌우) 으로 5칸을 차지하며, 출구는 중심에서 d 방향으로 인접한 1칸이다.</p></li>
</ul>
</li>
</ul>
</li>
</ol>
</div>
<div class="dropdown admonition">
<p class="admonition-title">graph의 확장</p>
<p><img alt="3-1" src="../../_images/1.png" /></p>
<p>In the beginning, the golem may extend up to <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">cells</span></code> above the forest. To handle this, we add 3 buffer rows at the top of the grid. These buffer rows are not part of the forest but provide enough room for the golem to move and settle safely.</p>
</div>
<div class="dropdown admonition">
<p class="admonition-title">각 step 구현</p>
<p>When the golem moves one step down, we must check 3 positions below the center: directly underneath, and one cell to the left and right. If all 3 are empty, the golem can move downward without collision.
<img alt="3-2" src="../../_images/2.png" /></p>
<p>Now let’s look at rotation to the left. For the golem to rotate, <code class="docutils literal notranslate"><span class="pre">five</span> <span class="pre">specific</span> <span class="pre">cells</span></code> must be empty. Interestingly, the rules allow rotation even if the upper-right or lower-right cells are occupied. We number the directions North, East, South, and West as 0, 1, 2, and 3. Using this, left rotation is simply (d + 3) mod 4, and right rotation is (d + 1) mod 4.</p>
<p><img alt="3-3" src="../../_images/3.png" /></p>
<p>Rotation to the right works symmetrically. Again, five surrounding cells must be empty to allow the move. The concept is the same as left rotation, but we apply the clockwise formula.
<img alt="3-4" src="../../_images/4.png" /></p>
<p>When the golem finally stops, all four arms must be inside the forest area, which is from row 3 down to H–1. To manage state, we store each golem’s position and exit direction in units[gid]. We also record which exit belongs to which golem in exit_map. This way, exit_map tells us the gid, and units gives us the exact center and direction.
<img alt="3-5" src="../../_images/5.png" /></p>
</div>
<div class="dropdown admonition">
<p class="admonition-title">정보 저장</p>
<p>We maintain two separate grids: <code class="docutils literal notranslate"><span class="pre">golem_arr</span></code> and <code class="docutils literal notranslate"><span class="pre">exit_map</span></code>. The <code class="docutils literal notranslate"><span class="pre">golem</span> <span class="pre">array</span></code> records body occupancy and is used for <code class="docutils literal notranslate"><span class="pre">collision</span> <span class="pre">checks</span></code>. The <code class="docutils literal notranslate"><span class="pre">exit</span> <span class="pre">map</span></code> records <code class="docutils literal notranslate"><span class="pre">only</span> <span class="pre">exits</span></code>, which lets us trace connectivity between golems using <code class="docutils literal notranslate"><span class="pre">BFS</span></code>. This separation is crucial because body cells and exit cells need to be treated differently.</p>
<p><img alt="3-6" src="../../_images/6.png" /></p>
</div>
<div class="dropdown admonition">
<p class="admonition-title">최댓값 전파</p>
<p><img alt="3-7" src="../../_images/7.png" /></p>
<p>Finally, let’s look at how we propagate the maximum reachable row.</p>
<ul class="simple">
<li><p>Step one: if <code class="docutils literal notranslate"><span class="pre">the</span> <span class="pre">current</span> <span class="pre">golem’s</span> <span class="pre">exit</span></code> touches a neighbor’s body, we inherit its <code class="docutils literal notranslate"><span class="pre">max_row</span></code> as the <code class="docutils literal notranslate"><span class="pre">seed</span></code> value.</p></li>
<li><p>Step two: using BFS, we spread values along exit-to-exit connections across the whole component.</p></li>
</ul>
<p>This two-step design ensures accuracy — newly placed golems immediately get the correct value. It also improves efficiency, since we avoid repeated updates by maximizing early and propagating just once.</p>
<p><img alt="3-8" src="../../_images/8.png" /></p>
<ol class="arabic simple">
<li><p>best 계산 단계 (시드 확정)</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">start_id</span></code> 의 출구 주변을 보면서, 이미 숲에 있던 이웃 골렘들이 가지고 있던 <code class="docutils literal notranslate"><span class="pre">max_row</span></code>값 참고</p></li>
<li><p>방금 들어온 골렘이 가질 수 있는 가장 큰 시작값 (best)를 정함.</p></li>
</ol>
</li>
<li><p>전파 단계 (BFS)</p>
<ol class="arabic simple">
<li><p>이제 <code class="docutils literal notranslate"><span class="pre">start_id</span></code>가 속한 component전체에 대해, max_row가 작은 이웃 노드들을 best 값으로 끌어올림.</p></li>
<li><p>이 과정을 통해 같은 컴포넌트 안의 모든 골렘이 최대값을 공유</p></li>
<li><p>이렇게 해 두면, 나중에 컴포넌트 안에서 어느 골렘을 시작점으로 잡아도 같은 답을 얻을 수 있습니다.</p></li>
<li><p>다음 골렘을 위해 준비 완료</p></li>
</ol>
</li>
</ol>
</div>
<div class="toggle docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>

<span class="c1"># 0=북, 1= 동, 2=남, 3=서</span>
<span class="n">DY</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">DX</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># 아래 직하/좌하/우하 이동시, 비어있어야하는 상대 좌표 집합</span>
<span class="c1"># 중심 기준 상대 좌표들이 모두 비어있어야 해당 ㅣㅇ동 가능</span>
<span class="c1"># 아래로: 중심 아래 2칸, 좌/우 아래 1칸</span>
<span class="n">TY</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span> <span class="n">TX</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="c1"># 좌하: 왼쪽으로 틀며 내려갈 때 필요한 빈칸 (모서리 간섭 방지)</span>
<span class="n">LY</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span> <span class="n">LX</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="c1"># 우하 : 오른쪽으로 틀며 내려갈 때 필요한 빈칸 (모서리 간섭 방지)</span>
<span class="n">RY</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span> <span class="n">RX</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

<span class="c1"># 출구 접속을 전파할 때, 한 골렘 중심 추변에서 &quot;출구 셀&quot;을 탐색할 8방 이웃</span>
<span class="n">EY</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">EX</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

<span class="n">R</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">R</span> <span class="o">+</span> <span class="mi">3</span> <span class="c1"># 시뮬은 R위에 3행 더해서 (R+3)xC보드 사용</span>

<span class="c1"># arr: 골렘 몸 (심자 5칸)의 골렘 ID 기록 (0=빈칸)</span>
<span class="c1"># exit_map = 출구 칸에 골렘 id 기록 (0=없음)</span>
<span class="n">arr</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">C</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">H</span><span class="p">)]</span>
<span class="n">exit_map</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">C</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">H</span><span class="p">)]</span> <span class="c1"># 해당 출구가 &quot;어느 골렘(Gid)의 출구인지 알아야함.&quot;</span>

<span class="c1"># 각 골렘 정보와 결과 합</span>
<span class="n">units</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># units[id] = (y, x,dir) 저장용으로 &quot;각 골렘의 중심 좌표와 출구 방향&quot;을 O(1)로 꺼내기 위한 인덱스 테이블 (최적화 탐색)</span>
<span class="n">max_row</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 각 골렘 컴포넌트의 &quot;도달 가능한 최대 행&quot; (원래 숲 기준 0 ~ R-1)</span>
<span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">in_range</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;골렘이 움직일 수 있는 구간&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="o">&lt;=</span> <span class="n">y</span><span class="o">&lt;</span> <span class="n">H</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span><span class="n">C</span>

<span class="k">def</span><span class="w"> </span><span class="nf">in_forest</span><span class="p">(</span><span class="n">y</span> <span class="p">,</span><span class="n">x</span><span class="p">):</span>
    <span class="c1"># 원래 숲 범위: 행 3...H-1 (R+2)</span>
    <span class="k">return</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">H</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span><span class="n">C</span>

<span class="k">def</span><span class="w"> </span><span class="nf">can_move</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">yofs</span><span class="p">,</span> <span class="n">xofs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    직하, 좌하, 우하 중 골렘이 갈 수 있음을 확인</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">yofs</span><span class="p">,</span> <span class="n">xofs</span><span class="p">):</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_range</span><span class="p">(</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span> <span class="ow">or</span> <span class="n">arr</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="kc">True</span>

<span class="k">def</span><span class="w"> </span><span class="nf">drop_and_settle</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="c1"># x, y,d에서 아래/좌하/우하를 우선순위대로 반복 시도</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">can_move</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">TY</span><span class="p">,</span> <span class="n">TX</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># 아래</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">can_move</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">LY</span><span class="p">,</span> <span class="n">LX</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span> <span class="c1"># 좌하: 출구 좌회전</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">x</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">can_move</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">RY</span><span class="p">,</span> <span class="n">RX</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span> <span class="c1"># 우하: 출구 우회전</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">continue</span>
        <span class="k">break</span>
    <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">d</span>

<span class="k">def</span><span class="w"> </span><span class="nf">place_or_reset</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="c1"># 십자 네 팔이 원래 숲 범위를 벗어나면 전체 초기화 후 False return</span>
    <span class="k">for</span> <span class="n">dir4</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="c1"># arm_y, arm_x</span>
        <span class="n">ay</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">DY</span><span class="p">[</span><span class="n">dir4</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">DX</span><span class="p">[</span><span class="n">dir4</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_forest</span><span class="p">(</span><span class="n">ay</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
            <span class="c1"># 전체 리셋</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">H</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
                    <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">exit_map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># 십자 네 팔이 원래 숲 범위 안에 있는 경우 True return</span>
    <span class="c1"># 출구 표시</span>
    <span class="n">ey</span><span class="p">,</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">DY</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">DX</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
    <span class="n">exit_map</span><span class="p">[</span><span class="n">ey</span><span class="p">][</span><span class="n">ex</span><span class="p">]</span> <span class="o">=</span> <span class="n">id_</span>

    <span class="c1"># 몸통 (십자) 표시</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">id_</span>
    <span class="k">for</span> <span class="n">dir4</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">ay</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">DY</span><span class="p">[</span><span class="n">dir4</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">DX</span><span class="p">[</span><span class="n">dir4</span><span class="p">]</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">ay</span><span class="p">][</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">id_</span>

    <span class="n">units</span><span class="p">[</span><span class="n">id_</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">True</span>

<span class="k">def</span><span class="w"> </span><span class="nf">compute_component_maxrow</span><span class="p">(</span><span class="n">start_id</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    현재 골렘 기준으로 최대행 계산 및 출구-접속 가능한 골렘들에 대해</span>
<span class="sd">    도달 가능한 최대 행 (원래 숲 좌표계) 값을 전파 (BFS)하며 갱신</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 기본: 중심의 &#39;숲 내&#39; 행 인덱스 = x-3</span>
    <span class="n">sy</span><span class="p">,</span> <span class="n">sx</span><span class="p">,</span> <span class="n">sd</span> <span class="o">=</span> <span class="n">units</span><span class="p">[</span><span class="n">start_id</span><span class="p">]</span>
    <span class="c1"># max_row: “사람이 실제로 밟을 수 있는 빈 칸 중 가장 아래(=가장 큰 y)”를 저장</span>
    <span class="c1"># base = sy - 1 # 골렘의 중심 기준으로 도달 가능한 최대 행을 저장</span>


    <span class="c1"># 먼저, 현재 골렘의 출구 주변 4방에 인접한 &#39;몸&#39;이 있으면 그 골렘으로부터 더 큰 최대값을 물려받음</span>
    <span class="n">best</span> <span class="o">=</span> <span class="n">sy</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># 중심 칸은 본인이 점유해서 사람이 설 수 없기 때문. 가장 아래쪽의 빈 칸이 중심 바로 위(sy-1)이므로, 거기서부터 최대행을 잡아 전파(BFS)합니다.</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    이후 출구 접속으로 다른 골렘과 이어지면, 이 base와 이웃 골렘들의 max_row를 비교해가며 더 큰 값으로 갱신하죠.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 출구 </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    1단계: 초기 시드값 설정 </span>
<span class="sd">    여기서는 현재 골렘의 출구 칸(ey,ex) 주변 4방(상하좌우) 에 다른 골렘의 몸(arr&gt;0) 이 닿아 있으면, 그 이웃 골렘이 이미 가지고 있던 max_row[nid]를 초기값(best) 로 상속받습니다.</span>
<span class="sd">    이유: 막 방금 놓인 골렘이 이미 배치되어 있던 컴포넌트와 바로 출구-몸 접촉으로 연결되면, 그 컴포넌트의 “가장 아래까지 갈 수 있는 값”을 즉시 물려받아야 해요. 이걸 하지 않으면, 큐를 돌리면서 여러 번의 라운드를 거쳐야 반영되거나, 더 복잡한 재방문 로직이 필요해집니다.</span>
<span class="sd">    즉, 이 단계는 현재 골렘의 시작값을 최대한 크게 만들어서 이후 전파를 한 번에 끝내려는 “초기화(시드) 단계”예요.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ey</span><span class="p">,</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">sy</span> <span class="o">+</span> <span class="n">DY</span><span class="p">[</span><span class="n">sd</span><span class="p">],</span> <span class="n">sx</span> <span class="o">+</span> <span class="n">DX</span><span class="p">[</span><span class="n">sd</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">ey</span> <span class="o">+</span> <span class="n">DY</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">ex</span> <span class="o">+</span> <span class="n">DX</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">in_range</span><span class="p">(</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">start_id</span><span class="p">:</span>
            <span class="n">nid</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span>
            <span class="n">best</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">best</span><span class="p">,</span> <span class="n">max_row</span><span class="p">[</span><span class="n">nid</span><span class="p">])</span>

    <span class="c1"># 시작 골렘의 현재 best 기록</span>
    <span class="k">if</span> <span class="n">best</span> <span class="o">&gt;</span> <span class="n">max_row</span><span class="p">[</span><span class="n">start_id</span><span class="p">]:</span>
        <span class="n">max_row</span><span class="p">[</span><span class="n">start_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">best</span>

    <span class="c1"># 이제 출구가 &#39;맞닿아 있는&#39; 골렘들로 최대 행을 전파 (출구 맵 기준 8방)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">start_id</span><span class="p">])</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="p">{</span><span class="n">start_id</span><span class="p">}</span> <span class="c1"># set</span>
    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">gid</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="n">gy</span><span class="p">,</span> <span class="n">gx</span><span class="p">,</span> <span class="n">gd</span> <span class="o">=</span> <span class="n">units</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span>

        <span class="c1"># 중심 8방의 출구 칸들을 보며, 출구가 있는 다른 골렘을 찾는다.</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
             <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">gy</span> <span class="o">+</span> <span class="n">EY</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">gx</span> <span class="o">+</span> <span class="n">EX</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
             <span class="k">if</span> <span class="n">in_range</span><span class="p">(</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span> <span class="ow">and</span> <span class="n">exit_map</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                 <span class="c1"># next id</span>
                 <span class="n">nid</span> <span class="o">=</span> <span class="n">exit_map</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span>
                 <span class="k">if</span> <span class="n">nid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                     <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>
                     <span class="c1"># 더 큰 최대행을 전파</span>
                     <span class="k">if</span> <span class="n">max_row</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_row</span><span class="p">[</span><span class="n">nid</span><span class="p">]:</span>
                        <span class="n">max_row</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_row</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span>
<span class="w">                        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                        이 BFS전파는 큰 값 -&gt; 작은 값의 전파 규칙으로 설정됨. </span>
<span class="sd">                        초기: A=5, B=10, edge: A—B</span>
<span class="sd">                        큐 시작: A</span>

<span class="sd">                        A(5) 방문 → B(10)은 더 크다 → 전파 안 함</span>
<span class="sd">                        큐: [B]  # B는 이미 seen 처리됨</span>

<span class="sd">                        B(10) 방문 → A(5)보다 크다 → A=10으로 업데이트</span>
<span class="sd">                        &#39;&#39;&#39;</span>
                     <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">solve</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">answer</span>
    <span class="k">for</span> <span class="n">gid</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
        <span class="c1"># 시작 지점: (1, c-1)에서 낙하 시작 (보드 상단 여유행 고려)</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dir_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dir_</span> <span class="o">=</span> <span class="n">drop_and_settle</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dir_</span><span class="p">)</span>

        <span class="c1"># 놓을 수 없으면 전체 보드 초기화되고, 이 골렘은 스킵</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">place_or_reset</span><span class="p">(</span><span class="n">gid</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dir_</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="c1"># 이 골렘 기준으로 최대행 계산 및 출구 접속 전파</span>
        <span class="n">compute_component_maxrow</span><span class="p">(</span><span class="n">gid</span><span class="p">)</span>
        <span class="n">answer</span> <span class="o">+=</span> <span class="n">max_row</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">answer</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
</div>
</section>
<section id="id2">
<h2>3번: 미생물 연구<a class="headerlink" href="#id2" title="Link to this heading">#</a></h2>
<div class="dropdown admonition">
<p class="admonition-title">문제 정리</p>
<ol class="arabic simple" start="0">
<li><p>preliminaries: 좌상단이 시작점인지, 좌하단이 시작점인지 좌표 변환 <a class="reference external" href="https://colab.research.google.com/github/Daye-Lee18/mybook/blob/main/assets/ipynb/grid_coords_rotations_cheatsheet.ipynb"><img alt="Open In Colab" src="https://colab.research.google.com/assets/colab-badge.svg" /></a></p></li>
<li><p>NxN 정사각형 배양 용기, 좌측 하단 (0,0), 우측 상단 (N, N)</p></li>
<li><p>총 Q번 실험동안, 실험 결과 기록</p>
<ul class="simple">
<li><p>2-1. insert_and_get_result() 미생물 투입 후, 배양</p>
<ul>
<li><p>(r1, c1) ~ (r2, c2) 직사각형 미생물 투입, 영역내에는 새로 투입된 미생물만 남음.</p></li>
<li><p>기존에 있던 미생물이 먹힌 경우, 영역이 두 개 이상으로 나뉘면 기존 미생물은 모두 사라짐.  -&gt; 항상 미생물은 하나의 그룹으로만 이루어지게 만듦.</p></li>
</ul>
</li>
<li><p>2-2. 배양 용기 이동: move_microbe()</p>
<ul>
<li><p>기존 용기와 동일한 새로운 배양 용기로 이동. 기존 배양 용기에 미생물이 한 마디도 남지 않을 때까지</p>
<ul>
<li><p>가장 차지한 영역 ((r1, c1) ~ (r2, c2))이 넓은 무리 하나 선택 -&gt; 2개 이상이면 먼저 투입된 미생물 선택 (용기에는 미생물을 넣은 시간 정보 필요 -&gt; idx가 작은 것 선택)</p></li>
<li><p>선택된 미생물의 영역 ((r1, c1) ~ (r2, c2))은</p>
<ul>
<li><p>배양 용기의 범위를 벗어나지 않으며</p></li>
<li><p>다른 미생물의 영역과 겹치지 않아야하고,</p></li>
<li><p>위의 조건에서 최대한 x좌표가 작은 위치로 미생물을 옮기는데,</p>
<ul>
<li><p>그 위치가 2개 이상이면 최대한 y좌표가 작은 위치로 오도록 옮김</p></li>
</ul>
</li>
<li><p>위의 조건이 없다면, 옮기지 못하고 사라짐</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2-3. record()</p>
<ul>
<li><p>미생물 무리 중 상하좌우로 닿아있는 인접한 무리 확인</p></li>
<li><p>맞닿은 면이 둘 이상이더라도 micro_id같으면 한 번만 확인</p></li>
<li><p>인접한 무리가 있으면</p>
<ul>
<li><p>확인하는 두 무리가 A,B라면 (미생물 A영역의 넓이) x (미생물 B영역의 넓이) 성과</p></li>
<li><p>확인한 모든 쌍의 성과 기록</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</div>
<div class="toggle docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span><span class="p">,</span> <span class="n">defaultdict</span>

<span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span>

<span class="c1"># 방향: 상하좌우 (행, 열)</span>
<span class="n">DR</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">DC</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">in_range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">n</span>

<span class="k">def</span><span class="w"> </span><span class="nf">bfs_component</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;grid[sr][sc]의 id로 연결된 컴포넌트 크기와</span>
<span class="sd">       인접한 다른 id 집합을 반환&quot;&quot;&quot;</span>
    <span class="n">idv</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">sr</span><span class="p">][</span><span class="n">sc</span><span class="p">]</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">)])</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">sr</span><span class="p">][</span><span class="n">sc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">DR</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">c</span> <span class="o">+</span> <span class="n">DC</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">in_range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">nid</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">nr</span><span class="p">][</span><span class="n">nc</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">nid</span> <span class="o">==</span> <span class="n">idv</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">nr</span><span class="p">][</span><span class="n">nc</span><span class="p">]:</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">nr</span><span class="p">][</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span>
                <span class="n">size</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">nid</span> <span class="o">!=</span> <span class="n">idv</span><span class="p">:</span>
                <span class="n">adj</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>  <span class="c1"># 0 포함해도 뒤에서 걸러냄</span>
    <span class="k">return</span> <span class="n">idv</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">adj</span>

<span class="k">def</span><span class="w"> </span><span class="nf">get_all_shapes</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;현재 용기의 모든 무리(id&gt;0)에 대해</span>
<span class="sd">       각 id의 셀 좌표 리스트와 면적을 구한다.&quot;&quot;&quot;</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">False</span><span class="p">]</span><span class="o">*</span><span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">id_to_cells</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">id_to_size</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
                <span class="n">idv</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bfs_component</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
                <span class="c1"># 다시 한 번 같은 컴포넌트를 순회해 좌표들 수집</span>
                <span class="c1"># (방금 BFS에서 좌표를 저장해도 되지만, 범위가 작아 재탐색해도 충분)</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)])</span>
                <span class="n">visited2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)])</span>
                <span class="n">id_to_cells</span><span class="p">[</span><span class="n">idv</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
                <span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
                    <span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                        <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">rr</span> <span class="o">+</span> <span class="n">DR</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">cc</span> <span class="o">+</span> <span class="n">DC</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">in_range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited2</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">nr</span><span class="p">][</span><span class="n">nc</span><span class="p">]</span> <span class="o">==</span> <span class="n">idv</span><span class="p">:</span>
                            <span class="n">visited2</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span>
                            <span class="n">id_to_cells</span><span class="p">[</span><span class="n">idv</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span>
                            <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span>
                            <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">id_to_size</span><span class="p">[</span><span class="n">idv</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span>  <span class="c1"># size와 동일</span>
    <span class="k">return</span> <span class="n">id_to_cells</span><span class="p">,</span> <span class="n">id_to_size</span>

<span class="k">def</span><span class="w"> </span><span class="nf">normalize_shape</span><span class="p">(</span><span class="n">cells</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;셀 좌표들을 (최소 r, 최소 c)을 (0,0)으로 옮긴 정규화 모양과</span>
<span class="sd">       모양의 최대 r, 최대 c(경계)를 반환&quot;&quot;&quot;</span>
    <span class="n">min_r</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">)</span>
    <span class="n">min_c</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">[(</span><span class="n">r</span> <span class="o">-</span> <span class="n">min_r</span><span class="p">,</span> <span class="n">c</span> <span class="o">-</span> <span class="n">min_c</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">]</span>
    <span class="n">max_r</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">)</span>
    <span class="n">max_c</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">shape</span><span class="p">,</span> <span class="n">max_r</span><span class="p">,</span> <span class="n">max_c</span>

<span class="k">def</span><span class="w"> </span><span class="nf">can_place</span><span class="p">(</span><span class="n">new_grid</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">base_r</span><span class="p">,</span> <span class="n">base_c</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">dr</span><span class="p">,</span> <span class="n">dc</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">base_r</span> <span class="o">+</span> <span class="n">dr</span><span class="p">,</span> <span class="n">base_c</span> <span class="o">+</span> <span class="n">dc</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">or</span> <span class="n">new_grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>

<span class="k">def</span><span class="w"> </span><span class="nf">place</span><span class="p">(</span><span class="n">new_grid</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">base_r</span><span class="p">,</span> <span class="n">base_c</span><span class="p">,</span> <span class="n">idv</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">dr</span><span class="p">,</span> <span class="n">dc</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
        <span class="n">new_grid</span><span class="p">[</span><span class="n">base_r</span> <span class="o">+</span> <span class="n">dr</span><span class="p">][</span><span class="n">base_c</span> <span class="o">+</span> <span class="n">dc</span><span class="p">]</span> <span class="o">=</span> <span class="n">idv</span>

<span class="k">def</span><span class="w"> </span><span class="nf">insert_and_split</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">rect_r1</span><span class="p">,</span> <span class="n">rect_c1</span><span class="p">,</span> <span class="n">rect_r2</span><span class="p">,</span> <span class="n">rect_c2</span><span class="p">,</span> <span class="n">new_id</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;직사각형을 new_id로 덮어쓰고,</span>
<span class="sd">       그로 인해 분리된 기존 무리는 소멸시킨다.&quot;&quot;&quot;</span>
    <span class="n">affected</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="c1"># 기존 덮어쓰기(잡아먹힘)</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rect_r1</span><span class="p">,</span> <span class="n">rect_r2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rect_c1</span><span class="p">,</span> <span class="n">rect_c2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">affected</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">])</span>
            <span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_id</span>

    <span class="c1"># 분리 여부 확인: 각 affected id에 대해 연결 성분 개수 count</span>
    <span class="c1"># 연결 성분이 2개 이상이면 해당 id 전부 소멸(0으로)</span>
    <span class="k">if</span> <span class="n">affected</span><span class="p">:</span>
        <span class="c1"># 현재 grid에서 해당 id의 컴포넌트 수 세기</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">False</span><span class="p">]</span><span class="o">*</span><span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">comp_cnt</span> <span class="o">=</span> <span class="p">{</span><span class="n">aid</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">aid</span> <span class="ow">in</span> <span class="n">affected</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="ow">in</span> <span class="n">affected</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
                    <span class="n">idv</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bfs_component</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">idv</span> <span class="ow">in</span> <span class="n">comp_cnt</span><span class="p">:</span>
                        <span class="n">comp_cnt</span><span class="p">[</span><span class="n">idv</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># 소멸 처리</span>
        <span class="n">to_erase</span> <span class="o">=</span> <span class="p">{</span><span class="n">aid</span> <span class="k">for</span> <span class="n">aid</span><span class="p">,</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="n">comp_cnt</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">cnt</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">to_erase</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_erase</span><span class="p">:</span>
                        <span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">move_all</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;규칙에 따라 새 배양 용기로 이동한 뒤의 격자를 반환&quot;&quot;&quot;</span>
    <span class="n">id_to_cells</span><span class="p">,</span> <span class="n">id_to_size</span> <span class="o">=</span> <span class="n">get_all_shapes</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="c1"># 이동 순서: (면적 내림차순, id 오름차순)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">id_to_size</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="n">new_grid</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">idv</span><span class="p">,</span> <span class="n">_sz</span> <span class="ow">in</span> <span class="n">order</span><span class="p">:</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">id_to_cells</span><span class="p">[</span><span class="n">idv</span><span class="p">]</span>
        <span class="n">shape</span><span class="p">,</span> <span class="n">max_r</span><span class="p">,</span> <span class="n">max_c</span> <span class="o">=</span> <span class="n">normalize_shape</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>
        <span class="n">placed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># x(열) 최소 → y(행) 최소 (즉, c를 먼저, r을 나중에 증가)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">max_c</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">placed</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">max_r</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">can_place</span><span class="p">(</span><span class="n">new_grid</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
                    <span class="n">place</span><span class="p">(</span><span class="n">new_grid</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">idv</span><span class="p">)</span>
                    <span class="n">placed</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
        <span class="c1"># 못 놓으면 소멸(=그냥 스킵)</span>
    <span class="k">return</span> <span class="n">new_grid</span>

<span class="k">def</span><span class="w"> </span><span class="nf">score</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;최종 배치에서 인접한 서로 다른 무리 쌍의 면적 곱 합산&quot;&quot;&quot;</span>
    <span class="c1"># 모든 id의 면적 계산</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">area</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># 인접 쌍(우/하만 보면 중복 제거 가능)</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># 오른쪽</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">!=</span> <span class="n">a</span><span class="p">:</span>
                    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="k">else</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                    <span class="n">pairs</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="c1"># 아래</span>
            <span class="k">if</span> <span class="n">r</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">!=</span> <span class="n">a</span><span class="p">:</span>
                    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="k">else</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                    <span class="n">pairs</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">area</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">total</span>

<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">():</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">N</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="c1"># 실험은 id = 1..Q</span>
    <span class="k">for</span> <span class="n">new_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Q</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">r1</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
        <span class="c1"># 1) 투입 + 분리 소멸 처리</span>
        <span class="n">insert_and_split</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">new_id</span><span class="p">)</span>
        <span class="c1"># 2) 이동</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">move_all</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
        <span class="c1"># 3) 결과 출력</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">score</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">grid</span><span class="p">))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./_pages/practice"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="../theory/3_backtracking.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">이전</p>
        <p class="prev-next-title">Lecture 3-1. Backtracking</p>
      </div>
    </a>
    <a class="right-next"
       href="2_DFS_BFSPS.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">다음</p>
        <p class="prev-next-title">Lecture 2-2. DFS/BFS 실습</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> 내용
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">1번: 마법의 숲 탐색 문제 풀이</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">3번: 미생물 연구</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
으로 Daye Lee
</p>

  </div>
  
  <div class="footer-item">
    

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>