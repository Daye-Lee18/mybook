
<!DOCTYPE html>


<html lang="ko" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Lecture 5-2. Shortest Path &amp; Heap &#8212; 말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css?v=6644e6bb" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/proof.css?v=b4b7a797" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=8127ecf8" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=ae323b5b"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="../../_static/translations.js?v=e33e7ba0"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_pages/practice/5_shortest_pathPS';</script>
    <script src="https://unpkg.com/jupyterquiz@1.1.8/dist/jupyterquiz.min.js"></script>
    <link rel="icon" href="../../_static/favicon.png"/>
    <link rel="index" title="색인" href="../../genindex.html" />
    <link rel="search" title="검색" href="../../search.html" />
    <link rel="next" title="Lecture 11-2. Linked List" href="11_linked_listPS.html" />
    <link rel="prev" title="Lecture 4-2. DP 실습" href="4_DPPS.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="ko"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/mylogo.png" class="logo__image only-light" alt="말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업 - Home"/>
    <script>document.write(`<img src="../../_static/mylogo.png" class="logo__image only-dark" alt="말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업 - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="검색" aria-label="검색" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">검색</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Welcome to 말레이시아 5급 IT 수업
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">기초</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../basics/Input.html">입력</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basics/oop.html">객체 지향 프로그래밍 (OOP)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basics/oop-classes_instances_objects.html">클래스, 인스턴스, 객체</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basics/regex.html">정규표현식</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basics/variable_scope.html">Variable Scope</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">이론</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../theory/0_tips.html">문제 풀이 순서 팁 (Tips)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/1_implementation.html">Lecture 1-1. 구현</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/2_DFS_BFS.html">Lecture 2-1. DFS/BFS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/3_backtracking.html">Lecture 3-1. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/4_DP.html">Lecture 4-1. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/5_shortest_path.html">Lecture 5-1. Shortest Path</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/6_sort.html">Lecture 6-1. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/7_binarysearch.html">Lecture 7-1. Binary Search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/8_graph.html">Lecture 8-1. Graph Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/9_greedy.html">Lecture 9-1. Greedy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/10_prefix.html">Lecture 10-1. Prefix Sum (누적 합)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/11_LinkedList.html">Lecture 11-1. Linked List</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">실습</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="1_implementationPS.html">Lecture 1-2. 구현 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_DFS_BFSPS.html">Lecture 2-2. DFS/BFS 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_backtrackingPS.html">Lecture 3-2. Backtracking 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_DPPS.html">Lecture 4-2. DP 실습</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Lecture 5-2. Shortest Path &amp; Heap</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_linked_listPS.html">Lecture 11-2. Linked List</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">시험</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../exams/midterm_student.html">Midterm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../exams/final_student.html">Final</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="이 페이지 다운로드">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/_pages/practice/5_shortest_pathPS.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="소스 파일 다운로드"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="PDF로 인쇄"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="전체 화면으로보기"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="검색" aria-label="검색" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Lecture 5-2. Shortest Path & Heap</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> 내용 </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">가로등 설치</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">코드 트리 채점기</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">코드 트리 투어</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="lecture-5-2-shortest-path-heap">
<h1>Lecture 5-2. Shortest Path &amp; Heap<a class="headerlink" href="#lecture-5-2-shortest-path-heap" title="Link to this heading">#</a></h1>
<div class="dropdown admonition">
<p class="admonition-title">Heap vs. sort</p>
<p>Shortest path를 dijkstra로 찾는 과정에서 우리는 heapq 라이브러리를 사용하여 priority queue구조에 대하여 배웠었다. priority queue는 sort()와 다르게, ‘최대/최소’값을 반복적으로 찾아야하는 문제에서 가장 효과적이다. 특히, 데이터가 실시간으로 나갔다 들어오는 경우 Sort()보다 더 유용하다.</p>
<p>sort()와 min-heap은 오름차순으로 두면, “매번 현재 가장 싼 간선”을 선택하므로 정확성은 동일하다. 또한 시간 복잡도는</p>
<ul class="simple">
<li><p>정렬: O(E logE)</p></li>
<li><p>min-heap: heapify O(E) + E번 pop (logE씩) -&gt; O(ElogE)
위와 같이 이론상 동일하지만, 실무에서는 정렬이 상수항이 더 작고 캐시 친화적이라 빠른 일이 많다. (Timsort). 반면 min-heap은 매 pop마다 log 비용이 들어서 오히려 느릴 수 있다.</p></li>
</ul>
<p>또한 메모리 측면에서 둘 다 간선 E개 저장이 필요하므로 O(E)로 동일.</p>
<p>보통의 경우 sort()를 사용하고, min-heap은 다음과 같은 특수 상황에서 사용하면 효율적이다.</p>
<ul class="simple">
<li><p>간선이 스트리밍으로 들어오거나 한번에 다 만들기 어려운 상황 (외부 입력/온라인 처리)</p></li>
<li><p>가장 싼 간선부터 일부만 처리하며 조기 종료가 확실한 특수 케이스</p></li>
</ul>
</div>
<p>예시 문제 링크</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/street-light-installation/description">가로등 설치</a></p></li>
<li><p><a class="reference external" href="https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/codetree-judger/description">코드 트리 채점기</a></p></li>
<li><p><a class="reference external" href="https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/codetree-tour/description">코드트리 투어</a></p></li>
<li><p><a class="reference external" href="https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/pirate-captain-coddy/description">해적 선장 코디</a></p></li>
<li><p><a class="reference external" href="https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/frog-journey/description">개구리의 여행</a></p></li>
</ul>
<section id="id1">
<h2>가로등 설치<a class="headerlink" href="#id1" title="Link to this heading">#</a></h2>
<div class="dropdown admonition">
<p class="admonition-title">전역변수</p>
<p>어떤 전역 변수를 사용할 것인지, 정리한후, 전역 변수를 한번에 INIT 해놓는다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 전역 변수 선언</span>
<span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
<span class="n">lamp_pos</span> <span class="o">=</span> <span class="kc">None</span>       <span class="c1"># 각 가로등의 위치 (ID -&gt; 위치)</span>
<span class="n">next_lamp_id</span> <span class="o">=</span> <span class="kc">None</span>   <span class="c1"># 각 가로등의 다음 가로등 ID (이중 연결 리스트 구현)</span>
<span class="n">prev_lamp_id</span> <span class="o">=</span> <span class="kc">None</span>   <span class="c1"># 각 가로등의 이전 가로등 ID (이중 연결 리스트 구현)</span>
<span class="n">roads</span> <span class="o">=</span> <span class="p">[]</span>            <span class="c1"># 도로 정보를 저장할 최대 힙</span>
<span class="n">lamp_pos_min_heap</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 가로등 위치를 저장할 최소 힙 (가장 왼쪽 가로등 탐색용)</span>
<span class="n">lamp_pos_max_heap</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 가로등 위치를 저장할 최대 힙 (가장 오른쪽 가로등 탐색용)</span>
</pre></div>
</div>
<p>참고로, <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">&quot;__main__&quot;</span></code>은 함수 내부가 아니라 전역 스코프안에 있는 조건문이라 전역 스코프 (global scope)에 해당한다. 따라서, 이 안에서 <code class="docutils literal notranslate"><span class="pre">global</span></code>을 사용하면 문법 오류가 난다.</p>
</div>
<div class="dropdown admonition">
<p class="admonition-title">Lazy Deletion</p>
<p><em><strong>지연 갱신(Lazy Deletion)</strong></em> 이란, 힙에서 특정 원소를 찾아 삭제할때 바로 삭제하지 않고 오래된 정보를 그냥 두되, 힙에서 원소를 꺼낼 때마다 “이 정보가 현재 유효한가?”를 검사하는 것이다. 즉, 해당 문제에서 가로등이 제거되면, 그와 관련된 도로나 위치 정보가 힙에 여전히 남아있게 되는데, 힙에서 특정 원소를 찾아 삭제하는 것이 비효율적이므로 힙에서 꺼낼 때 정보가 유효한지 확인하는 것이다. 유효하지 않다면 버리고 다음 원소를 꺼내는 방식으로 처리하면, 전체적인 효율성을 유지하면서 로직을 간단하게 만들 수 있다.</p>
<p>dijkstra algorithm의 개선된 코드 버전에서 현재 꺼낸 노드로 가는 비용이 최소가 아니면 skip하는 로직과 동일하다.</p>
<p>해당 문제에서는 <code class="docutils literal notranslate"><span class="pre">lamp_pos</span></code> 리스트에 각 가로등의 ID를 인덱스로 하여 위치 (pos)를 저장한다. 따라서 O(1)시간에 특정 가로등의 위치를 조회할 수 있다. 가로등이 제거되면 해당 위치를 -1와 같은 무효한 값으로 표시하여 ‘지연 갱신’에 사용된다.</p>
<p>예를 들어, 두 가로등 사이에 다른 가로등이 추가되거나 제거되었다면, 해당 정보를 “실시간으로” 우선 lamp_pos에서 추가하거나 제거한다. 그러나 heapq에 있는 정보는 그대로 두고 나중에 실제로 있는지는 계속 실시간 업데이트가 되는 <code class="docutils literal notranslate"><span class="pre">lamp_pos</span></code>에서 확인하는 것이다.</p>
<p>즉, 실시간으로 업데이트 되는 정보 <code class="docutils literal notranslate"><span class="pre">lamp_pos</span></code>, <code class="docutils literal notranslate"><span class="pre">prev</span></code>, <code class="docutils literal notranslate"><span class="pre">next</span></code>이고 지연되는 것은 priority queue 즉 <code class="docutils literal notranslate"><span class="pre">road_q</span></code>, <code class="docutils literal notranslate"><span class="pre">left_q</span></code>, <code class="docutils literal notranslate"><span class="pre">right_q</span></code>와 같은 정보이다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 

<span class="n">roads</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">lamp_pos</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">get_max_road</span><span class="p">():</span>
    <span class="k">while</span> <span class="n">roads</span><span class="p">:</span>
        <span class="n">road</span> <span class="o">=</span> <span class="n">roads</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># 힙에서 꺼낸 도로 정보가 현재 가로등 위치와 일치하는지 확인</span>
        <span class="c1"># 즉, 이 도로를 구성하는 두 가로등이 여전히 인접해 있는지 검사</span>
        <span class="k">if</span> <span class="n">lamp_pos</span><span class="p">[</span><span class="n">road</span><span class="o">.</span><span class="n">left_lamp_id</span><span class="p">]</span> <span class="o">==</span> <span class="n">road</span><span class="o">.</span><span class="n">st_pos</span> <span class="ow">and</span> <span class="n">lamp_pos</span><span class="p">[</span><span class="n">road</span><span class="o">.</span><span class="n">right_lamp_id</span><span class="p">]</span> <span class="o">==</span> <span class="n">road</span><span class="o">.</span><span class="n">st_pos</span> <span class="o">+</span> <span class="n">road</span><span class="o">.</span><span class="n">length</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">roads</span><span class="p">)</span>
</pre></div>
</div>
<p>다음 <a class="reference external" href="https://school.programmers.co.kr/learn/courses/30/lessons/42628">프로그래머스 문제 링크</a> / (LeetCode 295)[<a class="reference external" href="https://leetcode.com/problems/find-median-from-data-stream/description/">https://leetcode.com/problems/find-median-from-data-stream/description/</a>] / Baekjoon 7662 이중 우선순위큐에서 lazy deletion을 연습할 수 있다.</p>
<div class="dropdown admonition">
<p class="admonition-title">인덱스를 통한 풀이</p>
<p>삽입 순서를 ID로 지정한 후, 실시간 deleted 리스트 인덱스를 ID로 하여 lazy deletion 표시 배열 사용.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span>

<span class="k">def</span><span class="w"> </span><span class="nf">solution</span><span class="p">(</span><span class="n">operations</span><span class="p">):</span>
    <span class="n">queue_b</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">queue_s</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">deleted</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">operations</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">operations</span><span class="p">):</span> 
        <span class="n">cm</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cm</span> <span class="o">==</span> <span class="s2">&quot;I&quot;</span><span class="p">:</span> 
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">queue_b</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">num</span><span class="p">,</span> <span class="o">-</span><span class="n">i</span><span class="p">))</span>  <span class="c1"># max heap</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">queue_s</span><span class="p">,</span> <span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>   <span class="c1"># min heap</span>

        <span class="k">elif</span> <span class="n">cm</span> <span class="o">==</span> <span class="s2">&quot;D&quot;</span> <span class="ow">and</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">queue_b</span><span class="p">:</span>
                <span class="n">deleted_n</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">queue_b</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">deleted</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="p">)]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> 
                    <span class="n">deleted</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">break</span>

        <span class="k">elif</span> <span class="n">cm</span> <span class="o">==</span> <span class="s2">&quot;D&quot;</span> <span class="ow">and</span> <span class="n">num</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">queue_s</span><span class="p">:</span>
                <span class="n">deleted_n</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">queue_s</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">deleted</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> 
                    <span class="n">deleted</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">break</span>

    <span class="n">max_v</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">while</span> <span class="n">queue_b</span><span class="p">:</span>
        <span class="n">val</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">queue_b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deleted</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="p">)]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">max_v</span> <span class="o">=</span> <span class="o">-</span><span class="n">val</span>
            <span class="k">break</span>

    <span class="n">min_v</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">while</span> <span class="n">queue_s</span><span class="p">:</span>
        <span class="n">val</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">queue_s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deleted</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">min_v</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">max_v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">min_v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">max_v</span><span class="p">,</span> <span class="n">min_v</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">객체 공유를 이용한 풀이</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 

<span class="k">class</span><span class="w"> </span><span class="nc">Num</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">valid</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">num</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="n">valid</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">num</span> <span class="c1"># min_heap </span>
    
<span class="k">def</span><span class="w"> </span><span class="nf">check_valid</span><span class="p">(</span><span class="n">heap</span><span class="p">):</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cur_num</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cur_num</span><span class="o">.</span><span class="n">valid</span><span class="p">:</span>  <span class="c1"># 없어진 값이면 지우고 다시 pop </span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cur_num</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
            <span class="k">break</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">check_max_valid</span><span class="p">(</span><span class="n">heap</span><span class="p">):</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">neg_num</span><span class="p">,</span> <span class="n">num_obj</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">num_obj</span><span class="o">.</span><span class="n">valid</span><span class="p">:</span>  <span class="c1"># 이미 없어진 값이면 지우고 다시 pop </span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_obj</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
            <span class="k">break</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">clean_min</span><span class="p">(</span><span class="n">heap</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">heap</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">valid</span><span class="p">:</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">clean_max</span><span class="p">(</span><span class="n">max_heap</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">max_heap</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">max_heap</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">valid</span><span class="p">:</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">max_heap</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">solution</span><span class="p">(</span><span class="n">operations</span><span class="p">):</span>
    <span class="n">min_heap</span> <span class="o">=</span> <span class="p">[]</span> 
    <span class="n">max_heap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operations</span><span class="p">:</span>
        <span class="n">char</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">char</span> <span class="o">==</span> <span class="s1">&#39;I&#39;</span><span class="p">:</span>
            <span class="n">same_instance</span> <span class="o">=</span> <span class="n">Num</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">min_heap</span><span class="p">,</span> <span class="n">same_instance</span><span class="p">)</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">max_heap</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">same_instance</span><span class="o">.</span><span class="n">num</span><span class="p">,</span> <span class="n">same_instance</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">char</span> <span class="o">==</span> <span class="s1">&#39;D&#39;</span> <span class="ow">and</span> <span class="n">num</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="c1"># 최댓값 삭제 </span>
            <span class="c1"># 예를 들어, min_heap에서 먼저 지워진 상황이지만, max_heap에서 아직 안지워진 경우 </span>
            <span class="n">check_max_valid</span><span class="p">(</span><span class="n">max_heap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 최솟값 삭제 </span>
            <span class="c1"># 예를 들어, max_heap에서 먼저 지워진 상황이지만, min_heap에서 아직 안지워진 경우 </span>
            <span class="n">check_valid</span><span class="p">(</span><span class="n">min_heap</span><span class="p">)</span>

    <span class="c1"># 실제 비어있는지 정리용 </span>
    <span class="n">clean_min</span><span class="p">(</span><span class="n">min_heap</span><span class="p">)</span>
    <span class="n">clean_max</span><span class="p">(</span><span class="n">max_heap</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">min_heap</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[</span><span class="n">max_heap</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num</span><span class="p">]</span>


<span class="c1"># operations = [&quot;I 16&quot;, &quot;I -5643&quot;, &quot;D -1&quot;, &quot;D 1&quot;, &quot;D 1&quot;, &quot;I 123&quot;, &quot;D -1&quot;]</span>
<span class="c1"># operations = [&quot;I -45&quot;, &quot;I 653&quot;, &quot;D 1&quot;, &quot;I -642&quot;, &quot;I 45&quot;, &quot;I 97&quot;, &quot;D 1&quot;, &quot;D -1&quot;, &quot;I 333&quot;]</span>
<span class="c1"># print(solution(operations))</span>
</pre></div>
</div>
</div>
<p>위의 두 방식 중에서 대부분 온라인 저지에서는 시간이 보틀넥이기 때문에, index를 활용한 deleted list를 이용하는 방식이 베스트 선택이다.</p>
</div>
<div class="dropdown admonition">
<p class="admonition-title">class comparison for heap</p>
<p>현재 가로등 정보에서 관련 정보, 왼쪽 가로등, 오른쪽 가로등과 같은 가로등 쌍에 대한 정보를 담는 class를 heap에서 정렬하기 위해 <strong>lt</strong> 비교 연산자 정의가 필요하다. 이는 다음처럼 정의할 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 

<span class="n">roads</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 인접한 가로등 사이의 도로 정보를 저장할 힙 </span>

<span class="c1"># 인접한 가로등 사이의 도로 정보를 담는 클래스 </span>
<span class="k">class</span><span class="w"> </span><span class="nc">Road</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_lamp_id</span><span class="p">,</span> <span class="n">right_lamp_id</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">st_pos</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left_lamp_id</span> <span class="o">=</span> <span class="n">left_lamp_id</span> <span class="c1">#도로의 왼쪽 가로등 ID </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right_lamp_id</span> <span class="o">=</span> <span class="n">right_lamp_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">st_pos</span> <span class="o">=</span> <span class="n">st_pos</span> <span class="c1"># 도로 시작 위치 (왼쪽 가로등 ID)</span>
    
    <span class="c1"># 최대 힙으로 사용하기 위한 비교 연산자 정의 </span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">length</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">length</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">st_pos</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">st_pos</span> 

<span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">roads</span><span class="p">,</span> <span class="n">Road</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">lamp_pos</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">doubly linked list</p>
<p>보통 doubly linked list 는 pointer를 사용하여 연결하지만 “삽입/삭제” 기능에 있어서 최대 O(N) time complexity가 소요되는 단점이 있다. 이와 달리 prev_lamp_id와 next_lamp_id의 두 리스트를 만들어서 각 가로등의 ID를 인덱스로 하여 이전 가로등과 다음 가로등의 ID를 저장한다. 이는 가로등들을 위치 순서에 따라 이중 연결 리스트처럼 관리하기 위함이며, 가로등 제거 시 양옆의 가로등을 O(1)에 찾는데 사용된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">prev</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="nb">next</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>위의 코드에서 i번째 노드 삭제는:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">prev</span><span class="p">[</span><span class="nb">next</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="nb">next</span><span class="p">[</span><span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>삭제 연산이 O(1)으로 줄어든다. 즉, linked list를 “배열로 구현하면” 사실상 매우 빠른 연결 리스트가 된다.</p>
<div class="dropdown admonition">
<p class="admonition-title">DLL implementation with array</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">MAX</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>
<span class="n">prev</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">MAX</span> 
<span class="nb">next</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">MAX</span> 
<span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">MAX</span> 

<span class="c1"># head = some index </span>
<span class="c1"># insert x after cur </span>
<span class="k">def</span><span class="w"> </span><span class="nf">insert</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="nb">next</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span>
    <span class="n">prev</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span> 

    <span class="c1"># NOTE: next node의 prev에 접근할때 </span>
    <span class="k">if</span> <span class="nb">next</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># linked list의 last가 아닌 경우, </span>
        <span class="n">prev</span><span class="p">[</span><span class="nb">next</span><span class="p">[</span><span class="n">cur</span><span class="p">]]</span> <span class="o">=</span> <span class="n">x</span> 

    <span class="nb">next</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">delete</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">prev</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="nb">next</span><span class="p">[</span><span class="n">prev</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> 
    <span class="k">if</span> <span class="nb">next</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">prev</span><span class="p">[</span><span class="nb">next</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="n">prev</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p>해당 방식을 사용하여 빠르게 풀 수 있는 문제들을 아래에 적어놓았다.</p>
<ul class="simple">
<li><p>[LRU Cache 최적 구현]</p></li>
<li><p>[BOJ 5397 키로거]</p></li>
<li><p>[BOJ 1406 에디터]</p></li>
</ul>
</div>
<div class="dropdown admonition">
<p class="admonition-title">좌/우 전역값 동기화</p>
<p>이론상 전역 변수로 끝값을 정리하면서 “삭제 때만 갱신”하는 것으로 코드를 구현할 수 있다. 이런 방식은 힙 사용때보다 메모리 사용량을 줄일 수 있지만, 업데이트 순서가 미묘하게 어긋나거나 버그가 하나만 생겨도 전역 끝값이 틀어질 수 있다. 전역 캐시는 모든 변화 경로를 100% 누락 없이 갱신해야 하는 부채가 생깁니다(연속 삭제, 경계 근처 혼합 연산, 예외 입력 등). 하지만 <em><strong>힙+지연검증</strong></em> 은 질의 시점에 항상 자기 교정을 하므로, 누락이 끼어도 pop하면서 복구돼요.
→ “가능은 하지만 유지비가 큰 전역 캐시” vs “조금 더 구조화된 힙 기반”의 선택 문제입니다.</p>
</div>
<div class="dropdown admonition">
<p class="admonition-title">ceiling</p>
<p>중간 좌표 계산에서 천장(ceil)인 경우에, 아래 코드를 사용한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">new_pos</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">st_pos</span> <span class="o">+</span> <span class="p">(</span><span class="n">road</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
</pre></div>
</div>
<p>2로 나누어 round()를 적용하면 파이썬에서는 ‘은행가 반올림(0.5를 짝수로)이라 4.5 -&gt; 4, 5.5-&gt;6 같은 예외가 생긴다. 문제에서는 ceiling 을 요구하므로 위의 코드를 사용해야한다.</p>
</div>
<div class="dropdown admonition">
<p class="admonition-title">solution</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span> 
<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 

<span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span>
<span class="c1"># sys.stdin = open(&#39;Input.txt&#39;)</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">INIT:</span>

<span class="sd">1) road_q = </span>
<span class="sd">2) left_q = </span>
<span class="sd">3) right_q = </span>
<span class="sd">4) prev = </span>
<span class="sd">5) next = </span>
<span class="sd">6) N = length of the road </span>
<span class="sd">7) lamps_pos = </span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Road</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">end_pos</span><span class="p">,</span> <span class="n">left_num</span><span class="p">,</span> <span class="n">right_num</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_pos</span> <span class="o">=</span> <span class="n">start_pos</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">end_pos</span> <span class="o">=</span> <span class="n">end_pos</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">left_num</span> <span class="o">=</span> <span class="n">left_num</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">right_num</span> <span class="o">=</span> <span class="n">right_num</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">length</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_pos</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">start_pos</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">length</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">check</span><span class="p">(</span><span class="n">light_nums</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
    <span class="n">poses</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pos</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">left_pos</span><span class="p">,</span> <span class="n">right_pos</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">poses</span><span class="p">):</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">right_pos</span> <span class="o">-</span> <span class="n">left_pos</span> 
        <span class="n">left_num</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span> 
        <span class="n">right_num</span> <span class="o">=</span> <span class="n">left_num</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># Road 안에 __lt__로 length에 대해서 max_heap, left_pos에 대해서 min_heap으로 heapq에서 &quot;정렬&quot;되도록 해놓음. </span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">road_q</span><span class="p">,</span> <span class="n">Road</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">left_pos</span><span class="p">,</span> <span class="n">right_pos</span><span class="p">,</span> <span class="n">left_num</span><span class="p">,</span> <span class="n">right_num</span><span class="p">))</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">left_q</span><span class="p">,</span> <span class="p">(</span><span class="n">left_pos</span><span class="p">,</span> <span class="n">left_num</span><span class="p">))</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">right_q</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">left_pos</span><span class="p">,</span> <span class="n">left_num</span><span class="p">))</span>
        <span class="n">lamps_pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left_pos</span><span class="p">)</span>
        <span class="n">prev</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left_num</span><span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">left_num</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="nb">next</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right_num</span><span class="p">)</span> 
    
    <span class="c1"># 맨 마지막 노드 </span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">left_q</span><span class="p">,</span> <span class="p">(</span><span class="n">right_pos</span><span class="p">,</span> <span class="n">right_num</span><span class="p">))</span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">right_q</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">right_pos</span><span class="p">,</span> <span class="n">right_num</span><span class="p">))</span>
    <span class="n">prev</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right_num</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="nb">next</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">lamps_pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right_pos</span><span class="p">)</span>

 
<span class="k">def</span><span class="w"> </span><span class="nf">valid_check</span><span class="p">(</span><span class="n">cur_road</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    현재 두 가로등 사이의 정보(cur_road)가 정확한지, 아니면 old한 정보인지 check </span>
<span class="sd">    항상 맞는 정보: prev, next, lamps_pos(불변)</span>
<span class="sd">    아직 업데이트 안되어 있는 정보: road_q, left_q, right_q </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">cur_road</span><span class="o">.</span><span class="n">length</span> 
    <span class="n">left_pos</span> <span class="o">=</span> <span class="n">cur_road</span><span class="o">.</span><span class="n">start_pos</span> 
    <span class="n">right_pos</span> <span class="o">=</span> <span class="n">cur_road</span><span class="o">.</span><span class="n">end_pos</span> 
    <span class="n">left_num</span> <span class="o">=</span> <span class="n">cur_road</span><span class="o">.</span><span class="n">left_num</span> 
    <span class="n">right_num</span> <span class="o">=</span> <span class="n">cur_road</span><span class="o">.</span><span class="n">right_num</span> 

    <span class="k">if</span> <span class="n">lamps_pos</span><span class="p">[</span><span class="n">left_num</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">lamps_pos</span><span class="p">[</span><span class="n">right_num</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># 둘 중 하나가 이미 제거된 가로등 </span>
        <span class="k">return</span> <span class="kc">False</span> 
    <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="nb">abs</span><span class="p">(</span><span class="n">left_pos</span> <span class="o">-</span> <span class="n">lamps_pos</span><span class="p">[</span><span class="nb">next</span><span class="p">[</span><span class="n">left_num</span><span class="p">]]):</span>
        <span class="k">return</span> <span class="kc">True</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    인접 가로등 사이에 추가</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># lazy deletion </span>
    <span class="n">to_be_broken_road</span> <span class="o">=</span> <span class="kc">None</span> 
    <span class="k">while</span> <span class="n">road_q</span><span class="p">:</span>
        <span class="n">cur_road</span> <span class="o">=</span> <span class="n">road_q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">valid_check</span><span class="p">(</span><span class="n">cur_road</span><span class="p">):</span>
            <span class="c1"># 추가될 기존 길은 road_q에서 삭제 되어야한다. </span>
            <span class="n">to_be_broken_road</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">road_q</span><span class="p">)</span>
            <span class="k">break</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">road_q</span><span class="p">)</span>
    
    <span class="c1"># 추가 </span>
    <span class="n">left_pos</span> <span class="o">=</span> <span class="n">to_be_broken_road</span><span class="o">.</span><span class="n">start_pos</span>
    <span class="n">right_pos</span>  <span class="o">=</span> <span class="n">to_be_broken_road</span><span class="o">.</span><span class="n">end_pos</span>
    <span class="n">left_lamp_num</span> <span class="o">=</span> <span class="n">to_be_broken_road</span><span class="o">.</span><span class="n">left_num</span>
    <span class="n">right_lamp_num</span> <span class="o">=</span> <span class="n">to_be_broken_road</span><span class="o">.</span><span class="n">right_num</span>

    <span class="n">new_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">left_pos</span> <span class="o">+</span> <span class="n">right_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> 
    <span class="n">new_lamp_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">road_q</span><span class="p">,</span> <span class="n">Road</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">new_pos</span><span class="o">-</span><span class="n">left_pos</span><span class="p">),</span> <span class="n">left_pos</span><span class="p">,</span> <span class="n">new_pos</span><span class="p">,</span> <span class="n">left_lamp_num</span><span class="p">,</span> <span class="n">new_lamp_num</span><span class="p">))</span> <span class="c1"># length, start_pos, end_pos, left_num, right_num</span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">road_q</span><span class="p">,</span> <span class="n">Road</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">right_pos</span><span class="o">-</span><span class="n">new_pos</span><span class="p">),</span> <span class="n">new_pos</span><span class="p">,</span> <span class="n">right_pos</span><span class="p">,</span> <span class="n">new_lamp_num</span><span class="p">,</span> <span class="n">right_lamp_num</span><span class="p">))</span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">left_q</span><span class="p">,</span> <span class="p">(</span><span class="n">new_pos</span><span class="p">,</span> <span class="n">new_lamp_num</span><span class="p">))</span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">right_q</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">new_pos</span><span class="p">,</span> <span class="n">new_lamp_num</span><span class="p">))</span>
    <span class="n">prev</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left_lamp_num</span><span class="p">)</span>
    <span class="nb">next</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right_lamp_num</span><span class="p">)</span>
    <span class="n">prev</span><span class="p">[</span><span class="n">right_lamp_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_lamp_num</span>
    <span class="nb">next</span><span class="p">[</span><span class="n">left_lamp_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_lamp_num</span>

    <span class="n">lamps_pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pos</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">remove</span><span class="p">(</span><span class="n">removed_lamp_num</span><span class="p">):</span>
    <span class="c1"># 가장 자리 노드가 아닌 중간 노드를 제거하는 경우는, 두 개의 길이 삭제 (lazy deletion)될 것이고</span>
    <span class="c1"># 길이 하나 더 추가되어야함. </span>
    <span class="k">if</span> <span class="n">prev</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">next</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lamps_pos</span><span class="p">[</span><span class="n">prev</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]]</span><span class="o">-</span><span class="n">lamps_pos</span><span class="p">[</span><span class="nb">next</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]])</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">road_q</span><span class="p">,</span> <span class="n">Road</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">lamps_pos</span><span class="p">[</span><span class="n">prev</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]],</span> <span class="n">lamps_pos</span><span class="p">[</span><span class="nb">next</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]],</span> <span class="n">prev</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">],</span> <span class="nb">next</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]))</span>

<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    가장 자리 노드가 삭제되면 road_q는 그대로이고, left_q와 right_q도 후에 lazy deletion으로 삭제될 예정이라</span>
<span class="sd">    해줄 것이 없음, 다만 현재의 정보를 정확히 lamps_pos, prev, next에 저장</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># doubly linked list </span>
    <span class="k">if</span> <span class="n">prev</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="nb">next</span><span class="p">[</span><span class="n">prev</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">next</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">prev</span><span class="p">[</span><span class="nb">next</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]]</span> <span class="o">=</span> <span class="n">prev</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]</span>
    <span class="c1"># 현재 가로등에 대한 정보 전부 제거 </span>
    <span class="n">lamps_pos</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 
    <span class="n">prev</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="nb">next</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">get_max_from_left</span><span class="p">():</span>
    <span class="k">while</span> <span class="n">left_q</span><span class="p">:</span> <span class="c1"># (pos, num)</span>
        <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="o">=</span> <span class="n">left_q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">lamps_pos</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pos</span><span class="p">:</span> <span class="c1"># invalid </span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">left_q</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span> 
    <span class="k">return</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># r계산 </span>

<span class="k">def</span><span class="w"> </span><span class="nf">get_max_from_right</span><span class="p">():</span>
    <span class="n">dis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">right_q</span><span class="p">:</span>
        <span class="p">(</span><span class="n">dis</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="o">=</span> <span class="n">right_q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dis</span> <span class="o">=</span> <span class="n">dis</span><span class="o">*-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">lamps_pos</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dis</span><span class="p">:</span> <span class="c1"># max_heap 이라서 -1 를 곱해줘야함. </span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">right_q</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span> 
    <span class="k">return</span> <span class="n">N</span><span class="o">-</span><span class="n">dis</span>  <span class="c1"># pos는 이미 음수, r 계산 </span>

<span class="k">def</span><span class="w"> </span><span class="nf">get_max_from_roads</span><span class="p">():</span>
    <span class="k">while</span> <span class="n">road_q</span><span class="p">:</span>
        <span class="n">cur_road</span> <span class="o">=</span> <span class="n">road_q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">valid_check</span><span class="p">(</span><span class="n">cur_road</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cur_road</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">road_q</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">calculate</span><span class="p">():</span>
    <span class="n">side_r</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">get_max_from_left</span><span class="p">(),</span> <span class="n">get_max_from_right</span><span class="p">())</span>
    <span class="n">middle_r</span> <span class="o">=</span> <span class="n">get_max_from_roads</span><span class="p">()</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="n">side_r</span><span class="p">,</span> <span class="n">middle_r</span><span class="p">))</span>

<span class="n">lamps_pos</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">road_q</span> <span class="o">=</span> <span class="p">[]</span> 
<span class="n">left_q</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">right_q</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">prev</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="c1"># 아무것도 없으면 -1 </span>
<span class="nb">next</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
<span class="n">N</span> <span class="o">=</span> <span class="mi">0</span> 

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Q</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> 
            <span class="n">check</span><span class="p">(</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">order</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span>
        <span class="k">elif</span> <span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span>
            <span class="n">add</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">300</span><span class="p">:</span>
            <span class="n">remove</span><span class="p">(</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># 400 </span>
            <span class="nb">print</span><span class="p">(</span><span class="n">calculate</span><span class="p">())</span>
</pre></div>
</div>
</div>
</section>
<section id="id2">
<h2>코드 트리 채점기<a class="headerlink" href="#id2" title="Link to this heading">#</a></h2>
<p>이런 문제를 푸는 경우, 각 문제의 요구 사항을 만족시키기 위해서는 <em><strong>(1) 각 정보의 특성에 맞는 효율적인 자료구조</strong></em> 를 설계하고, 각 명령어에 따른 <em><strong>(2) 상태 변화를 누락 없이 처리</strong></em> 하는 것이 중요하다.</p>
<div class="dropdown admonition">
<p class="admonition-title">필요한 자료구조</p>
<p>문제를 풀때 wating_urls을 priority queue로 해서, Task를 하나씩 뽑아내는 것을 생각하기 쉽다. 이때 문제는, 현재 들어온 url이 waiting_urls에 있는지 확인하려면, 다 뺐다가 다시 넣어야한다. 따라서, waiting_urls은 검색을 O(1)으로 용이하게 하도록 set[str]으로 만든다. 그렇다면, 우선순위가 가장 높은 Task를 구할때는 domain_pqs: dict[str, list[Task]] 로 각 도메인별로 가장 우선순위가 높은 맨 앞의 Task하나씩 비교해서 보면 된다. 문제의 contraints를 보면 서로 다른 도메인수는 최대 300이라고 했기 때문에, 이렇게 하는것이 시간 복잡도상 가장 효율적이게 된다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">waiting_urls:</span> <span class="pre">set[str]</span></code>: 채점 대기 큐에 있는 Task들의 url들을 저장하는 집합(set). 특정 url이 큐에 있는지 평균 O(1) 시간 복잡도로 빠르게 확인하기 위해 사용한다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">domain_pqs:</span> <span class="pre">dict[str,</span> <span class="pre">list[Task]]</span></code>: 각 도메인별로 채점 대기 중인 Task들을 저장하는 우선순위 큐. 파이썬의 heapq 모듈을 사용한다. 도메인별로 list가 연결되어있고, 이 리스트가 우선순위큐로 Task들을 저장한다.</p>
<ul>
<li><p>key는 ‘도메인(domain)’, value는 해당 도메인의 Task들을 담은 우선순위 큐(최소 힙)이다.</p></li>
<li><p>Task의 우선순위(우선순위 번호가 작을 수록, 요청 시간이 빠를수록 높음)에 따라 자동으로 정렬되므로, 각 도메인에서 가장 우선순위 높은 Task를 O(1)로 찾을 수 있다.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">resting_judger_ids:</span> <span class="pre">list[int]</span></code>: 쉬고 있는 채점기의 ID들을 저장하는 최소 힙. 가장 번호가 작은 채점기를 빠르게 찾기 위해 사용한다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">judgers:</span> <span class="pre">list[Task</span> <span class="pre">|</span> <span class="pre">None]</span></code>: 각 채점기가 현재 어떤 Task를 채점 중인지 저장하는 배열. judger[i]는 i번 채점기가 채점 중인 Task 객체를 가리키거나, 쉬고 있다면 None을 저장한다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">domain_judge_history:</span> <span class="pre">dict[str,</span> <span class="pre">History]</span></code>: 각 도메인의 가장 최근 채점 기록(시작 시간, 종료 시간)을 저장하는 딕셔너리. 채점 유예 기간을 계산하는데 사용한다.</p></li>
</ul>
<p>또한, Task정보와 채점 기록 정보를 편리하게 다루기 위한 클래스들을 정의한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 채점 태스크(Task) 정보를 저장하는 클래스입니다.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Task</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">priority</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">url</span><span class="p">:</span><span class="nb">str</span><span class="p">):</span>
        <span class="n">domain</span><span class="p">,</span> <span class="n">pid_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">request_time</span> <span class="o">=</span> <span class="n">request_time</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">priority</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">url</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">domain</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">problem_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pid_str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 
        
    
    <span class="c1"># 우선순위 비교를 위한 __lt__ 메서드 </span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    &quot;Task&quot;라고 표시한 이유: __lt__가 클래스 내부에 있을 때 아직 정의되지 않은 Task 타입을 참조하기 위해 &quot;전방 선언(Forward Reference)&quot;으로 문자열을 사용한 것. 즉 문자열을 &#39;타입 힌트&#39;로 쓰면 python이 나중에 실제 그걸 클래스 이름으로 다시 해석한다. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Task&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">priority</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">priority</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">request_time</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">request_time</span>

<span class="c1"># 각 도메인의 채점 기록(History)을 저장하는 클래스입니다.</span>
<span class="c1"># domain_judge_history: dict[str, History]에서 value에 사용될 예정 </span>
<span class="k">class</span><span class="w"> </span><span class="nc">History</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">start_time</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">end_time</span> 

    <span class="k">def</span><span class="w"> </span><span class="nf">is_valid_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">gap</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">gap</span> <span class="o">&lt;=</span> <span class="n">cur_time</span> 
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">solution</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span> 

<span class="c1"># -----------------------------</span>
<span class="c1"># 데이터 구조 공간 복잡도</span>
<span class="c1"># -----------------------------</span>
<span class="c1"># domain_pqs           : 도메인별 우선순위 큐, 전체 Task 수 ≤ Q → O(Q)</span>
<span class="c1"># domain_judge_history : 도메인 ≤ 300개 → O(1)</span>
<span class="c1"># resting_judger_ids   : 최대 N개 → O(N)</span>
<span class="c1"># judging_domains      : 최대 300개 → O(1)</span>
<span class="c1"># judgers              : N+1 크기 배열 → O(N)</span>
<span class="c1"># waiting_urls         : 대기 URL ≤ Q → O(Q)</span>
<span class="c1">#</span>
<span class="c1"># 전체 공간 복잡도: O(N + Q)</span>
<span class="c1"># -----------------------------</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Task</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Task 객체 1개 공간: O(1) (URL 길이가 상수 19니까 O(1))&quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">priority</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">url</span><span class="p">:</span><span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">domain</span><span class="p">,</span> <span class="n">pid_str</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">request_time</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">request_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">priority</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">priority</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">url</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">domain</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">problem_id</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pid_str</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Task&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;비교 연산: O(1)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">priority</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">priority</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">request_time</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">request_time</span> 


<span class="k">class</span><span class="w"> </span><span class="nc">History</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;History 객체 1개 공간: O(1)&quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span><span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">start_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">end_time</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_valid_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;단순 연산: O(1)&quot;&quot;&quot;</span>
        <span class="n">gap</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">gap</span> <span class="o">&lt;=</span> <span class="n">cur_time</span> 
    

<span class="c1"># 전역 데이터 구조</span>
<span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">domain_pqs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Task</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="n">domain_judge_history</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">History</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">resting_judger_ids</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">judging_domains</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="n">judgers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Task</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">waiting_urls</span> <span class="p">:</span><span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>


<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 명령어 100: 채점기 준비</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 시간 복잡도:</span>
<span class="c1">#   resting_judger_ids 초기화: O(N)</span>
<span class="c1">#   judgers 초기화: O(N)</span>
<span class="c1">#   process_200 호출: O(log Q)</span>
<span class="c1"># 전체 → O(N)</span>
<span class="c1">#</span>
<span class="c1"># 공간 복잡도: O(N) (리스트 초기화)</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process_100</span><span class="p">(</span><span class="n">n_</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span><span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">n</span><span class="p">,</span> <span class="n">resting_judger_ids</span><span class="p">,</span> <span class="n">judgers</span> 

    <span class="n">n</span> <span class="o">=</span> <span class="n">n_</span>
    <span class="n">resting_judger_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>  <span class="c1"># O(N)</span>
    <span class="n">judgers</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>                         <span class="c1"># O(N)</span>

    <span class="n">process_200</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">)</span>                       <span class="c1"># O(log Q)</span>


<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 명령어 200: 채점 요청 추가</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 시간 복잡도:</span>
<span class="c1">#   u in waiting_urls (set membership): O(1)</span>
<span class="c1">#   Task 생성: O(1)</span>
<span class="c1">#   heapq.heappush: O(log Q)</span>
<span class="c1">#   waiting_urls.add: O(1)</span>
<span class="c1"># 전체 → O(log Q)</span>
<span class="c1">#</span>
<span class="c1"># 공간 복잡도: O(1) (Task 1개 추가 → 전체적으로 O(Q) 안에 포함)</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process_200</span><span class="p">(</span><span class="n">t</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">waiting_urls</span><span class="p">,</span> <span class="n">domain_pqs</span> 

    <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">waiting_urls</span><span class="p">:</span>    <span class="c1"># O(1)</span>
        <span class="k">return</span> 
    
    <span class="n">task</span> <span class="o">=</span> <span class="n">Task</span><span class="p">(</span><span class="n">request_time</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">url</span><span class="o">=</span><span class="n">u</span><span class="p">)</span>  <span class="c1"># O(1)</span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">domain_pqs</span><span class="p">[</span><span class="n">task</span><span class="o">.</span><span class="n">domain</span><span class="p">],</span> <span class="n">task</span><span class="p">)</span>   <span class="c1"># O(log Q)</span>
    <span class="n">waiting_urls</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>                             <span class="c1"># O(1)</span>


<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 도메인 채점 가능 여부 확인</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 시간 복잡도: O(1)</span>
<span class="c1"># 공간 복잡도: O(1)</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="k">def</span><span class="w"> </span><span class="nf">is_domain_judgeable</span><span class="p">(</span><span class="n">cur_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">domain</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">judging_domains</span><span class="p">,</span> <span class="n">domain_judge_history</span>

    <span class="k">if</span> <span class="n">domain</span> <span class="ow">in</span> <span class="n">judging_domains</span><span class="p">:</span>           <span class="c1"># O(1)</span>
        <span class="k">return</span> <span class="kc">False</span> 

    <span class="n">history</span><span class="p">:</span> <span class="n">History</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="n">domain_judge_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># O(1)</span>
    <span class="k">if</span> <span class="n">history</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">history</span><span class="o">.</span><span class="n">is_valid_time</span><span class="p">(</span><span class="n">cur_time</span><span class="p">):</span>               <span class="c1"># O(1)</span>
        <span class="k">return</span> <span class="kc">False</span> 
    
    <span class="k">return</span> <span class="kc">True</span> 


<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 명령어 300: 채점 시도</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 시간 복잡도:</span>
<span class="c1">#   쉬는 채점기 체크: O(1)</span>
<span class="c1">#   모든 도메인 순회: D ≤ 300 → O(300) = O(1)</span>
<span class="c1">#   각 도메인 pq[0] 접근: O(1)</span>
<span class="c1">#   비교 연산: O(1)</span>
<span class="c1">#   heappop(resting_judger_ids): O(log N)</span>
<span class="c1">#   heappop(domain_pqs[domain]): O(log Q)</span>
<span class="c1">#   set/dict 업데이트: O(1)</span>
<span class="c1">#</span>
<span class="c1"># 전체 → O(log N + log Q)</span>
<span class="c1">#</span>
<span class="c1"># 공간 복잡도: O(1)</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process_300</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">resting_judger_ids</span><span class="p">,</span> <span class="n">domain_pqs</span><span class="p">,</span> <span class="n">judging_domains</span><span class="p">,</span> <span class="n">judgers</span><span class="p">,</span> <span class="n">waiting_urls</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">resting_judger_ids</span><span class="p">:</span>  <span class="c1"># O(1)</span>
        <span class="k">return</span> 
    
    <span class="n">best_task</span><span class="p">:</span> <span class="n">Task</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span> 

    <span class="k">for</span> <span class="n">domain</span><span class="p">,</span> <span class="n">pq</span> <span class="ow">in</span> <span class="n">domain_pqs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>   <span class="c1"># O(300) = O(1)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pq</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">is_domain_judgeable</span><span class="p">(</span><span class="n">cur_time</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="p">):</span>  
            <span class="k">continue</span> 

        <span class="n">current_task</span> <span class="o">=</span> <span class="n">pq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                <span class="c1"># O(1)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">best_task</span> <span class="ow">or</span> <span class="n">current_task</span> <span class="o">&lt;</span> <span class="n">best_task</span><span class="p">:</span>  <span class="c1"># O(1)</span>
            <span class="n">best_task</span> <span class="o">=</span> <span class="n">current_task</span> 

    <span class="k">if</span> <span class="ow">not</span> <span class="n">best_task</span><span class="p">:</span>
        <span class="k">return</span> 
    
    <span class="n">j_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">resting_judger_ids</span><span class="p">)</span>     <span class="c1"># O(log N)</span>
    <span class="n">best_task</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">t</span> 

    <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">domain_pqs</span><span class="p">[</span><span class="n">best_task</span><span class="o">.</span><span class="n">domain</span><span class="p">])</span>       <span class="c1"># O(log Q)</span>
    <span class="n">judging_domains</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">best_task</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>             <span class="c1"># O(1)</span>
    <span class="n">judgers</span><span class="p">[</span><span class="n">j_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_task</span>                         <span class="c1"># O(1)</span>
    <span class="n">waiting_urls</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">best_task</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>                <span class="c1"># O(1)</span>


<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 명령어 400: 채점 종료</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 시간 복잡도:</span>
<span class="c1">#   task 조회: O(1)</span>
<span class="c1">#   History 생성 및 dict 기록: O(1)</span>
<span class="c1">#   heapq.heappush(resting_judger_ids): O(log N)</span>
<span class="c1">#   set.remove + 배열 저장: O(1)</span>
<span class="c1">#</span>
<span class="c1"># 전체 → O(log N)</span>
<span class="c1">#</span>
<span class="c1"># 공간 복잡도: O(1)  (History 1개 추가 → 전체 O(Q)에 포함)</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process_400</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">judgers</span><span class="p">,</span> <span class="n">domain_judge_history</span><span class="p">,</span> <span class="n">resting_judger_ids</span><span class="p">,</span> <span class="n">judging_domains</span>

    <span class="n">task</span><span class="p">:</span> <span class="n">Task</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="n">judgers</span><span class="p">[</span><span class="n">j_id</span><span class="p">]</span>       <span class="c1"># O(1)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">task</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">domain_judge_history</span><span class="p">[</span><span class="n">task</span><span class="o">.</span><span class="n">domain</span><span class="p">]</span> <span class="o">=</span> <span class="n">History</span><span class="p">(</span><span class="n">start_time</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># O(1)</span>
    
    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">resting_judger_ids</span><span class="p">,</span> <span class="n">j_id</span><span class="p">)</span>    <span class="c1"># O(log N)</span>
    <span class="n">judging_domains</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>          <span class="c1"># O(1)</span>
    <span class="n">judgers</span><span class="p">[</span><span class="n">j_id</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>                         <span class="c1"># O(1)</span>


<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 명령어 500: 대기 큐 조회</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 시간 복잡도: O(1)</span>
<span class="c1"># 공간 복잡도: O(1)</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process_500</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">waiting_urls</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">waiting_urls</span><span class="p">))</span>  <span class="c1"># O(1)</span>


<span class="c1"># ------------------ 메인 실행 ------------------</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">전체 시간 복잡도: O(Q(logN + logQ))</span>
<span class="sd">전체 공간 복잡도: O(N+Q)</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="n">q</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="n">query</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">cmd</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">cmd</span> <span class="o">==</span> <span class="mi">100</span><span class="p">:</span>
        <span class="n">process_100</span><span class="p">(</span><span class="n">n_</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">u</span><span class="o">=</span><span class="n">query</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">cmd</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span>
        <span class="n">process_200</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">p</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">u</span><span class="o">=</span><span class="n">query</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">cmd</span> <span class="o">==</span> <span class="mi">300</span><span class="p">:</span>
        <span class="n">process_300</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">cmd</span> <span class="o">==</span> <span class="mi">400</span><span class="p">:</span>
        <span class="n">process_400</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">j_id</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">cmd</span> <span class="o">==</span> <span class="mi">500</span><span class="p">:</span>
        <span class="n">process_500</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

</pre></div>
</div>
</div>
</section>
<section id="id3">
<h2>코드 트리 투어<a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<p>구현 문제의 경우, 실수할 수 있는 부분은 여러개의 command 중 하나를 하고 다른 command를 할 경우 그 다음 상황에 영향을 미치는 것이 있는 지 미리 체크해야한다. 이번 문제의 경우 새로 변한 start_id에 대해 이후에 command <code class="docutils literal notranslate"><span class="pre">200</span></code>이 나오는 경우에 새로운 <code class="docutils literal notranslate"><span class="pre">start_id</span></code>에 대하여 Trip의 cost등을 계산해야하므로 이를 global variable로 관리해주는 것이 포인트였다.</p>
<div class="dropdown admonition">
<p class="admonition-title">explanation</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">여행 상품의 출발지는 통일: 0번 도시 </span>
<span class="sd">간선에 음수가 없으므로 dijkstra algorithm사용 가능. </span>

<span class="sd">0. 필요한 자료 구조 </span>
<span class="sd">- `trip_lists`: pq, Trip class를 priority에 맞게 보관 </span>
<span class="sd">- class Trip: __lt__(), get_benefit(), </span>
<span class="sd">- shortest_path: dict[int(id), list[int] (cost to the dest_id)]</span>
<span class="sd">- graph: adjacency_list: list[list[int]], 각 노드와 연결된 node정보 저장 </span>

<span class="sd">1. 코드트리 랜드 건설</span>
<span class="sd">- 도시의 수 n, 간선의 수 m, 간성 정보 (도시 i,도시 j, 가중치)</span>
<span class="sd">- 자기자신 연결, 두 도시 간의 여러 간선 가능 </span>
<span class="sd">- start_node가 0인 shortest_path INIT </span>
<span class="sd">- graph 초기화 </span>

<span class="sd">2. 여행 상품 생성 </span>
<span class="sd">- 관리 목록: (id, revenue_id, dest_id) 여행 상품을 추가하고 관리 목록에 추가 </span>
<span class="sd">    - 데이터 구조: priority queue로 O(log(30,000)) = O(10)  </span>
<span class="sd">    - id: 여행상품 고유 식별자 </span>
<span class="sd">    - revenue_id : 여행사가 얻게되는 매출 </span>
<span class="sd">    - start_id: 이 상품의 출발지 </span>
<span class="sd">    - dest_id :이 상품의 도착지 </span>
<span class="sd">    - cost : revenue_id - shortest_path (출발지 ~ 도착지 최단거리)</span>
<span class="sd">- 해당 명령은 최대 30,000번 주어진다.</span>
<span class="sd">- class Trip 생성으로 해당 데이터 관리 필요 </span>
<span class="sd">    - __lt__ 함수 : pq에 들어갈나 &lt;, &gt;를 계산할때 비교 함수 생성 </span>
<span class="sd">    - get_benefit 함수: Start_id가 바뀜에 cost가 변해서, 변할때 그 차이를 계산해주는 함수 생성 </span>


<span class="sd">3. 여행 상품 취소 </span>
<span class="sd">- 여행 상품 고유 식별자 id에 해당하는 여행 상품 존재하면 관리 목록에서 삭제 </span>
<span class="sd">    - 찾기: O(1) -&gt; dict로 id에 따른 상품을 관리할 수 있음 </span>
<span class="sd">        - list로 관리하면 어떤 id가 있을 지도 모르는데, 메모리 비용이 많이 든다. </span>
<span class="sd">        - id는 30,000보다 작으므로 근데 어차피 여행 상품 넣는 것을 30000으로 하니까 오히려 list의 indexf로 관리하는게 더 나을 수도 있겠음. </span>
<span class="sd">        - dictionary는 key가 맞는지 일일이 확인해야하잖아. </span>
<span class="sd">    - 삭제: O(1) </span>
<span class="sd">    - 삭제 이후, 관리 목록 pq 는 lazy deletion을 진행해야함. (즉, id_trip_pq는 바로 관리하고, 4번 판매할때, 이게 유효한지, id_trip_pq를 통해서 확인)</span>
<span class="sd">- 해당 명령은 최대 30,000번 주어진다. ~ 3*1e4</span>

<span class="sd">4. 최적 여행 상품 판매 </span>
<span class="sd">- 판매 가능 상품이 없으면 -1 출력후 상품 제거 x </span>
<span class="sd">- 판매 가능 상품 있으면 해당 상품 id 출력후 상품 제거 </span>
<span class="sd">- 해당 명령은 최대 30,000번 주어진다. ~ O(10)*30000 ~ 3*1e5</span>

<span class="sd">- 판매 불가 상품 </span>
<span class="sd">    - 출발지로부터 dest_id까지 도달하는 것이 불가능 </span>
<span class="sd">        - 이건 넣을때부터 알 수 있는 건데...아 근데 넣을때 빼버리면 나중에 출발지 변경할때 또 달라질 수 있어서 그때그때 검사하는 게 좋음 </span>
<span class="sd">        - Trip class의 cost가 MAX값이면 도달 불가능확인 가능 </span>
<span class="sd">        - O(1)</span>
<span class="sd">    - cost_id가 revenue_id보다 커서 여행사가 이득을 얻을 수 없는 상황, 이득이 0인 경우도 팔 수 있음 </span>
<span class="sd">        - revenue_id - cost_id &lt; 0 이면 팔 수 없음 </span>
<span class="sd">        - O(1) </span>
<span class="sd">- 관리 목록에서 조건에 맞는 최적 상품 선택 및 판매 </span>
<span class="sd">    - 조건: </span>
<span class="sd">        - 이득 [revenue - cost]가 최대인 상품 : cost = 출발지로부터 id 상품의 도착지 dest_id까지 도달하기 위한 최단 거리 </span>
<span class="sd">        - 이득이 동일하면 id가 가장 작은 상품 선택 </span>
<span class="sd">        - NOTE: </span>
<span class="sd">        ---&gt; 이 조건들을 생각해보면, get_benefit()을 통해 나온 이득이 음수인 경우, 그 뒤를 보지 않아도 다 팔리지 못할 상품들이므로 팔 수 있는 상품이 없다고 생각하면 됨. </span>
<span class="sd">        ----&gt; 따라서, 맨 처음 pq에 있는 상품의 이득이 &gt;=0인 경우, 그것을 팔면 된다.</span>
<span class="sd">    - 판매 불가 조건 </span>
<span class="sd">        - 위 참고 </span>
<span class="sd">    - 판매 가능 상품 중 가장 우선순위가 높은 상품을 1개 판매하고, 이 상품의 id를 출력한 뒤 관리 목록에서 제거 (logQ)</span>
<span class="sd">        -관리 목록: priority queue </span>

<span class="sd">Algorithm </span>
<span class="sd">1-1. pq에서 맨 위의 Task를 뽑는다. (아직 제거x) (이득이 최대이고, id가 가장 작은 상품 순으로 뽑힘.)</span>
<span class="sd">2-1. 이미 3.에 의해 삭제된 여행 상품인지 확인한다. (O(1))</span>
<span class="sd">2-2. 존재하는 상품이면, 판매 불가 상품인지 확인한다. (O(1))</span>
<span class="sd">3-1. 위의 조건을 만족하면, id를 출력한 뒤 관리 목록에서 제거한다. (log30000 ~ 10)</span>
<span class="sd">3-3. pq의 모든 상품을 다 돌았는데도 불구하고, 판매가능한 상품이 없으면, -1를 출력하고, 관리 목록에서 제거하지 않는다. </span>


<span class="sd">5. 여행 상품의 출발지 변경 </span>
<span class="sd">- 여행 상품의 출발지를 전부 s로 변경 -&gt; 변경 이후에 각 상품의 cost_id가 변경될 수 있음에 유의 </span>
<span class="sd">- NOTE: `trip_lists`의 모든 Trip에 대해서 start_id와 cost를 변경해서 pq안에서 정렬이 바뀔 수 있도록 해야한다. </span>
<span class="sd">    - 새로 삽입될 때 비교를 해서 넣고, 해당 class안의 variable들을 바꿨다고 우선순위가 변할 것 같지 않음 </span>
<span class="sd">    - 새로 만들때 log(30000) = O(10)</span>
<span class="sd">    - 새로 만들고 기존 변수명에 다시 복사하는 방식을 사용해야함. global 및 [:] 슬라이싱사용. </span>
<span class="sd">- 출발지가 바뀌는 경우, cost를 쉽게 계산하는 법 </span>
<span class="sd">    - dijkstra는 greedy algorithm으로 O(E)로 계산 가능 : 이걸로 최대 15번이니까 15*O(Elog(V))</span>
<span class="sd">    - floyd warshall algorithm은 한번에 2D matrix 계산 O(N^3)이 걸림 </span>
<span class="sd">- NOTE: 새로 변한 start_id에 대해 이후에 command `200`이 나오는 경우에 새로운 `start_id`에 대하여 Trip의 cost등을 계산해야하므로 이를 global variable로 관리해준다. </span>

<span class="sd">- 해당 명령은 최대 15번 주어진다. 0&lt;=s&lt;=n-1 인데, n은 최대 2000개지만, s는 15번만 바뀐다. </span>
<span class="sd">- s가 바뀌면 그에 따른 최단거리도 달라진다. -&gt; Trip의 cost , start_id 가 변해야함. </span>
<span class="sd">- shortest_distance: dict[int, list[int]] 를 저장하는 데이터 구조 필요 -&gt; Trip의 cost는 shortest_distance[start_id][dest_id]로 저장 </span>
<span class="sd">- Dijkstra algorithm을 최대 15번 진행한다고 하면, O(15*(2000+10000)* log(2000)) = 1.3 * 1e6</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span> 
<span class="nb">print</span><span class="p">(</span><span class="mi">12000</span><span class="o">*</span><span class="mi">15</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2000</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">solution</p>
<p>만약 풀리지 않는 test case가 있다면 각 cmd마다 print를 해서 어느 부분이 틀렸는지 검토해보자.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span> 
<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 

<span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span>
<span class="c1"># sys.stdin = open(&#39;Input.txt&#39;)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">graph_init</span><span class="p">(</span><span class="n">num_edges</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="k">global</span> <span class="n">graph</span> 
    <span class="k">for</span> <span class="n">idx_2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">),</span> <span class="mi">3</span><span class="p">):</span>
        <span class="c1"># print(idx)</span>
        <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">edges</span><span class="p">[</span><span class="n">idx_2</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">idx_2</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">idx_2</span><span class="p">]</span>
        <span class="c1"># 자기자신 연결인 경우는 한번만 그래프에 추가 </span>
        <span class="n">graph</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">weight</span><span class="p">,</span> <span class="n">node2</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">node1</span> <span class="o">!=</span> <span class="n">node2</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">node2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">weight</span><span class="p">,</span> <span class="n">node1</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">dijkstra</span><span class="p">(</span><span class="n">start_node</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">shortest_path</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">N</span>
    <span class="c1"># shortest_path: dict[int, list] INIT </span>
    <span class="n">shortest_path</span><span class="p">[</span><span class="n">start_node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">MAX</span><span class="p">]</span><span class="o">*</span> <span class="n">N</span>
    <span class="n">shortest_path</span><span class="p">[</span><span class="n">start_node</span><span class="p">][</span><span class="n">start_node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># INIT at start_node </span>
    <span class="n">q</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start_node</span><span class="p">)]</span> <span class="c1"># (dis, start_node)</span>

    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">cur_dis</span><span class="p">,</span> <span class="n">cur_node</span> <span class="o">=</span>  <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="c1"># min_heap on the first dis element </span>

        <span class="c1"># 1. is already visited?</span>
        <span class="k">if</span> <span class="n">cur_dis</span> <span class="o">&gt;</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">start_node</span><span class="p">][</span><span class="n">cur_node</span><span class="p">]:</span>
            <span class="k">continue</span> 
        
        <span class="c1"># 2. explore next nodes in the graph</span>
        <span class="k">for</span> <span class="n">weight</span><span class="p">,</span> <span class="n">nxt_node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">cur_node</span><span class="p">]:</span>
            <span class="n">dis</span> <span class="o">=</span> <span class="n">cur_dis</span> <span class="o">+</span> <span class="n">weight</span>
            <span class="k">if</span>  <span class="n">dis</span> <span class="o">&lt;</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">start_node</span><span class="p">][</span><span class="n">nxt_node</span><span class="p">]:</span>
                <span class="n">shortest_path</span><span class="p">[</span><span class="n">start_node</span><span class="p">][</span><span class="n">nxt_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">dis</span> 
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="n">dis</span><span class="p">,</span> <span class="n">nxt_node</span><span class="p">))</span>
    <span class="c1"># print(shortest_path)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process_400</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">trip_pq</span>

    <span class="k">while</span> <span class="n">trip_pq</span><span class="p">:</span>
        <span class="n">cur_trip</span> <span class="o">=</span> <span class="n">trip_pq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># 이미 cmd[0]== 300에 의해 삭제된 여행 상품인지 확인</span>
        <span class="c1"># lazy deletion  </span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exist_trip_id</span><span class="p">[</span><span class="n">cur_trip</span><span class="o">.</span><span class="n">id</span><span class="p">]:</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">trip_pq</span><span class="p">)</span>
            <span class="k">continue</span> 

        <span class="c1"># 존재하는 상품이면, 판매 불가 상품인지 확인 </span>
        <span class="k">if</span> <span class="n">cur_trip</span><span class="o">.</span><span class="n">get_cost</span><span class="p">()</span> <span class="o">==</span> <span class="n">MAX</span> <span class="ow">or</span> <span class="n">cur_trip</span><span class="o">.</span><span class="n">get_benefit</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 위의 조건을 다 만족하면, id를 출력한 뒤 관리 목록에서 제거 </span>
            <span class="nb">print</span><span class="p">(</span><span class="n">cur_trip</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">trip_pq</span><span class="p">)</span>
            <span class="c1"># NOTE: 해당 관리 목록에서 삭제해줘야함!!</span>
            <span class="n">exist_trip_id</span><span class="p">[</span><span class="n">cur_trip</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> 
    
    <span class="c1"># trip_pq에 아무원소도 없을 경우 </span>
    <span class="nb">print</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        
<span class="c1"># --------------- 전역 스코프 </span>
<span class="n">Q</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="c1"># 데이터 구조 INIT </span>
<span class="n">MAX</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>
<span class="n">shortest_path</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">trip_pq</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;Trip&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> 
<span class="n">exist_trip_id</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">cur_start_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># graph 는 아래서 </span>
<span class="k">class</span><span class="w"> </span><span class="nc">Trip</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">revenue</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dest_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">start_id</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">revenue</span> <span class="o">=</span> <span class="n">revenue</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">dest_id</span> <span class="o">=</span> <span class="n">dest_id</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">start_id</span> <span class="o">=</span> <span class="n">start_id</span> <span class="c1"># 변할 수 있음. </span>
        <span class="c1"># self.cost = MAX  # start 와 dest을 알면 shortest_path에 바로 접근해서 알 수 있고, 아래 get_benefit() 함수에서 그걸 구현해놓음. </span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">my_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_benefit</span><span class="p">()</span>
        <span class="n">other_b</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_benefit</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">my_b</span> <span class="o">==</span> <span class="n">other_b</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span> 
        <span class="k">return</span> <span class="n">my_b</span> <span class="o">&gt;</span> <span class="n">other_b</span> 
    
    <span class="k">def</span><span class="w"> </span><span class="nf">get_benefit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># Revenue - current_cost </span>
        <span class="k">global</span> <span class="n">shortest_path</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_id</span> <span class="ow">in</span> <span class="n">shortest_path</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">revenue</span> <span class="o">-</span> <span class="n">shortest_path</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start_id</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">dest_id</span><span class="p">]</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">get_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">global</span> <span class="n">shortest_path</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_id</span> <span class="ow">in</span> <span class="n">shortest_path</span> 
        <span class="k">return</span> <span class="n">shortest_path</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start_id</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">dest_id</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Trip(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">)&quot;</span>
    
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="p">):</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
    <span class="c1"># if cmd == [300, 3]:</span>
    <span class="c1">#     print(&#39;a&#39;)</span>
    <span class="k">if</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">100</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">M</span><span class="o">=</span><span class="n">cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
        <span class="n">exist_trip_id</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="mi">30001</span>
        <span class="n">graph_init</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span> <span class="c1"># m, [node1, end1, weight1,... ]</span>
        <span class="c1"># print(graph)</span>
        <span class="n">dijkstra</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># start node= 0 </span>
        <span class="c1"># print(shortest_path)</span>

    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">trip_pq</span><span class="p">,</span> <span class="n">Trip</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">revenue</span><span class="o">=</span><span class="n">cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">dest_id</span><span class="o">=</span><span class="n">cmd</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">start_id</span><span class="o">=</span><span class="n">cur_start_id</span><span class="p">))</span>
        <span class="n">exist_trip_id</span><span class="p">[</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># 해당 여행이 존재 </span>
        <span class="c1"># print(f&quot;Add Trip {cmd[1]}&quot;)</span>
        <span class="c1"># print(f&quot;  trip_pq: {trip_pq}&quot;)</span>
        <span class="c1"># print(f&quot;  exist_trip: {exist_trip_id[cmd[1]]}&quot;)</span>

    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">300</span><span class="p">:</span>
        <span class="n">cur_id</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">exist_trip_id</span><span class="p">[</span><span class="n">cur_id</span><span class="p">]:</span> <span class="c1"># 존재하면 </span>
            <span class="n">exist_trip_id</span><span class="p">[</span><span class="n">cur_id</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span> 

        <span class="c1"># print(f&quot;Delete Trip {cur_id}&quot;)</span>
        <span class="c1"># print(f&quot;  trip_pq: {trip_pq}&quot;)</span>
        <span class="c1"># print(f&quot;  exist_trip: {exist_trip_id[cur_id]}&quot;)</span>


    <span class="c1"># 최적의 여행 상품 판매 </span>
    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">400</span><span class="p">:</span>
        <span class="c1"># print(f&quot;여행 상품 판매&quot;)</span>
        <span class="n">process_400</span><span class="p">()</span>
        <span class="c1"># print(f&quot;  trip_pq: {trip_pq}&quot;)</span>



    <span class="c1"># 여행 상품의 출발지 변경 </span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># cmd[0] == 500:</span>
        <span class="c1"># print(f&quot;-------출발지 변경&quot;)</span>
        <span class="c1"># print(f&quot;before: {trip_pq}&quot;)</span>
        <span class="c1">##### global로 start_id 를 변경해줘야 나중에 200으로 들어왔을 때, 해당 start_id에 대해 task가 정렬됨. </span>
        <span class="n">cur_start_id</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">new_trip_pq</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># 1. 새로운 출발점에 대한 shortest_path 계산 먼저 해야 cost 계산에 의해 heapq에서 정렬됨. </span>
        <span class="n">dijkstra</span><span class="p">(</span><span class="n">cur_start_id</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cur_trip</span> <span class="ow">in</span> <span class="n">trip_pq</span><span class="p">:</span>
            <span class="c1"># 여기서도 lazy deletion해준다. </span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">exist_trip_id</span><span class="p">[</span><span class="n">cur_trip</span><span class="o">.</span><span class="n">id</span><span class="p">]:</span>
                <span class="k">continue</span> 
            <span class="n">cur_trip</span><span class="o">.</span><span class="n">start_id</span> <span class="o">=</span> <span class="n">cur_start_id</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">new_trip_pq</span><span class="p">,</span> <span class="n">cur_trip</span><span class="p">)</span>

        <span class="n">trip_pq</span> <span class="o">=</span> <span class="n">new_trip_pq</span><span class="p">[:]</span>
        <span class="c1"># debug </span>
        <span class="c1"># print(f&quot;start node {cur_start_id}: {trip_pq}&quot;)</span>
        <span class="c1"># print([exist_trip_id[cur_trip.id] for cur_trip in trip_pq])</span>
        <span class="c1"># print(f&quot;-------출발지 변경 끝&quot;)</span>
</pre></div>
</div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./_pages/practice"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="4_DPPS.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">이전</p>
        <p class="prev-next-title">Lecture 4-2. DP 실습</p>
      </div>
    </a>
    <a class="right-next"
       href="11_linked_listPS.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">다음</p>
        <p class="prev-next-title">Lecture 11-2. Linked List</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> 내용
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">가로등 설치</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">코드 트리 채점기</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">코드 트리 투어</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
으로 Daye Lee
</p>

  </div>
  
  <div class="footer-item">
    

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>