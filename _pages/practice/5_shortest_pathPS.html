
<!DOCTYPE html>


<html lang="ko" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Lecture 5-2. Shortest Path &amp; Heap &#8212; 말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css?v=6644e6bb" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/proof.css?v=b4b7a797" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=8127ecf8" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=ae323b5b"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="../../_static/translations.js?v=e33e7ba0"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_pages/practice/5_shortest_pathPS';</script>
    <script src="https://unpkg.com/jupyterquiz@1.1.8/dist/jupyterquiz.min.js"></script>
    <link rel="icon" href="../../_static/favicon.png"/>
    <link rel="index" title="색인" href="../../genindex.html" />
    <link rel="search" title="검색" href="../../search.html" />
    <link rel="next" title="Lecture 6-2. Sorting" href="6_sortPS.html" />
    <link rel="prev" title="Lecture 4-2. DP 실습" href="4_DPPS.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="ko"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/mylogo.png" class="logo__image only-light" alt="말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업 - Home"/>
    <script>document.write(`<img src="../../_static/mylogo.png" class="logo__image only-dark" alt="말레이시아 5급 학생들을 위한 파이썬 알고리즘 수업 - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="검색" aria-label="검색" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">검색</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Welcome to 말레이시아 5급 IT 수업
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">기초</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../basics/Input.html">입력</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basics/oop.html">객체 지향 프로그래밍 (OOP)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basics/oop-classes_instances_objects.html">클래스, 인스턴스, 객체</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basics/regex.html">정규표현식</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basics/variable_scope.html">Variable Scope</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">이론</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../theory/0_tips.html">문제 풀이 순서 팁 (Tips)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/1_implementation.html">Lecture 1-1. 구현</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/2_DFS_BFS.html">Lecture 2-1. DFS/BFS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/3_backtracking.html">Lecture 3-1. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/4_DP.html">Lecture 4-1. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/5_shortest_path.html">Lecture 5-1. Shortest Path</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/6_sort.html">Lecture 6-1. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/7_binarysearch.html">Lecture 7-1. Binary Search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/8_graph.html">Lecture 8-1. Graph Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/9_greedy.html">Lecture 9-1. Greedy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/10_prefix.html">Lecture 10-1. Prefix Sum (누적 합)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/11_LinkedList.html">Lecture 11-1. Linked List</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">실습</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="1_implementationPS.html">Lecture 1-2. 구현 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_DFS_BFSPS.html">Lecture 2-2. DFS/BFS 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_backtrackingPS.html">Lecture 3-2. Backtracking 실습</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_DPPS.html">Lecture 4-2. DP 실습</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Lecture 5-2. Shortest Path &amp; Heap</a></li>
<li class="toctree-l1"><a class="reference internal" href="6_sortPS.html">Lecture 6-2. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_linked_listPS.html">Lecture 11-2. Linked List</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">시험</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../exams/midterm_student.html">Midterm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../exams/final_student.html">Final</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="이 페이지 다운로드">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/_pages/practice/5_shortest_pathPS.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="소스 파일 다운로드"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="PDF로 인쇄"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="전체 화면으로보기"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="검색" aria-label="검색" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Lecture 5-2. Shortest Path & Heap</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> 내용 </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#priority-queue-kit">Priority Queue, 고득점 Kit</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">더 맵게</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">디스크 컨트롤러</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">이중우선순위큐</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#priority-queue">Priority Queue</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">가로등 설치</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">코드 트리 채점기</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">코드 트리 투어</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">해적 선장 코디</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#dijkstra">Dijkstra</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">개구리의 여행</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reachable-nodes-in-subdivided-graph">Reachable Nodes In Subdivided Graph</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#second-minimum-time-to-reach-destination">Second Minimum  Time to Reach Destination</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#minimum-weighted-subgraph-with-the-required-paths">Minimum Weighted Subgraph With the Required Paths</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="lecture-5-2-shortest-path-heap">
<h1>Lecture 5-2. Shortest Path &amp; Heap<a class="headerlink" href="#lecture-5-2-shortest-path-heap" title="Link to this heading">#</a></h1>
<div class="dropdown admonition">
<p class="admonition-title">Heap vs. sort</p>
<p>Shortest path를 dijkstra로 찾는 과정에서 우리는 heapq 라이브러리를 사용하여 priority queue구조에 대하여 배웠었다. priority queue는 sort()와 다르게, ‘최대/최소’값을 반복적으로 찾아야하는 문제에서 가장 효과적이다. 특히, 데이터가 실시간으로 나갔다 들어오는 경우 Sort()보다 더 유용하다.</p>
<p>sort()와 min-heap은 오름차순으로 두면, “매번 현재 가장 싼 간선”을 선택하므로 정확성은 동일하다. 또한 시간 복잡도는</p>
<ul class="simple">
<li><p>정렬: O(E logE)</p></li>
<li><p>min-heap: heapify O(E) + E번 pop (logE씩) -&gt; O(ElogE)
위와 같이 이론상 동일하지만, 실무에서는 정렬이 상수항이 더 작고 캐시 친화적이라 빠른 일이 많다. (Timsort). 반면 min-heap은 매 pop마다 log 비용이 들어서 오히려 느릴 수 있다.</p></li>
</ul>
<p>또한 메모리 측면에서 둘 다 간선 E개 저장이 필요하므로 O(E)로 동일.</p>
<p>보통의 경우 sort()를 사용하고, min-heap은 다음과 같은 특수 상황에서 사용하면 효율적이다.</p>
<ul class="simple">
<li><p>간선이 스트리밍으로 들어오거나 한번에 다 만들기 어려운 상황 (외부 입력/온라인 처리)</p></li>
<li><p>가장 싼 간선부터 일부만 처리하며 조기 종료가 확실한 특수 케이스</p></li>
</ul>
</div>
<p>예시 문제 링크</p>
<ul class="simple">
<li><p>Priority Queue 고득점 Kit</p>
<ul>
<li><p><a class="reference external" href="https://school.programmers.co.kr/learn/courses/30/lessons/42626">더 맵게</a></p></li>
<li><p><a class="reference external" href="https://school.programmers.co.kr/learn/courses/30/lessons/42627">디스크 컨트롤러</a></p></li>
<li><p><a class="reference external" href="https://school.programmers.co.kr/learn/courses/30/lessons/42628">이중우선순위큐</a></p></li>
</ul>
</li>
<li><p>Priority Queue</p>
<ul>
<li><p><a class="reference external" href="https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/street-light-installation/description">가로등 설치</a></p></li>
<li><p><a class="reference external" href="https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/codetree-judger/description">코드 트리 채점기</a></p></li>
<li><p><a class="reference external" href="https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/codetree-tour/description">코드트리 투어</a></p></li>
<li><p><a class="reference external" href="https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/pirate-captain-coddy/description">해적 선장 코디</a></p></li>
<li><p><a class="reference external" href="https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/rabit-and-race/description">토끼와 경주</a></p></li>
</ul>
</li>
<li><p>Dijkstra</p>
<ul>
<li><p><a class="reference external" href="https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/frog-journey/description">개구리의 여행</a></p></li>
<li><p><a class="reference external" href="https://leetcode.com/problems/reachable-nodes-in-subdivided-graph/description/?envType=problem-list-v2&amp;amp;envId=shortest-path">Reachable Nodes in Subdivided Graph</a></p></li>
<li><p><a class="reference external" href="https://leetcode.com/problems/second-minimum-time-to-reach-destination/description/?envType=problem-list-v2&amp;amp;envId=shortest-path">Second Minimum Time to Reach Destination</a></p></li>
<li><p><a class="reference external" href="https://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/?envType=problem-list-v2&amp;amp;envId=shortest-path">Minimum Weighted Subgraph With the Required Paths</a></p></li>
</ul>
</li>
</ul>
<section id="priority-queue-kit">
<h2>Priority Queue, 고득점 Kit<a class="headerlink" href="#priority-queue-kit" title="Link to this heading">#</a></h2>
<section id="id1">
<h3>더 맵게<a class="headerlink" href="#id1" title="Link to this heading">#</a></h3>
<p>Idea:</p>
<ol class="arabic simple">
<li><p>처음 원소의 개수가 짝수이든, 홀수이든 마지막에는 1개의 원소만 남게 된다. 따라서, 계속 진행되었을 때 남아있는 두 개의 원소 중 하나라도 K보다 크면 answer을 내놓으면 됨.</p>
<ol class="arabic simple">
<li><p>또한 answer=0이고, 첫 리스트가 1개만 남아있는 경우도 있으므로, 이를 위해 len(cur_scoville_list) == 1 인 경우를 위해, <code class="docutils literal notranslate"><span class="pre">while</span></code>조건에 맨 처음 원소가 &gt;= K임을 명시한다.</p></li>
<li><p>따라서, <code class="docutils literal notranslate"><span class="pre">while</span></code>조건에는 K보다 작은 원소들이 존재하는 경우에만 새로 음식을 섞는 작업을 진행한다.</p></li>
</ol>
</li>
<li><p>처음 scoville_pq를 초기화시킬 때, <code class="docutils literal notranslate"><span class="pre">heappush()</span></code> 로 초기화하였기 때문에, 모든 원소가 priority queue의 기준에 따라 정렬되었고 추후에 해당 priority queue에 들어오는 원소들은 당연히 기존 원소들보다 크기 때문에</p>
<ul class="simple">
<li><p>제일 작은 원소 1+1*2 = 3 이므로, 원소가 [1, 1, 2] 였다고 하더라도 heapush()로 삽입되기 때문에, 정렬상 작은 원소가 제일 앞에 있게 된다.</p></li>
<li><p>for loop으로 heappush로 초기화하면 O(NlogN)이 걸리고, (for loop을 돌면서 heapush())</p></li>
<li><p>heapify를 하면, O(n)이 걸린다. 배열을 트리 형태로 보고 아래에서 위로 정리</p></li>
<li><p>따라서, python에서는 <code class="docutils literal notranslate"><span class="pre">heapify()</span></code>를 쓰는 것이 훨씬 빠르다.</p></li>
</ul>
</li>
</ol>
<div class="dropdown admonition">
<p class="admonition-title">Solution</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">solution</span><span class="p">(</span><span class="n">scoville</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">K</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="c1"># INIT</span>
    <span class="c1"># `scoville` list의 정보를 최소 힙으로 변환, 이것은 아래처럼 O(N)으로 할수도 있고, heapify 함수를 사용해서 할수도 있다. </span>
    <span class="c1"># for idx, each_s in enumerate(scoville):</span>
    <span class="c1">#     heapq.heappush(scoville_pq, (each_s, idx))</span>
    <span class="c1">#     id_to_scoville.append(each_s)</span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heapify</span><span class="p">(</span><span class="n">scoville</span><span class="p">)</span> <span class="c1"># O(N)</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 연산 횟수 </span>
        
    <span class="c1"># 알고리즘 시작 </span>
    <span class="k">while</span> <span class="n">scoville</span> <span class="ow">and</span> <span class="n">scoville</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">:</span>
        
        <span class="c1"># 더 이상 두 개를 섞을 수 없으면 실패 </span>
        <span class="c1"># 예) [1,2] -&gt; [5] 로 마지막에는 항상 한 개 만 남음 </span>
        <span class="c1"># 예) 애초에 음식이 1개인데, K보다 작은 경우 </span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scoville</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> 
        
        <span class="c1"># Step 1. 총 두 개의 음식 꺼내기 </span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">scoville</span><span class="p">)</span>
        <span class="n">second</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">scoville</span><span class="p">)</span>

        <span class="c1"># NOTE: </span>
        <span class="c1"># 1. scoville_pq의 모든 원소는 모두 priority queue형식으로 push되었고</span>
        <span class="c1"># 2. 미래에 들어오는 원소들은 항상 클것이므로, 가장 작은 원소가 맨 앞에 있는 것이 진리임</span>
        <span class="c1"># 따라서, 혹시 모를 작은 원소때문에 lazy deletion 필요 없음. </span>
        <span class="n">new_s</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">second</span> 
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">scoville</span><span class="p">,</span> <span class="n">new_s</span><span class="p">)</span> <span class="c1"># 새로운 음식의 id = len(id_to_scoville)</span>
        <span class="n">answer</span> <span class="o">+=</span> <span class="mi">1</span> 
    <span class="k">return</span> <span class="n">answer</span> <span class="c1"># 위의 실패 경우를 제외하면, answer를 반환 </span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">scoville</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">];</span> <span class="n">K</span><span class="o">=</span><span class="mi">7</span> <span class="c1"># 2 </span>
    <span class="c1"># scoville = [1, 1]; K=7</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">solution</span><span class="p">(</span><span class="n">scoville</span><span class="o">=</span><span class="n">scoville</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="n">K</span><span class="p">))</span>
</pre></div>
</div>
</div>
</section>
<section id="id2">
<h3>디스크 컨트롤러<a class="headerlink" href="#id2" title="Link to this heading">#</a></h3>
<div class="dropdown admonition">
<p class="admonition-title">틀린 정답</p>
<p>아래 코드의 문제점은 task_pq는 모든 작업을 가지고 있고, 작업의 요청시간이 현재 시간보다 클때에만 해당 task 작업을 진행하게 되어 있음.
이의 문제점은, 현재 작업이 안된 작업들 중 cur_time보다 request_time 들이 다 높아서, 요청 시간이 가장 작은 task를 꺼내야할 때 문제가 됨.
task_pq는 요청 시간이 아닌 소요 시간이 가장 짧은 테스크를 min-heap으로 저장해놓았기 때문에 해당 task를 뽑을 수 없음.</p>
<p>또한, O(N^2log(N))이 걸림. 왜냐하면 <code class="docutils literal notranslate"><span class="pre">unused_task</span></code>를 따로 관리하며, 안 쓰는 것을 넣었다가 빼기 때문임.</p>
<p>-&gt; 이러한 문제점들을 위해서,도착한 작업만 pq에 넣고 + pq가 비면 다음 요청 시각으로 time 점프를 하는 것을 지켜주면 된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span> 
<span class="kn">from</span><span class="w"> </span><span class="nn">heapq</span><span class="w"> </span><span class="kn">import</span> <span class="n">heappush</span><span class="p">,</span> <span class="n">heappop</span> 

<span class="k">class</span><span class="w"> </span><span class="nc">Task</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">request_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">time_used</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">request_time</span> <span class="o">=</span> <span class="n">request_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_used</span> <span class="o">=</span> <span class="n">time_used</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_used</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">time_used</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_used</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">time_used</span> 
    
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_turnaround</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">request_time</span> 
    
<span class="k">class</span><span class="w"> </span><span class="nc">History</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">task_id</span> <span class="o">=</span> <span class="nb">id</span> 
    

<span class="k">def</span><span class="w"> </span><span class="nf">solution</span><span class="p">(</span><span class="n">jobs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    1 &lt;= jobs.length &lt;= 500</span>
<span class="sd">    jobs[i] = [s, l] = [작업 요청 시점, 작업 소요시간]</span>

<span class="sd">    최대 N=500, 3NlogN ~ 1e4 </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># 필요한 자료구조 INIT </span>
    <span class="n">task_pq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">is_harddisk_used</span> <span class="o">=</span> <span class="n">History</span><span class="p">()</span> <span class="c1"># History, task_id being processed </span>
    <span class="n">task_id_to_object_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># O(NlogN)</span>
    <span class="k">for</span> <span class="nb">id</span><span class="p">,</span> <span class="n">job</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">jobs</span><span class="p">):</span>
        <span class="n">cur_task</span> <span class="o">=</span> <span class="n">Task</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">job</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">job</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># object sharing </span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">task_pq</span><span class="p">,</span> <span class="n">cur_task</span><span class="p">)</span> <span class="c1"># jobs.heapify를 하고 싶어도, 단일 정수가 아니라 어려울 듯. </span>
        <span class="n">task_id_to_object_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_task</span><span class="p">)</span> 
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    아이디어: </span>
<span class="sd">    - pq에 모든 작업을 넣어두고, 매번 &quot;현재 시간까지 도착한 작업들 중에서&quot; 수행할 수 있는 최단 작업을 찾으려고</span>
<span class="sd">    pq를 쭉 빼면서 request_time &lt;= cur_time인 task를 만날때까지 탐색 </span>
<span class="sd">    - 아직 도착 안 한 것들은 unused_tasks에 모았다가 다시 pqd에 넣기 </span>
<span class="sd">    - 시간 복잡도: 최악 O(N^2 log(N))</span>

<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">cur_time</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_turnaround_time</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">task_pq</span><span class="p">:</span> <span class="c1"># 최악 N번 </span>
        <span class="c1"># 1-1. 하드디스크가 사용 중이면, 작업을 끝냄 / 하드디스크가 사용중이 아님 (맨 처음)</span>
        <span class="k">if</span> <span class="n">is_harddisk_used</span><span class="o">.</span><span class="n">task_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">is_harddisk_used</span><span class="o">.</span><span class="n">end_time</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">cur_id</span> <span class="o">=</span> <span class="n">is_harddisk_used</span><span class="o">.</span><span class="n">task_id</span> 
            <span class="n">cur_task</span> <span class="o">=</span> <span class="n">task_id_to_object_list</span><span class="p">[</span><span class="n">cur_id</span><span class="p">]</span>
            <span class="n">cur_time</span> <span class="o">=</span> <span class="n">cur_task</span><span class="o">.</span><span class="n">start_time</span> <span class="o">+</span> <span class="n">cur_task</span><span class="o">.</span><span class="n">time_used</span> 
            <span class="c1"># 작업 끝냄 (end time 갱신)</span>
            <span class="n">cur_task</span><span class="o">.</span><span class="n">end_time</span> <span class="o">=</span> <span class="n">cur_time</span> 
            <span class="n">is_harddisk_used</span><span class="o">.</span><span class="n">end_time</span> <span class="o">=</span> <span class="n">cur_time</span> 
            <span class="c1"># 1-2. 작업을 끝냈다면, turnaround time 계산 </span>
            <span class="n">total_turnaround_time</span> <span class="o">+=</span> <span class="n">cur_task</span><span class="o">.</span><span class="n">calculate_turnaround</span><span class="p">()</span>

        <span class="c1"># 작업을 끝냄과 동시에 다른 작업 시작 가능 </span>
        <span class="c1"># 2-1. 현재 시간에서 요청이 된 task 중 (lazy validation) 우선순위가 가장 높은 task 선택</span>
        
        <span class="n">unused_tasks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># O(NlogN)</span>
        <span class="k">while</span> <span class="n">task_pq</span><span class="p">:</span> <span class="c1"># 최대 ~N</span>
            <span class="n">nxt_task</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">task_pq</span><span class="p">)</span> <span class="c1"># O(logN)</span>
            <span class="k">if</span> <span class="n">nxt_task</span><span class="o">.</span><span class="n">request_time</span> <span class="o">&lt;=</span> <span class="n">cur_time</span><span class="p">:</span> 
                <span class="c1"># 가능 </span>
                <span class="c1"># 2-2. 하드디스크가 처리하고 있는 정보 update </span>
                <span class="n">is_harddisk_used</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">cur_time</span> 
                <span class="n">is_harddisk_used</span><span class="o">.</span><span class="n">end_time</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 
                <span class="n">is_harddisk_used</span><span class="o">.</span><span class="n">task_id</span> <span class="o">=</span> <span class="n">nxt_task</span><span class="o">.</span><span class="n">id</span> 
                <span class="n">task_id_to_object_list</span><span class="p">[</span><span class="n">nxt_task</span><span class="o">.</span><span class="n">id</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">cur_time</span> 
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#  현재 요청안된 task </span>
                <span class="n">unused_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nxt_task</span><span class="p">)</span>
        
        <span class="c1"># 3. task_pq에서 제거하였으나, 아직 사용안된 task들 다시 넣어주기 </span>
        <span class="c1"># O(NlogN)</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">unused_tasks</span><span class="p">:</span>
            <span class="n">heappush</span><span class="p">(</span><span class="n">task_pq</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>

        <span class="c1"># 현재 시간대에 cur_Time을 위로 늘려줘야만 함. </span>
        <span class="c1"># 도착시간이 가장 빠른 작업을 골라야하는데, task_pq에는 소요 시간이 가장 짧은 작업이 들어있음. </span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unused_tasks</span><span class="p">)</span> <span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">unused_tasks</span><span class="p">)</span><span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">task_pq</span><span class="p">):</span>
            <span class="n">cur_task</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">task_pq</span><span class="p">)</span>
            <span class="n">cur_time</span> <span class="o">=</span> <span class="n">cur_task</span><span class="o">.</span><span class="n">request_time</span> 
            <span class="n">is_harddisk_used</span><span class="o">.</span><span class="n">task_id</span> <span class="o">=</span> <span class="n">cur_task</span><span class="o">.</span><span class="n">id</span>
            <span class="n">is_harddisk_used</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">cur_time</span> 
            <span class="n">cur_task</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">cur_time</span> 
            <span class="n">is_harddisk_used</span><span class="o">.</span><span class="n">end_time</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 
    <span class="c1"># while 문에서 마지막 task작업에 대해서 끝마치기 </span>
    <span class="k">if</span> <span class="n">is_harddisk_used</span><span class="o">.</span><span class="n">task_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">is_harddisk_used</span><span class="o">.</span><span class="n">end_time</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">cur_id</span> <span class="o">=</span> <span class="n">is_harddisk_used</span><span class="o">.</span><span class="n">task_id</span> 
        <span class="n">cur_task</span> <span class="o">=</span> <span class="n">task_id_to_object_list</span><span class="p">[</span><span class="n">cur_id</span><span class="p">]</span>
        <span class="n">cur_time</span> <span class="o">=</span> <span class="n">cur_task</span><span class="o">.</span><span class="n">start_time</span> <span class="o">+</span> <span class="n">cur_task</span><span class="o">.</span><span class="n">time_used</span> 
        <span class="c1"># 작업 끝냄 (end time 갱신)</span>
        <span class="n">cur_task</span><span class="o">.</span><span class="n">end_time</span> <span class="o">=</span> <span class="n">cur_time</span> 
        <span class="n">is_harddisk_used</span><span class="o">.</span><span class="n">end_time</span> <span class="o">=</span> <span class="n">cur_time</span> 
        <span class="c1"># 1-2. 작업을 끝냈다면, turnaround time 계산 </span>
        <span class="n">total_turnaround_time</span> <span class="o">+=</span> <span class="n">cur_task</span><span class="o">.</span><span class="n">calculate_turnaround</span><span class="p">()</span>

    
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">total_turnaround_time</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">jobs</span><span class="p">))</span> <span class="c1"># turnaround평균의 &quot;정수 부분&quot;을 출력, 버림</span>
        


    
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># jobs = [[0, 3], [1, 9], [3, 5]] # 8</span>
    <span class="c1"># jobs = [[0, 3], [4, 3]] # 8</span>
    <span class="n">jobs</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span><span class="c1"># 9</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">solution</span><span class="p">(</span><span class="n">jobs</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">Idea</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&#39;&#39;&#39;
- 단 &#39;하나의&#39; 하드디스크를 가지고 있음. 
- 우선순위 디스크 컨트롤러 구현 

1. 자료구조 큐: 작업 요청이 들어왔을 때 (작업 번호, 요청 시각, 작업 소요 시간) 저장
    - 필요한 자료구조 
        - priority queue (task_pq): request_time이 현재 시간보다 작은 작업들을 넣어야함. 
        - jobs.sort()후 현재 시간이 request_time보다 작은 idx를 저장하고 있음. 
2. 하드디스크가 작업을 하고 있지 않고, 대기 큐가 비어있지 않으면 우선순위가 가장 높은 작업을 대기 큐에서 꺼내서 하드디스크에 작업을 시킴
    - 우선순위 
        - 작업의 소요시간이 가장 짧은 것 
        - 작업의 번호가 가장 작은 것 (작업 id는 request_time이 작으면 됨.)
    - 필요한 자료구조 
        - 하드디스크의 작업 여부 is_harddisk_used[harddisk_id] = -1 (False) / True (하드디스크가 작업하는 Task id)
        - Task class (번호, 요청 시각, 작업 소요시간, 작업 시작 시간, end시간, __lt__ 함수  , turnaround 계산 함수 

3. 하드디스크는 작업을 한 번 시작하면 작업을 마칠 때까지 그 작업만 수행 
    - 필요한 자료구조 
        - 하드디스크 id - History class (task_id, 시작 시간, end 시간)

4. 하드디스크가 어떤 작업을 마치는 시점과 다른 작업 요청이 들어오는 시점이 &quot;겹치면&quot; 하드디스크가 작업을 마치자마자 디스크 컨트롤러는 요청이 들어온
작업을 &quot;대기 큐&quot;에 저장한 뒤 우선순위가 높은 작업을 대기 큐에서 꺼내서 하드디스크에 그 작업을 시킨다. 
- 요청을 한 작업이 들어오고 그 같은 시점에 하드디스크가 작업이 끝나면 바로 다른 작업을 시작할 수 있다. 
    - 하드디스크가 작업을 하고 있는 중이면, -&gt; 끝나는 지점 history에 확인해서 반환시간 계산하기  
    - 작업이 끝나면 다음에 할 작업이 있는지 대기 큐에서 받으면 됨. 

5. 하드디스크가 어떤 작업을 마치는 &#39;시점&#39;에 다른 작업이 들어오지 않더라도 그 작업을 마치자마자 또 다른 작업을 시작할 수 있다. 
- 이 과정에서 걸리는 시간은 없다고 가정한다. 

Algorithm 
0. 필요한 자료구조 
- Task class, History class, task_pq 생성, 
- is_harddisk_used[harddisk_id] = -1 (False) / True (하드디스크가 작업하는 Task id), 
- 대기 큐 Task class에 한번에 저장해놓기 
- History class (task_id, 시작 시간, end 시간)

Algorithm 
    1. 현재 수행된 작업 개수(cnt) n이 원래 작업 개수보다 작은 경우에 아래 스텝을 계속 진행 
    2. 현재 jobs.sort()[idx] request_time &lt;= cur_time보다 작은 것들을 pq에 넣음 
    3. pq에서 가장 작은 것을 뺌 
        3-1. 만약 pq에 원소가 없다면, cur_time을 jobs.sort()에서 현재 idx.request_time의 값으로 대체 
    4. turnaround_time은 cur_time + required_time (소요시간) 이고 cur_time += required_time으로 업데이트 
&#39;&#39;&#39;

import math 
N = 500 

print(N*math.log(N)) # ~1e4 
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">Solution</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">solution</span><span class="p">(</span><span class="n">jobs</span><span class="p">):</span>
    <span class="c1"># 1. 요청 시간 기준으로 정렬 </span>
    <span class="n">jobs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># O(NlogN)</span>

    <span class="c1"># 필요한 자료 구조 </span>
    <span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># (작업 소요 시간, 요청 시간)</span>
    <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 현재 시각 </span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># jobs에서 아직 힙에 안 넣은 인덱스 </span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 처리한 작업 수 </span>
    <span class="n">total_time</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 요청 ~ 완료 시간 합 </span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">jobs</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="c1"># 2. 현재 시각까지 들어온 모든 job을 heap에 넣기 </span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        각 job은 딱 한 번 heap에 push 되고 (idx가 전역에서 위로만 움직임), 딱 한 번 pop 됨</span>
<span class="sd">        push, pop 각각 O(log N), N개에 대해 한 번씩 → O(N log N)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">jobs</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">time</span><span class="p">:</span>
            <span class="n">req</span><span class="p">,</span> <span class="n">dur</span> <span class="o">=</span> <span class="n">jobs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">dur</span><span class="p">,</span> <span class="n">req</span><span class="p">))</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span> 


        <span class="k">if</span> <span class="n">heap</span><span class="p">:</span>
            <span class="c1"># 3. 가장 작업 시간이 짧은 job을 처리 </span>
            <span class="n">dur</span><span class="p">,</span> <span class="n">req</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
            <span class="n">time</span> <span class="o">+=</span> <span class="n">dur</span>  <span class="c1"># 이 작업이 끝나는 시각 = 현재 시각 </span>
            <span class="n">total_time</span> <span class="o">+=</span> <span class="n">time</span><span class="o">-</span><span class="n">req</span> <span class="c1"># 요청 ~ 완료 시간 (turnaround)</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">jobs</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">total_time</span> <span class="o">//</span> <span class="n">n</span>
    
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># jobs = [[0, 3], [1, 9], [3, 5]] # 8</span>
    <span class="c1"># jobs = [[0, 3], [4, 3]] # 8</span>
    <span class="n">jobs</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span><span class="c1"># 9</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">solution</span><span class="p">(</span><span class="n">jobs</span><span class="p">))</span>
</pre></div>
</div>
</div>
</section>
<section id="id3">
<h3>이중우선순위큐<a class="headerlink" href="#id3" title="Link to this heading">#</a></h3>
<div class="dropdown admonition">
<p class="admonition-title">Explanation</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>이중 우선순위큐는 3가지 연산을 할 수 있다. 
1. &quot;I 숫자&quot; 
    - 큐에 주어진 숫자를 삽입 
    - 숫자는 음수일 수 있음. 
2. D 1 
    - 큐에서 최댓값 삭제 
    - 빈 큐에 데이터를 삭제하라는 연산이 주어질 경우, 해당 연산은 무시 
3. D -1 
    - 큐에서 최솟값 삭제 
    - 빈 큐에 데이터를 삭제하라는 연산이 주어질 경우, 해당 연산은 무시 


매개변수로 이중 우선순위 큐가 할 연산 operations이 주어질 때, 모든 연산을 처리한 후 큐가 비어있으면 [0,0], 
비어있지 않으면 [최댓값, 최솟값]을 return 하도록 solution 함수를 구현해라. 

1 &lt;= operations.length &lt;= 1_000_000 
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">Solution</p>
<p>만약, visited 리스트를 만들어서 False/True로 지연 삭제를 만들고 싶은 경우에는
visited = [False] * len(operations)를 하고
visited[i] = True 로 한다. 이때 id 숫자는 음수일 수 있으므로, id는 operation index (0, 1, 2, …)로 만들어준다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">heapq</span><span class="w"> </span><span class="kn">import</span> <span class="n">heappush</span><span class="p">,</span> <span class="n">heappop</span> 

<span class="c1"># 필요한 자료구조 </span>
<span class="n">min_heap</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">max_heap</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">does_id_exist</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># True/False </span>

<span class="k">def</span><span class="w"> </span><span class="nf">solution</span><span class="p">(</span><span class="n">operations</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">min_heap</span><span class="p">,</span> <span class="n">max_heap</span><span class="p">,</span> <span class="n">does_id_exist</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operations</span><span class="p">:</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;I&quot;</span><span class="p">:</span>
            <span class="n">heappush</span><span class="p">(</span><span class="n">min_heap</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">heappush</span><span class="p">(</span><span class="n">max_heap</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
            <span class="n">does_id_exist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        
        <span class="c1"># 최댓값 삭제 </span>
        <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;D&quot;</span> <span class="ow">and</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span>
            <span class="c1"># lazy deletion </span>
            <span class="k">while</span> <span class="n">max_heap</span><span class="p">:</span>
                <span class="n">cur_num</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">max_heap</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span> 
                <span class="k">if</span> <span class="n">cur_num</span> <span class="ow">in</span> <span class="n">does_id_exist</span><span class="p">:</span>
                    <span class="n">does_id_exist</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">cur_num</span><span class="p">)</span>
                    <span class="k">break</span>
        
        <span class="c1"># 최솟값 삭제 </span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># lazy deletion </span>
            <span class="k">while</span> <span class="n">min_heap</span><span class="p">:</span>
                <span class="n">cur_num</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">min_heap</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cur_num</span> <span class="ow">in</span> <span class="n">does_id_exist</span><span class="p">:</span>
                    <span class="n">does_id_exist</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">cur_num</span><span class="p">)</span>
                    <span class="k">break</span> 
    <span class="c1"># 모든 연산 처리후 가장 최신 업데이트에는 does_id_exist가 가지고 있음 </span>
    <span class="c1"># 큐가 비어있으면 [0,0]</span>
    <span class="c1"># 비어있지 않으면, [최댓값, 최솟값]을 return </span>
    <span class="n">does_id_exist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">does_id_exist</span><span class="p">)</span>
    <span class="n">does_id_exist</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span> <span class="c1"># ascending sort </span>
    <span class="k">return</span> <span class="p">[</span><span class="n">does_id_exist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">does_id_exist</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">if</span> <span class="n">does_id_exist</span> <span class="k">else</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="c1"># operations = [&quot;I 16&quot;, &quot;I -5643&quot;, &quot;D -1&quot;, &quot;D 1&quot;, &quot;D 1&quot;, &quot;I 123&quot;, &quot;D -1&quot;] # [0,0]</span>
<span class="n">operations</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;I -45&quot;</span><span class="p">,</span> <span class="s2">&quot;I 653&quot;</span><span class="p">,</span> <span class="s2">&quot;D 1&quot;</span><span class="p">,</span> <span class="s2">&quot;I -642&quot;</span><span class="p">,</span> <span class="s2">&quot;I 45&quot;</span><span class="p">,</span> <span class="s2">&quot;I 97&quot;</span><span class="p">,</span> <span class="s2">&quot;D 1&quot;</span><span class="p">,</span> <span class="s2">&quot;D -1&quot;</span><span class="p">,</span> <span class="s2">&quot;I 333&quot;</span><span class="p">]</span> <span class="c1"># [333, -45]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">solution</span><span class="p">(</span><span class="n">operations</span><span class="p">))</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="priority-queue">
<h2>Priority Queue<a class="headerlink" href="#priority-queue" title="Link to this heading">#</a></h2>
<p>우선순위에 대해서 맨 처음의 데이터를 Extract하거나 데이터의 출입이 잦은 경우, priority queue를 이용해 데이터를 관리한다.</p>
<section id="id4">
<h3>가로등 설치<a class="headerlink" href="#id4" title="Link to this heading">#</a></h3>
<div class="dropdown admonition">
<p class="admonition-title">전역변수</p>
<p>어떤 전역 변수를 사용할 것인지, 정리한후, 전역 변수를 한번에 INIT 해놓는다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 전역 변수 선언</span>
<span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
<span class="n">lamp_pos</span> <span class="o">=</span> <span class="kc">None</span>       <span class="c1"># 각 가로등의 위치 (ID -&gt; 위치)</span>
<span class="n">next_lamp_id</span> <span class="o">=</span> <span class="kc">None</span>   <span class="c1"># 각 가로등의 다음 가로등 ID (이중 연결 리스트 구현)</span>
<span class="n">prev_lamp_id</span> <span class="o">=</span> <span class="kc">None</span>   <span class="c1"># 각 가로등의 이전 가로등 ID (이중 연결 리스트 구현)</span>
<span class="n">roads</span> <span class="o">=</span> <span class="p">[]</span>            <span class="c1"># 도로 정보를 저장할 최대 힙</span>
<span class="n">lamp_pos_min_heap</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 가로등 위치를 저장할 최소 힙 (가장 왼쪽 가로등 탐색용)</span>
<span class="n">lamp_pos_max_heap</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 가로등 위치를 저장할 최대 힙 (가장 오른쪽 가로등 탐색용)</span>
</pre></div>
</div>
<p>참고로, <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">&quot;__main__&quot;</span></code>은 함수 내부가 아니라 전역 스코프안에 있는 조건문이라 전역 스코프 (global scope)에 해당한다. 따라서, 이 안에서 <code class="docutils literal notranslate"><span class="pre">global</span></code>을 사용하면 문법 오류가 난다.</p>
</div>
<div class="dropdown admonition">
<p class="admonition-title">Lazy Deletion</p>
<p><em><strong>지연 갱신(Lazy Deletion)</strong></em> 이란, 힙에서 특정 원소를 찾아 삭제할때 바로 삭제하지 않고 오래된 정보를 그냥 두되, 힙에서 원소를 꺼낼 때마다 “이 정보가 현재 유효한가?”를 검사하는 것이다. 즉, 해당 문제에서 가로등이 제거되면, 그와 관련된 도로나 위치 정보가 힙에 여전히 남아있게 되는데, 힙에서 특정 원소를 찾아 삭제하는 것이 비효율적이므로 힙에서 꺼낼 때 정보가 유효한지 확인하는 것이다. 유효하지 않다면 버리고 다음 원소를 꺼내는 방식으로 처리하면, 전체적인 효율성을 유지하면서 로직을 간단하게 만들 수 있다.</p>
<p>dijkstra algorithm의 개선된 코드 버전에서 현재 꺼낸 노드로 가는 비용이 최소가 아니면 skip하는 로직과 동일하다.</p>
<p>해당 문제에서는 <code class="docutils literal notranslate"><span class="pre">lamp_pos</span></code> 리스트에 각 가로등의 ID를 인덱스로 하여 위치 (pos)를 저장한다. 따라서 O(1)시간에 특정 가로등의 위치를 조회할 수 있다. 가로등이 제거되면 해당 위치를 -1와 같은 무효한 값으로 표시하여 ‘지연 갱신’에 사용된다.</p>
<p>예를 들어, 두 가로등 사이에 다른 가로등이 추가되거나 제거되었다면, 해당 정보를 “실시간으로” 우선 lamp_pos에서 추가하거나 제거한다. 그러나 heapq에 있는 정보는 그대로 두고 나중에 실제로 있는지는 계속 실시간 업데이트가 되는 <code class="docutils literal notranslate"><span class="pre">lamp_pos</span></code>에서 확인하는 것이다.</p>
<p>즉, 실시간으로 업데이트 되는 정보 <code class="docutils literal notranslate"><span class="pre">lamp_pos</span></code>, <code class="docutils literal notranslate"><span class="pre">prev</span></code>, <code class="docutils literal notranslate"><span class="pre">next</span></code>이고 지연되는 것은 priority queue 즉 <code class="docutils literal notranslate"><span class="pre">road_q</span></code>, <code class="docutils literal notranslate"><span class="pre">left_q</span></code>, <code class="docutils literal notranslate"><span class="pre">right_q</span></code>와 같은 정보이다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 

<span class="n">roads</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">lamp_pos</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">get_max_road</span><span class="p">():</span>
    <span class="k">while</span> <span class="n">roads</span><span class="p">:</span>
        <span class="n">road</span> <span class="o">=</span> <span class="n">roads</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># 힙에서 꺼낸 도로 정보가 현재 가로등 위치와 일치하는지 확인</span>
        <span class="c1"># 즉, 이 도로를 구성하는 두 가로등이 여전히 인접해 있는지 검사</span>
        <span class="k">if</span> <span class="n">lamp_pos</span><span class="p">[</span><span class="n">road</span><span class="o">.</span><span class="n">left_lamp_id</span><span class="p">]</span> <span class="o">==</span> <span class="n">road</span><span class="o">.</span><span class="n">st_pos</span> <span class="ow">and</span> <span class="n">lamp_pos</span><span class="p">[</span><span class="n">road</span><span class="o">.</span><span class="n">right_lamp_id</span><span class="p">]</span> <span class="o">==</span> <span class="n">road</span><span class="o">.</span><span class="n">st_pos</span> <span class="o">+</span> <span class="n">road</span><span class="o">.</span><span class="n">length</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">roads</span><span class="p">)</span>
</pre></div>
</div>
<p>다음 <a class="reference external" href="https://school.programmers.co.kr/learn/courses/30/lessons/42628">프로그래머스 문제 링크</a> / (LeetCode 295)[<a class="reference external" href="https://leetcode.com/problems/find-median-from-data-stream/description/">https://leetcode.com/problems/find-median-from-data-stream/description/</a>] / Baekjoon 7662 이중 우선순위큐에서 lazy deletion을 연습할 수 있다.</p>
<div class="dropdown admonition">
<p class="admonition-title">인덱스를 통한 풀이</p>
<p>삽입 순서를 ID로 지정한 후, 실시간 deleted 리스트 인덱스를 ID로 하여 lazy deletion 표시 배열 사용.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span>

<span class="k">def</span><span class="w"> </span><span class="nf">solution</span><span class="p">(</span><span class="n">operations</span><span class="p">):</span>
    <span class="n">queue_b</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">queue_s</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">deleted</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">operations</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">operations</span><span class="p">):</span> 
        <span class="n">cm</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cm</span> <span class="o">==</span> <span class="s2">&quot;I&quot;</span><span class="p">:</span> 
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">queue_b</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">num</span><span class="p">,</span> <span class="o">-</span><span class="n">i</span><span class="p">))</span>  <span class="c1"># max heap</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">queue_s</span><span class="p">,</span> <span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>   <span class="c1"># min heap</span>

        <span class="k">elif</span> <span class="n">cm</span> <span class="o">==</span> <span class="s2">&quot;D&quot;</span> <span class="ow">and</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">queue_b</span><span class="p">:</span>
                <span class="n">deleted_n</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">queue_b</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">deleted</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="p">)]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> 
                    <span class="n">deleted</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">break</span>

        <span class="k">elif</span> <span class="n">cm</span> <span class="o">==</span> <span class="s2">&quot;D&quot;</span> <span class="ow">and</span> <span class="n">num</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">queue_s</span><span class="p">:</span>
                <span class="n">deleted_n</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">queue_s</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">deleted</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> 
                    <span class="n">deleted</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">break</span>

    <span class="n">max_v</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">while</span> <span class="n">queue_b</span><span class="p">:</span>
        <span class="n">val</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">queue_b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deleted</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="p">)]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">max_v</span> <span class="o">=</span> <span class="o">-</span><span class="n">val</span>
            <span class="k">break</span>

    <span class="n">min_v</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">while</span> <span class="n">queue_s</span><span class="p">:</span>
        <span class="n">val</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">queue_s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deleted</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">min_v</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">max_v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">min_v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">max_v</span><span class="p">,</span> <span class="n">min_v</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">객체 공유를 이용한 풀이</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 

<span class="k">class</span><span class="w"> </span><span class="nc">Num</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">valid</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">num</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="n">valid</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">num</span> <span class="c1"># min_heap </span>
    
<span class="k">def</span><span class="w"> </span><span class="nf">check_valid</span><span class="p">(</span><span class="n">heap</span><span class="p">):</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cur_num</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cur_num</span><span class="o">.</span><span class="n">valid</span><span class="p">:</span>  <span class="c1"># 없어진 값이면 지우고 다시 pop </span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cur_num</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
            <span class="k">break</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">check_max_valid</span><span class="p">(</span><span class="n">heap</span><span class="p">):</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">neg_num</span><span class="p">,</span> <span class="n">num_obj</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">num_obj</span><span class="o">.</span><span class="n">valid</span><span class="p">:</span>  <span class="c1"># 이미 없어진 값이면 지우고 다시 pop </span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_obj</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
            <span class="k">break</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">clean_min</span><span class="p">(</span><span class="n">heap</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">heap</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">valid</span><span class="p">:</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">clean_max</span><span class="p">(</span><span class="n">max_heap</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">max_heap</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">max_heap</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">valid</span><span class="p">:</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">max_heap</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">solution</span><span class="p">(</span><span class="n">operations</span><span class="p">):</span>
    <span class="n">min_heap</span> <span class="o">=</span> <span class="p">[]</span> 
    <span class="n">max_heap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operations</span><span class="p">:</span>
        <span class="n">char</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">char</span> <span class="o">==</span> <span class="s1">&#39;I&#39;</span><span class="p">:</span>
            <span class="n">same_instance</span> <span class="o">=</span> <span class="n">Num</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">min_heap</span><span class="p">,</span> <span class="n">same_instance</span><span class="p">)</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">max_heap</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">same_instance</span><span class="o">.</span><span class="n">num</span><span class="p">,</span> <span class="n">same_instance</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">char</span> <span class="o">==</span> <span class="s1">&#39;D&#39;</span> <span class="ow">and</span> <span class="n">num</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="c1"># 최댓값 삭제 </span>
            <span class="c1"># 예를 들어, min_heap에서 먼저 지워진 상황이지만, max_heap에서 아직 안지워진 경우 </span>
            <span class="n">check_max_valid</span><span class="p">(</span><span class="n">max_heap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 최솟값 삭제 </span>
            <span class="c1"># 예를 들어, max_heap에서 먼저 지워진 상황이지만, min_heap에서 아직 안지워진 경우 </span>
            <span class="n">check_valid</span><span class="p">(</span><span class="n">min_heap</span><span class="p">)</span>

    <span class="c1"># 실제 비어있는지 정리용 </span>
    <span class="n">clean_min</span><span class="p">(</span><span class="n">min_heap</span><span class="p">)</span>
    <span class="n">clean_max</span><span class="p">(</span><span class="n">max_heap</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">min_heap</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[</span><span class="n">max_heap</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num</span><span class="p">]</span>


<span class="c1"># operations = [&quot;I 16&quot;, &quot;I -5643&quot;, &quot;D -1&quot;, &quot;D 1&quot;, &quot;D 1&quot;, &quot;I 123&quot;, &quot;D -1&quot;]</span>
<span class="c1"># operations = [&quot;I -45&quot;, &quot;I 653&quot;, &quot;D 1&quot;, &quot;I -642&quot;, &quot;I 45&quot;, &quot;I 97&quot;, &quot;D 1&quot;, &quot;D -1&quot;, &quot;I 333&quot;]</span>
<span class="c1"># print(solution(operations))</span>
</pre></div>
</div>
</div>
<p>위의 두 방식 중에서 대부분 온라인 저지에서는 시간이 보틀넥이기 때문에, index를 활용한 deleted list를 이용하는 방식이 베스트 선택이다.</p>
</div>
<div class="dropdown admonition">
<p class="admonition-title">class comparison for heap</p>
<p>현재 가로등 정보에서 관련 정보, 왼쪽 가로등, 오른쪽 가로등과 같은 가로등 쌍에 대한 정보를 담는 class를 heap에서 정렬하기 위해 <strong>lt</strong> 비교 연산자 정의가 필요하다. 이는 다음처럼 정의할 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 

<span class="n">roads</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 인접한 가로등 사이의 도로 정보를 저장할 힙 </span>

<span class="c1"># 인접한 가로등 사이의 도로 정보를 담는 클래스 </span>
<span class="k">class</span><span class="w"> </span><span class="nc">Road</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_lamp_id</span><span class="p">,</span> <span class="n">right_lamp_id</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">st_pos</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left_lamp_id</span> <span class="o">=</span> <span class="n">left_lamp_id</span> <span class="c1">#도로의 왼쪽 가로등 ID </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right_lamp_id</span> <span class="o">=</span> <span class="n">right_lamp_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">st_pos</span> <span class="o">=</span> <span class="n">st_pos</span> <span class="c1"># 도로 시작 위치 (왼쪽 가로등 ID)</span>
    
    <span class="c1"># 최대 힙으로 사용하기 위한 비교 연산자 정의 </span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">length</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">length</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">st_pos</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">st_pos</span> 

<span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">roads</span><span class="p">,</span> <span class="n">Road</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">lamp_pos</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">doubly linked list</p>
<p>보통 doubly linked list 는 pointer를 사용하여 연결하지만 “삽입/삭제” 기능에 있어서 최대 O(N) time complexity가 소요되는 단점이 있다. 이와 달리 prev_lamp_id와 next_lamp_id의 두 리스트를 만들어서 각 가로등의 ID를 인덱스로 하여 이전 가로등과 다음 가로등의 ID를 저장한다. 이는 가로등들을 위치 순서에 따라 이중 연결 리스트처럼 관리하기 위함이며, 가로등 제거 시 양옆의 가로등을 O(1)에 찾는데 사용된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">prev</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="nb">next</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>위의 코드에서 i번째 노드 삭제는:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">prev</span><span class="p">[</span><span class="nb">next</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="nb">next</span><span class="p">[</span><span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>삭제 연산이 O(1)으로 줄어든다. 즉, linked list를 “배열로 구현하면” 사실상 매우 빠른 연결 리스트가 된다.</p>
<div class="dropdown admonition">
<p class="admonition-title">DLL implementation with array</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">MAX</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>
<span class="n">prev</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">MAX</span> 
<span class="nb">next</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">MAX</span> 
<span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">MAX</span> 

<span class="c1"># head = some index </span>
<span class="c1"># insert x after cur </span>
<span class="k">def</span><span class="w"> </span><span class="nf">insert</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="nb">next</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span>
    <span class="n">prev</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span> 

    <span class="c1"># NOTE: next node의 prev에 접근할때 </span>
    <span class="k">if</span> <span class="nb">next</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># linked list의 last가 아닌 경우, </span>
        <span class="n">prev</span><span class="p">[</span><span class="nb">next</span><span class="p">[</span><span class="n">cur</span><span class="p">]]</span> <span class="o">=</span> <span class="n">x</span> 

    <span class="nb">next</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">delete</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">prev</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="nb">next</span><span class="p">[</span><span class="n">prev</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> 
    <span class="k">if</span> <span class="nb">next</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">prev</span><span class="p">[</span><span class="nb">next</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="n">prev</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p>해당 방식을 사용하여 빠르게 풀 수 있는 문제들을 아래에 적어놓았다.</p>
<ul class="simple">
<li><p>[LRU Cache 최적 구현]</p></li>
<li><p>[BOJ 5397 키로거]</p></li>
<li><p>[BOJ 1406 에디터]</p></li>
</ul>
</div>
<div class="dropdown admonition">
<p class="admonition-title">좌/우 전역값 동기화</p>
<p>이론상 전역 변수로 끝값을 정리하면서 “삭제 때만 갱신”하는 것으로 코드를 구현할 수 있다. 이런 방식은 힙 사용때보다 메모리 사용량을 줄일 수 있지만, 업데이트 순서가 미묘하게 어긋나거나 버그가 하나만 생겨도 전역 끝값이 틀어질 수 있다. 전역 캐시는 모든 변화 경로를 100% 누락 없이 갱신해야 하는 부채가 생깁니다(연속 삭제, 경계 근처 혼합 연산, 예외 입력 등). 하지만 <em><strong>힙+지연검증</strong></em> 은 질의 시점에 항상 자기 교정을 하므로, 누락이 끼어도 pop하면서 복구돼요.
→ “가능은 하지만 유지비가 큰 전역 캐시” vs “조금 더 구조화된 힙 기반”의 선택 문제입니다.</p>
</div>
<div class="dropdown admonition">
<p class="admonition-title">ceiling</p>
<p>중간 좌표 계산에서 천장(ceil)인 경우에, 아래 코드를 사용한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">new_pos</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">st_pos</span> <span class="o">+</span> <span class="p">(</span><span class="n">road</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
</pre></div>
</div>
<p>2로 나누어 round()를 적용하면 파이썬에서는 ‘은행가 반올림(0.5를 짝수로)이라 4.5 -&gt; 4, 5.5-&gt;6 같은 예외가 생긴다. 문제에서는 ceiling 을 요구하므로 위의 코드를 사용해야한다.</p>
</div>
<div class="dropdown admonition">
<p class="admonition-title">solution</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span> 
<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 

<span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span>
<span class="c1"># sys.stdin = open(&#39;Input.txt&#39;)</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">INIT:</span>

<span class="sd">1) road_q = </span>
<span class="sd">2) left_q = </span>
<span class="sd">3) right_q = </span>
<span class="sd">4) prev = </span>
<span class="sd">5) next = </span>
<span class="sd">6) N = length of the road </span>
<span class="sd">7) lamps_pos = </span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Road</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">end_pos</span><span class="p">,</span> <span class="n">left_num</span><span class="p">,</span> <span class="n">right_num</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_pos</span> <span class="o">=</span> <span class="n">start_pos</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">end_pos</span> <span class="o">=</span> <span class="n">end_pos</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">left_num</span> <span class="o">=</span> <span class="n">left_num</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">right_num</span> <span class="o">=</span> <span class="n">right_num</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">length</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_pos</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">start_pos</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">length</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">check</span><span class="p">(</span><span class="n">light_nums</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
    <span class="n">poses</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pos</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">left_pos</span><span class="p">,</span> <span class="n">right_pos</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">poses</span><span class="p">):</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">right_pos</span> <span class="o">-</span> <span class="n">left_pos</span> 
        <span class="n">left_num</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span> 
        <span class="n">right_num</span> <span class="o">=</span> <span class="n">left_num</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># Road 안에 __lt__로 length에 대해서 max_heap, left_pos에 대해서 min_heap으로 heapq에서 &quot;정렬&quot;되도록 해놓음. </span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">road_q</span><span class="p">,</span> <span class="n">Road</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">left_pos</span><span class="p">,</span> <span class="n">right_pos</span><span class="p">,</span> <span class="n">left_num</span><span class="p">,</span> <span class="n">right_num</span><span class="p">))</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">left_q</span><span class="p">,</span> <span class="p">(</span><span class="n">left_pos</span><span class="p">,</span> <span class="n">left_num</span><span class="p">))</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">right_q</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">left_pos</span><span class="p">,</span> <span class="n">left_num</span><span class="p">))</span>
        <span class="n">lamps_pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left_pos</span><span class="p">)</span>
        <span class="n">prev</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left_num</span><span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">left_num</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="nb">next</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right_num</span><span class="p">)</span> 
    
    <span class="c1"># 맨 마지막 노드 </span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">left_q</span><span class="p">,</span> <span class="p">(</span><span class="n">right_pos</span><span class="p">,</span> <span class="n">right_num</span><span class="p">))</span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">right_q</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">right_pos</span><span class="p">,</span> <span class="n">right_num</span><span class="p">))</span>
    <span class="n">prev</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right_num</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="nb">next</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">lamps_pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right_pos</span><span class="p">)</span>

 
<span class="k">def</span><span class="w"> </span><span class="nf">valid_check</span><span class="p">(</span><span class="n">cur_road</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    현재 두 가로등 사이의 정보(cur_road)가 정확한지, 아니면 old한 정보인지 check </span>
<span class="sd">    항상 맞는 정보: prev, next, lamps_pos(불변)</span>
<span class="sd">    아직 업데이트 안되어 있는 정보: road_q, left_q, right_q </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">cur_road</span><span class="o">.</span><span class="n">length</span> 
    <span class="n">left_pos</span> <span class="o">=</span> <span class="n">cur_road</span><span class="o">.</span><span class="n">start_pos</span> 
    <span class="n">right_pos</span> <span class="o">=</span> <span class="n">cur_road</span><span class="o">.</span><span class="n">end_pos</span> 
    <span class="n">left_num</span> <span class="o">=</span> <span class="n">cur_road</span><span class="o">.</span><span class="n">left_num</span> 
    <span class="n">right_num</span> <span class="o">=</span> <span class="n">cur_road</span><span class="o">.</span><span class="n">right_num</span> 

    <span class="k">if</span> <span class="n">lamps_pos</span><span class="p">[</span><span class="n">left_num</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">lamps_pos</span><span class="p">[</span><span class="n">right_num</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># 둘 중 하나가 이미 제거된 가로등 </span>
        <span class="k">return</span> <span class="kc">False</span> 
    <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="nb">abs</span><span class="p">(</span><span class="n">left_pos</span> <span class="o">-</span> <span class="n">lamps_pos</span><span class="p">[</span><span class="nb">next</span><span class="p">[</span><span class="n">left_num</span><span class="p">]]):</span>
        <span class="k">return</span> <span class="kc">True</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    인접 가로등 사이에 추가</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># lazy deletion </span>
    <span class="n">to_be_broken_road</span> <span class="o">=</span> <span class="kc">None</span> 
    <span class="k">while</span> <span class="n">road_q</span><span class="p">:</span>
        <span class="n">cur_road</span> <span class="o">=</span> <span class="n">road_q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">valid_check</span><span class="p">(</span><span class="n">cur_road</span><span class="p">):</span>
            <span class="c1"># 추가될 기존 길은 road_q에서 삭제 되어야한다. </span>
            <span class="n">to_be_broken_road</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">road_q</span><span class="p">)</span>
            <span class="k">break</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">road_q</span><span class="p">)</span>
    
    <span class="c1"># 추가 </span>
    <span class="n">left_pos</span> <span class="o">=</span> <span class="n">to_be_broken_road</span><span class="o">.</span><span class="n">start_pos</span>
    <span class="n">right_pos</span>  <span class="o">=</span> <span class="n">to_be_broken_road</span><span class="o">.</span><span class="n">end_pos</span>
    <span class="n">left_lamp_num</span> <span class="o">=</span> <span class="n">to_be_broken_road</span><span class="o">.</span><span class="n">left_num</span>
    <span class="n">right_lamp_num</span> <span class="o">=</span> <span class="n">to_be_broken_road</span><span class="o">.</span><span class="n">right_num</span>

    <span class="n">new_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">left_pos</span> <span class="o">+</span> <span class="n">right_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> 
    <span class="n">new_lamp_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">road_q</span><span class="p">,</span> <span class="n">Road</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">new_pos</span><span class="o">-</span><span class="n">left_pos</span><span class="p">),</span> <span class="n">left_pos</span><span class="p">,</span> <span class="n">new_pos</span><span class="p">,</span> <span class="n">left_lamp_num</span><span class="p">,</span> <span class="n">new_lamp_num</span><span class="p">))</span> <span class="c1"># length, start_pos, end_pos, left_num, right_num</span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">road_q</span><span class="p">,</span> <span class="n">Road</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">right_pos</span><span class="o">-</span><span class="n">new_pos</span><span class="p">),</span> <span class="n">new_pos</span><span class="p">,</span> <span class="n">right_pos</span><span class="p">,</span> <span class="n">new_lamp_num</span><span class="p">,</span> <span class="n">right_lamp_num</span><span class="p">))</span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">left_q</span><span class="p">,</span> <span class="p">(</span><span class="n">new_pos</span><span class="p">,</span> <span class="n">new_lamp_num</span><span class="p">))</span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">right_q</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">new_pos</span><span class="p">,</span> <span class="n">new_lamp_num</span><span class="p">))</span>
    <span class="n">prev</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left_lamp_num</span><span class="p">)</span>
    <span class="nb">next</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right_lamp_num</span><span class="p">)</span>
    <span class="n">prev</span><span class="p">[</span><span class="n">right_lamp_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_lamp_num</span>
    <span class="nb">next</span><span class="p">[</span><span class="n">left_lamp_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_lamp_num</span>

    <span class="n">lamps_pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pos</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">remove</span><span class="p">(</span><span class="n">removed_lamp_num</span><span class="p">):</span>
    <span class="c1"># 가장 자리 노드가 아닌 중간 노드를 제거하는 경우는, 두 개의 길이 삭제 (lazy deletion)될 것이고</span>
    <span class="c1"># 길이 하나 더 추가되어야함. </span>
    <span class="k">if</span> <span class="n">prev</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">next</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lamps_pos</span><span class="p">[</span><span class="n">prev</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]]</span><span class="o">-</span><span class="n">lamps_pos</span><span class="p">[</span><span class="nb">next</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]])</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">road_q</span><span class="p">,</span> <span class="n">Road</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">lamps_pos</span><span class="p">[</span><span class="n">prev</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]],</span> <span class="n">lamps_pos</span><span class="p">[</span><span class="nb">next</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]],</span> <span class="n">prev</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">],</span> <span class="nb">next</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]))</span>

<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    가장 자리 노드가 삭제되면 road_q는 그대로이고, left_q와 right_q도 후에 lazy deletion으로 삭제될 예정이라</span>
<span class="sd">    해줄 것이 없음, 다만 현재의 정보를 정확히 lamps_pos, prev, next에 저장</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># doubly linked list </span>
    <span class="k">if</span> <span class="n">prev</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="nb">next</span><span class="p">[</span><span class="n">prev</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">next</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">prev</span><span class="p">[</span><span class="nb">next</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]]</span> <span class="o">=</span> <span class="n">prev</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]</span>
    <span class="c1"># 현재 가로등에 대한 정보 전부 제거 </span>
    <span class="n">lamps_pos</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 
    <span class="n">prev</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="nb">next</span><span class="p">[</span><span class="n">removed_lamp_num</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">get_max_from_left</span><span class="p">():</span>
    <span class="k">while</span> <span class="n">left_q</span><span class="p">:</span> <span class="c1"># (pos, num)</span>
        <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="o">=</span> <span class="n">left_q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">lamps_pos</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pos</span><span class="p">:</span> <span class="c1"># invalid </span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">left_q</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span> 
    <span class="k">return</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># r계산 </span>

<span class="k">def</span><span class="w"> </span><span class="nf">get_max_from_right</span><span class="p">():</span>
    <span class="n">dis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">right_q</span><span class="p">:</span>
        <span class="p">(</span><span class="n">dis</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="o">=</span> <span class="n">right_q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dis</span> <span class="o">=</span> <span class="n">dis</span><span class="o">*-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">lamps_pos</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dis</span><span class="p">:</span> <span class="c1"># max_heap 이라서 -1 를 곱해줘야함. </span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">right_q</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span> 
    <span class="k">return</span> <span class="n">N</span><span class="o">-</span><span class="n">dis</span>  <span class="c1"># pos는 이미 음수, r 계산 </span>

<span class="k">def</span><span class="w"> </span><span class="nf">get_max_from_roads</span><span class="p">():</span>
    <span class="k">while</span> <span class="n">road_q</span><span class="p">:</span>
        <span class="n">cur_road</span> <span class="o">=</span> <span class="n">road_q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">valid_check</span><span class="p">(</span><span class="n">cur_road</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cur_road</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">road_q</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">calculate</span><span class="p">():</span>
    <span class="n">side_r</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">get_max_from_left</span><span class="p">(),</span> <span class="n">get_max_from_right</span><span class="p">())</span>
    <span class="n">middle_r</span> <span class="o">=</span> <span class="n">get_max_from_roads</span><span class="p">()</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="n">side_r</span><span class="p">,</span> <span class="n">middle_r</span><span class="p">))</span>

<span class="n">lamps_pos</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">road_q</span> <span class="o">=</span> <span class="p">[]</span> 
<span class="n">left_q</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">right_q</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">prev</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="c1"># 아무것도 없으면 -1 </span>
<span class="nb">next</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
<span class="n">N</span> <span class="o">=</span> <span class="mi">0</span> 

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Q</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> 
            <span class="n">check</span><span class="p">(</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">order</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span>
        <span class="k">elif</span> <span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span>
            <span class="n">add</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">300</span><span class="p">:</span>
            <span class="n">remove</span><span class="p">(</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># 400 </span>
            <span class="nb">print</span><span class="p">(</span><span class="n">calculate</span><span class="p">())</span>
</pre></div>
</div>
</div>
</section>
<section id="id5">
<h3>코드 트리 채점기<a class="headerlink" href="#id5" title="Link to this heading">#</a></h3>
<p>이런 문제를 푸는 경우, 각 문제의 요구 사항을 만족시키기 위해서는 <em><strong>(1) 각 정보의 특성에 맞는 효율적인 자료구조</strong></em> 를 설계하고, 각 명령어에 따른 <em><strong>(2) 상태 변화를 누락 없이 처리</strong></em> 하는 것이 중요하다.</p>
<div class="dropdown admonition">
<p class="admonition-title">필요한 자료구조</p>
<p>문제를 풀때 wating_urls을 priority queue로 해서, Task를 하나씩 뽑아내는 것을 생각하기 쉽다. 이때 문제는, 현재 들어온 url이 waiting_urls에 있는지 확인하려면, 다 뺐다가 다시 넣어야한다. 따라서, waiting_urls은 검색을 O(1)으로 용이하게 하도록 set[str]으로 만든다. 그렇다면, 우선순위가 가장 높은 Task를 구할때는 domain_pqs: dict[str, list[Task]] 로 각 도메인별로 가장 우선순위가 높은 맨 앞의 Task하나씩 비교해서 보면 된다. 문제의 contraints를 보면 서로 다른 도메인수는 최대 300이라고 했기 때문에, 이렇게 하는것이 시간 복잡도상 가장 효율적이게 된다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">waiting_urls:</span> <span class="pre">set[str]</span></code>: 채점 대기 큐에 있는 Task들의 url들을 저장하는 집합(set). 특정 url이 큐에 있는지 평균 O(1) 시간 복잡도로 빠르게 확인하기 위해 사용한다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">domain_pqs:</span> <span class="pre">dict[str,</span> <span class="pre">list[Task]]</span></code>: 각 도메인별로 채점 대기 중인 Task들을 저장하는 우선순위 큐. 파이썬의 heapq 모듈을 사용한다. 도메인별로 list가 연결되어있고, 이 리스트가 우선순위큐로 Task들을 저장한다.</p>
<ul>
<li><p>key는 ‘도메인(domain)’, value는 해당 도메인의 Task들을 담은 우선순위 큐(최소 힙)이다.</p></li>
<li><p>Task의 우선순위(우선순위 번호가 작을 수록, 요청 시간이 빠를수록 높음)에 따라 자동으로 정렬되므로, 각 도메인에서 가장 우선순위 높은 Task를 O(1)로 찾을 수 있다.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">resting_judger_ids:</span> <span class="pre">list[int]</span></code>: 쉬고 있는 채점기의 ID들을 저장하는 최소 힙. 가장 번호가 작은 채점기를 빠르게 찾기 위해 사용한다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">judgers:</span> <span class="pre">list[Task</span> <span class="pre">|</span> <span class="pre">None]</span></code>: 각 채점기가 현재 어떤 Task를 채점 중인지 저장하는 배열. judger[i]는 i번 채점기가 채점 중인 Task 객체를 가리키거나, 쉬고 있다면 None을 저장한다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">domain_judge_history:</span> <span class="pre">dict[str,</span> <span class="pre">History]</span></code>: 각 도메인의 가장 최근 채점 기록(시작 시간, 종료 시간)을 저장하는 딕셔너리. 채점 유예 기간을 계산하는데 사용한다.</p></li>
</ul>
<p>또한, Task정보와 채점 기록 정보를 편리하게 다루기 위한 클래스들을 정의한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 채점 태스크(Task) 정보를 저장하는 클래스입니다.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Task</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">priority</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">url</span><span class="p">:</span><span class="nb">str</span><span class="p">):</span>
        <span class="n">domain</span><span class="p">,</span> <span class="n">pid_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">request_time</span> <span class="o">=</span> <span class="n">request_time</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">priority</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">url</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">domain</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">problem_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pid_str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 
        
    
    <span class="c1"># 우선순위 비교를 위한 __lt__ 메서드 </span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    &quot;Task&quot;라고 표시한 이유: __lt__가 클래스 내부에 있을 때 아직 정의되지 않은 Task 타입을 참조하기 위해 &quot;전방 선언(Forward Reference)&quot;으로 문자열을 사용한 것. 즉 문자열을 &#39;타입 힌트&#39;로 쓰면 python이 나중에 실제 그걸 클래스 이름으로 다시 해석한다. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Task&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">priority</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">priority</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">request_time</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">request_time</span>

<span class="c1"># 각 도메인의 채점 기록(History)을 저장하는 클래스입니다.</span>
<span class="c1"># domain_judge_history: dict[str, History]에서 value에 사용될 예정 </span>
<span class="k">class</span><span class="w"> </span><span class="nc">History</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">start_time</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">end_time</span> 

    <span class="k">def</span><span class="w"> </span><span class="nf">is_valid_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">gap</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">gap</span> <span class="o">&lt;=</span> <span class="n">cur_time</span> 
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">solution</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span> 

<span class="c1"># -----------------------------</span>
<span class="c1"># 데이터 구조 공간 복잡도</span>
<span class="c1"># -----------------------------</span>
<span class="c1"># domain_pqs           : 도메인별 우선순위 큐, 전체 Task 수 ≤ Q → O(Q)</span>
<span class="c1"># domain_judge_history : 도메인 ≤ 300개 → O(1)</span>
<span class="c1"># resting_judger_ids   : 최대 N개 → O(N)</span>
<span class="c1"># judging_domains      : 최대 300개 → O(1)</span>
<span class="c1"># judgers              : N+1 크기 배열 → O(N)</span>
<span class="c1"># waiting_urls         : 대기 URL ≤ Q → O(Q)</span>
<span class="c1">#</span>
<span class="c1"># 전체 공간 복잡도: O(N + Q)</span>
<span class="c1"># -----------------------------</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Task</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Task 객체 1개 공간: O(1) (URL 길이가 상수 19니까 O(1))&quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">priority</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">url</span><span class="p">:</span><span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">domain</span><span class="p">,</span> <span class="n">pid_str</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">request_time</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">request_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">priority</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">priority</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">url</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">domain</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">problem_id</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pid_str</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Task&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;비교 연산: O(1)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">priority</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">priority</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">request_time</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">request_time</span> 


<span class="k">class</span><span class="w"> </span><span class="nc">History</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;History 객체 1개 공간: O(1)&quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span><span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">start_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">end_time</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_valid_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;단순 연산: O(1)&quot;&quot;&quot;</span>
        <span class="n">gap</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">gap</span> <span class="o">&lt;=</span> <span class="n">cur_time</span> 
    

<span class="c1"># 전역 데이터 구조</span>
<span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">domain_pqs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Task</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="n">domain_judge_history</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">History</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">resting_judger_ids</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">judging_domains</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="n">judgers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Task</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">waiting_urls</span> <span class="p">:</span><span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>


<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 명령어 100: 채점기 준비</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 시간 복잡도:</span>
<span class="c1">#   resting_judger_ids 초기화: O(N)</span>
<span class="c1">#   judgers 초기화: O(N)</span>
<span class="c1">#   process_200 호출: O(log Q)</span>
<span class="c1"># 전체 → O(N)</span>
<span class="c1">#</span>
<span class="c1"># 공간 복잡도: O(N) (리스트 초기화)</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process_100</span><span class="p">(</span><span class="n">n_</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span><span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">n</span><span class="p">,</span> <span class="n">resting_judger_ids</span><span class="p">,</span> <span class="n">judgers</span> 

    <span class="n">n</span> <span class="o">=</span> <span class="n">n_</span>
    <span class="n">resting_judger_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>  <span class="c1"># O(N)</span>
    <span class="n">judgers</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>                         <span class="c1"># O(N)</span>

    <span class="n">process_200</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">)</span>                       <span class="c1"># O(log Q)</span>


<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 명령어 200: 채점 요청 추가</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 시간 복잡도:</span>
<span class="c1">#   u in waiting_urls (set membership): O(1)</span>
<span class="c1">#   Task 생성: O(1)</span>
<span class="c1">#   heapq.heappush: O(log Q)</span>
<span class="c1">#   waiting_urls.add: O(1)</span>
<span class="c1"># 전체 → O(log Q)</span>
<span class="c1">#</span>
<span class="c1"># 공간 복잡도: O(1) (Task 1개 추가 → 전체적으로 O(Q) 안에 포함)</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process_200</span><span class="p">(</span><span class="n">t</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">waiting_urls</span><span class="p">,</span> <span class="n">domain_pqs</span> 

    <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">waiting_urls</span><span class="p">:</span>    <span class="c1"># O(1)</span>
        <span class="k">return</span> 
    
    <span class="n">task</span> <span class="o">=</span> <span class="n">Task</span><span class="p">(</span><span class="n">request_time</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">url</span><span class="o">=</span><span class="n">u</span><span class="p">)</span>  <span class="c1"># O(1)</span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">domain_pqs</span><span class="p">[</span><span class="n">task</span><span class="o">.</span><span class="n">domain</span><span class="p">],</span> <span class="n">task</span><span class="p">)</span>   <span class="c1"># O(log Q)</span>
    <span class="n">waiting_urls</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>                             <span class="c1"># O(1)</span>


<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 도메인 채점 가능 여부 확인</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 시간 복잡도: O(1)</span>
<span class="c1"># 공간 복잡도: O(1)</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="k">def</span><span class="w"> </span><span class="nf">is_domain_judgeable</span><span class="p">(</span><span class="n">cur_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">domain</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">judging_domains</span><span class="p">,</span> <span class="n">domain_judge_history</span>

    <span class="k">if</span> <span class="n">domain</span> <span class="ow">in</span> <span class="n">judging_domains</span><span class="p">:</span>           <span class="c1"># O(1)</span>
        <span class="k">return</span> <span class="kc">False</span> 

    <span class="n">history</span><span class="p">:</span> <span class="n">History</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="n">domain_judge_history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># O(1)</span>
    <span class="k">if</span> <span class="n">history</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">history</span><span class="o">.</span><span class="n">is_valid_time</span><span class="p">(</span><span class="n">cur_time</span><span class="p">):</span>               <span class="c1"># O(1)</span>
        <span class="k">return</span> <span class="kc">False</span> 
    
    <span class="k">return</span> <span class="kc">True</span> 


<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 명령어 300: 채점 시도</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 시간 복잡도:</span>
<span class="c1">#   쉬는 채점기 체크: O(1)</span>
<span class="c1">#   모든 도메인 순회: D ≤ 300 → O(300) = O(1)</span>
<span class="c1">#   각 도메인 pq[0] 접근: O(1)</span>
<span class="c1">#   비교 연산: O(1)</span>
<span class="c1">#   heappop(resting_judger_ids): O(log N)</span>
<span class="c1">#   heappop(domain_pqs[domain]): O(log Q)</span>
<span class="c1">#   set/dict 업데이트: O(1)</span>
<span class="c1">#</span>
<span class="c1"># 전체 → O(log N + log Q)</span>
<span class="c1">#</span>
<span class="c1"># 공간 복잡도: O(1)</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process_300</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">resting_judger_ids</span><span class="p">,</span> <span class="n">domain_pqs</span><span class="p">,</span> <span class="n">judging_domains</span><span class="p">,</span> <span class="n">judgers</span><span class="p">,</span> <span class="n">waiting_urls</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">resting_judger_ids</span><span class="p">:</span>  <span class="c1"># O(1)</span>
        <span class="k">return</span> 
    
    <span class="n">best_task</span><span class="p">:</span> <span class="n">Task</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span> 

    <span class="k">for</span> <span class="n">domain</span><span class="p">,</span> <span class="n">pq</span> <span class="ow">in</span> <span class="n">domain_pqs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>   <span class="c1"># O(300) = O(1)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pq</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">is_domain_judgeable</span><span class="p">(</span><span class="n">cur_time</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="p">):</span>  
            <span class="k">continue</span> 

        <span class="n">current_task</span> <span class="o">=</span> <span class="n">pq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                <span class="c1"># O(1)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">best_task</span> <span class="ow">or</span> <span class="n">current_task</span> <span class="o">&lt;</span> <span class="n">best_task</span><span class="p">:</span>  <span class="c1"># O(1)</span>
            <span class="n">best_task</span> <span class="o">=</span> <span class="n">current_task</span> 

    <span class="k">if</span> <span class="ow">not</span> <span class="n">best_task</span><span class="p">:</span>
        <span class="k">return</span> 
    
    <span class="n">j_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">resting_judger_ids</span><span class="p">)</span>     <span class="c1"># O(log N)</span>
    <span class="n">best_task</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">t</span> 

    <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">domain_pqs</span><span class="p">[</span><span class="n">best_task</span><span class="o">.</span><span class="n">domain</span><span class="p">])</span>       <span class="c1"># O(log Q)</span>
    <span class="n">judging_domains</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">best_task</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>             <span class="c1"># O(1)</span>
    <span class="n">judgers</span><span class="p">[</span><span class="n">j_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_task</span>                         <span class="c1"># O(1)</span>
    <span class="n">waiting_urls</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">best_task</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>                <span class="c1"># O(1)</span>


<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 명령어 400: 채점 종료</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 시간 복잡도:</span>
<span class="c1">#   task 조회: O(1)</span>
<span class="c1">#   History 생성 및 dict 기록: O(1)</span>
<span class="c1">#   heapq.heappush(resting_judger_ids): O(log N)</span>
<span class="c1">#   set.remove + 배열 저장: O(1)</span>
<span class="c1">#</span>
<span class="c1"># 전체 → O(log N)</span>
<span class="c1">#</span>
<span class="c1"># 공간 복잡도: O(1)  (History 1개 추가 → 전체 O(Q)에 포함)</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process_400</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">judgers</span><span class="p">,</span> <span class="n">domain_judge_history</span><span class="p">,</span> <span class="n">resting_judger_ids</span><span class="p">,</span> <span class="n">judging_domains</span>

    <span class="n">task</span><span class="p">:</span> <span class="n">Task</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="n">judgers</span><span class="p">[</span><span class="n">j_id</span><span class="p">]</span>       <span class="c1"># O(1)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">task</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">domain_judge_history</span><span class="p">[</span><span class="n">task</span><span class="o">.</span><span class="n">domain</span><span class="p">]</span> <span class="o">=</span> <span class="n">History</span><span class="p">(</span><span class="n">start_time</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># O(1)</span>
    
    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">resting_judger_ids</span><span class="p">,</span> <span class="n">j_id</span><span class="p">)</span>    <span class="c1"># O(log N)</span>
    <span class="n">judging_domains</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>          <span class="c1"># O(1)</span>
    <span class="n">judgers</span><span class="p">[</span><span class="n">j_id</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>                         <span class="c1"># O(1)</span>


<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 명령어 500: 대기 큐 조회</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="c1"># 시간 복잡도: O(1)</span>
<span class="c1"># 공간 복잡도: O(1)</span>
<span class="c1"># ----------------------------------------------------------</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process_500</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">waiting_urls</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">waiting_urls</span><span class="p">))</span>  <span class="c1"># O(1)</span>


<span class="c1"># ------------------ 메인 실행 ------------------</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">전체 시간 복잡도: O(Q(logN + logQ))</span>
<span class="sd">전체 공간 복잡도: O(N+Q)</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="n">q</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="n">query</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">cmd</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">cmd</span> <span class="o">==</span> <span class="mi">100</span><span class="p">:</span>
        <span class="n">process_100</span><span class="p">(</span><span class="n">n_</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">u</span><span class="o">=</span><span class="n">query</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">cmd</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span>
        <span class="n">process_200</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">p</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">u</span><span class="o">=</span><span class="n">query</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">cmd</span> <span class="o">==</span> <span class="mi">300</span><span class="p">:</span>
        <span class="n">process_300</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">cmd</span> <span class="o">==</span> <span class="mi">400</span><span class="p">:</span>
        <span class="n">process_400</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">j_id</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">cmd</span> <span class="o">==</span> <span class="mi">500</span><span class="p">:</span>
        <span class="n">process_500</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

</pre></div>
</div>
</div>
</section>
<section id="id6">
<h3>코드 트리 투어<a class="headerlink" href="#id6" title="Link to this heading">#</a></h3>
<p>구현 문제의 경우, 실수할 수 있는 부분은 여러개의 command 중 하나를 하고 다른 command를 할 경우 그 다음 상황에 영향을 미치는 것이 있는 지 미리 체크해야한다. 이번 문제의 경우 새로 변한 start_id에 대해 이후에 command <code class="docutils literal notranslate"><span class="pre">200</span></code>이 나오는 경우에 새로운 <code class="docutils literal notranslate"><span class="pre">start_id</span></code>에 대하여 Trip의 cost등을 계산해야하므로 이를 global variable로 관리해주는 것이 포인트였다.</p>
<div class="dropdown admonition">
<p class="admonition-title">explanation</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">여행 상품의 출발지는 통일: 0번 도시 </span>
<span class="sd">간선에 음수가 없으므로 dijkstra algorithm사용 가능. </span>

<span class="sd">0. 필요한 자료 구조 </span>
<span class="sd">- `trip_lists`: pq, Trip class를 priority에 맞게 보관 </span>
<span class="sd">- class Trip: __lt__(), get_benefit(), </span>
<span class="sd">- shortest_path: dict[int(id), list[int] (cost to the dest_id)]</span>
<span class="sd">- graph: adjacency_list: list[list[int]], 각 노드와 연결된 node정보 저장 </span>

<span class="sd">1. 코드트리 랜드 건설</span>
<span class="sd">- 도시의 수 n, 간선의 수 m, 간성 정보 (도시 i,도시 j, 가중치)</span>
<span class="sd">- 자기자신 연결, 두 도시 간의 여러 간선 가능 </span>
<span class="sd">- start_node가 0인 shortest_path INIT </span>
<span class="sd">- graph 초기화 </span>

<span class="sd">2. 여행 상품 생성 </span>
<span class="sd">- 관리 목록: (id, revenue_id, dest_id) 여행 상품을 추가하고 관리 목록에 추가 </span>
<span class="sd">    - 데이터 구조: priority queue로 O(log(30,000)) = O(10)  </span>
<span class="sd">    - id: 여행상품 고유 식별자 </span>
<span class="sd">    - revenue_id : 여행사가 얻게되는 매출 </span>
<span class="sd">    - start_id: 이 상품의 출발지 </span>
<span class="sd">    - dest_id :이 상품의 도착지 </span>
<span class="sd">    - cost : revenue_id - shortest_path (출발지 ~ 도착지 최단거리)</span>
<span class="sd">- 해당 명령은 최대 30,000번 주어진다.</span>
<span class="sd">- class Trip 생성으로 해당 데이터 관리 필요 </span>
<span class="sd">    - __lt__ 함수 : pq에 들어갈나 &lt;, &gt;를 계산할때 비교 함수 생성 </span>
<span class="sd">    - get_benefit 함수: Start_id가 바뀜에 cost가 변해서, 변할때 그 차이를 계산해주는 함수 생성 </span>


<span class="sd">3. 여행 상품 취소 </span>
<span class="sd">- 여행 상품 고유 식별자 id에 해당하는 여행 상품 존재하면 관리 목록에서 삭제 </span>
<span class="sd">    - 찾기: O(1) -&gt; dict로 id에 따른 상품을 관리할 수 있음 </span>
<span class="sd">        - list로 관리하면 어떤 id가 있을 지도 모르는데, 메모리 비용이 많이 든다. </span>
<span class="sd">        - id는 30,000보다 작으므로 근데 어차피 여행 상품 넣는 것을 30000으로 하니까 오히려 list의 indexf로 관리하는게 더 나을 수도 있겠음. </span>
<span class="sd">        - dictionary는 key가 맞는지 일일이 확인해야하잖아. </span>
<span class="sd">    - 삭제: O(1) </span>
<span class="sd">    - 삭제 이후, 관리 목록 pq 는 lazy deletion을 진행해야함. (즉, id_trip_pq는 바로 관리하고, 4번 판매할때, 이게 유효한지, id_trip_pq를 통해서 확인)</span>
<span class="sd">- 해당 명령은 최대 30,000번 주어진다. ~ 3*1e4</span>

<span class="sd">4. 최적 여행 상품 판매 </span>
<span class="sd">- 판매 가능 상품이 없으면 -1 출력후 상품 제거 x </span>
<span class="sd">- 판매 가능 상품 있으면 해당 상품 id 출력후 상품 제거 </span>
<span class="sd">- 해당 명령은 최대 30,000번 주어진다. ~ O(10)*30000 ~ 3*1e5</span>

<span class="sd">- 판매 불가 상품 </span>
<span class="sd">    - 출발지로부터 dest_id까지 도달하는 것이 불가능 </span>
<span class="sd">        - 이건 넣을때부터 알 수 있는 건데...아 근데 넣을때 빼버리면 나중에 출발지 변경할때 또 달라질 수 있어서 그때그때 검사하는 게 좋음 </span>
<span class="sd">        - Trip class의 cost가 MAX값이면 도달 불가능확인 가능 </span>
<span class="sd">        - O(1)</span>
<span class="sd">    - cost_id가 revenue_id보다 커서 여행사가 이득을 얻을 수 없는 상황, 이득이 0인 경우도 팔 수 있음 </span>
<span class="sd">        - revenue_id - cost_id &lt; 0 이면 팔 수 없음 </span>
<span class="sd">        - O(1) </span>
<span class="sd">- 관리 목록에서 조건에 맞는 최적 상품 선택 및 판매 </span>
<span class="sd">    - 조건: </span>
<span class="sd">        - 이득 [revenue - cost]가 최대인 상품 : cost = 출발지로부터 id 상품의 도착지 dest_id까지 도달하기 위한 최단 거리 </span>
<span class="sd">        - 이득이 동일하면 id가 가장 작은 상품 선택 </span>
<span class="sd">        - NOTE: </span>
<span class="sd">        ---&gt; 이 조건들을 생각해보면, get_benefit()을 통해 나온 이득이 음수인 경우, 그 뒤를 보지 않아도 다 팔리지 못할 상품들이므로 팔 수 있는 상품이 없다고 생각하면 됨. </span>
<span class="sd">        ----&gt; 따라서, 맨 처음 pq에 있는 상품의 이득이 &gt;=0인 경우, 그것을 팔면 된다.</span>
<span class="sd">    - 판매 불가 조건 </span>
<span class="sd">        - 위 참고 </span>
<span class="sd">    - 판매 가능 상품 중 가장 우선순위가 높은 상품을 1개 판매하고, 이 상품의 id를 출력한 뒤 관리 목록에서 제거 (logQ)</span>
<span class="sd">        -관리 목록: priority queue </span>

<span class="sd">Algorithm </span>
<span class="sd">1-1. pq에서 맨 위의 Task를 뽑는다. (아직 제거x) (이득이 최대이고, id가 가장 작은 상품 순으로 뽑힘.)</span>
<span class="sd">2-1. 이미 3.에 의해 삭제된 여행 상품인지 확인한다. (O(1))</span>
<span class="sd">2-2. 존재하는 상품이면, 판매 불가 상품인지 확인한다. (O(1))</span>
<span class="sd">3-1. 위의 조건을 만족하면, id를 출력한 뒤 관리 목록에서 제거한다. (log30000 ~ 10)</span>
<span class="sd">3-3. pq의 모든 상품을 다 돌았는데도 불구하고, 판매가능한 상품이 없으면, -1를 출력하고, 관리 목록에서 제거하지 않는다. </span>


<span class="sd">5. 여행 상품의 출발지 변경 </span>
<span class="sd">- 여행 상품의 출발지를 전부 s로 변경 -&gt; 변경 이후에 각 상품의 cost_id가 변경될 수 있음에 유의 </span>
<span class="sd">- NOTE: `trip_lists`의 모든 Trip에 대해서 start_id와 cost를 변경해서 pq안에서 정렬이 바뀔 수 있도록 해야한다. </span>
<span class="sd">    - 새로 삽입될 때 비교를 해서 넣고, 해당 class안의 variable들을 바꿨다고 우선순위가 변할 것 같지 않음 </span>
<span class="sd">    - 새로 만들때 log(30000) = O(10)</span>
<span class="sd">    - 새로 만들고 기존 변수명에 다시 복사하는 방식을 사용해야함. global 및 [:] 슬라이싱사용. </span>
<span class="sd">- 출발지가 바뀌는 경우, cost를 쉽게 계산하는 법 </span>
<span class="sd">    - dijkstra는 greedy algorithm으로 O(E)로 계산 가능 : 이걸로 최대 15번이니까 15*O(Elog(V))</span>
<span class="sd">    - floyd warshall algorithm은 한번에 2D matrix 계산 O(N^3)이 걸림 </span>
<span class="sd">- NOTE: 새로 변한 start_id에 대해 이후에 command `200`이 나오는 경우에 새로운 `start_id`에 대하여 Trip의 cost등을 계산해야하므로 이를 global variable로 관리해준다. </span>

<span class="sd">- 해당 명령은 최대 15번 주어진다. 0&lt;=s&lt;=n-1 인데, n은 최대 2000개지만, s는 15번만 바뀐다. </span>
<span class="sd">- s가 바뀌면 그에 따른 최단거리도 달라진다. -&gt; Trip의 cost , start_id 가 변해야함. </span>
<span class="sd">- shortest_distance: dict[int, list[int]] 를 저장하는 데이터 구조 필요 -&gt; Trip의 cost는 shortest_distance[start_id][dest_id]로 저장 </span>
<span class="sd">- Dijkstra algorithm을 최대 15번 진행한다고 하면, O(15*(2000+10000)* log(2000)) = 1.3 * 1e6</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span> 
<span class="nb">print</span><span class="p">(</span><span class="mi">12000</span><span class="o">*</span><span class="mi">15</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2000</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">solution</p>
<p>만약 풀리지 않는 test case가 있다면 각 cmd마다 print를 해서 어느 부분이 틀렸는지 검토해보자.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span> 
<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 

<span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span>
<span class="c1"># sys.stdin = open(&#39;Input.txt&#39;)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">graph_init</span><span class="p">(</span><span class="n">num_edges</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="k">global</span> <span class="n">graph</span> 
    <span class="k">for</span> <span class="n">idx_2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">),</span> <span class="mi">3</span><span class="p">):</span>
        <span class="c1"># print(idx)</span>
        <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">edges</span><span class="p">[</span><span class="n">idx_2</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">idx_2</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">idx_2</span><span class="p">]</span>
        <span class="c1"># 자기자신 연결인 경우는 한번만 그래프에 추가 </span>
        <span class="n">graph</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">weight</span><span class="p">,</span> <span class="n">node2</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">node1</span> <span class="o">!=</span> <span class="n">node2</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">node2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">weight</span><span class="p">,</span> <span class="n">node1</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">dijkstra</span><span class="p">(</span><span class="n">start_node</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">shortest_path</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">N</span>
    <span class="c1"># shortest_path: dict[int, list] INIT </span>
    <span class="n">shortest_path</span><span class="p">[</span><span class="n">start_node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">MAX</span><span class="p">]</span><span class="o">*</span> <span class="n">N</span>
    <span class="n">shortest_path</span><span class="p">[</span><span class="n">start_node</span><span class="p">][</span><span class="n">start_node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># INIT at start_node </span>
    <span class="n">q</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start_node</span><span class="p">)]</span> <span class="c1"># (dis, start_node)</span>

    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">cur_dis</span><span class="p">,</span> <span class="n">cur_node</span> <span class="o">=</span>  <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="c1"># min_heap on the first dis element </span>

        <span class="c1"># 1. is already visited?</span>
        <span class="k">if</span> <span class="n">cur_dis</span> <span class="o">&gt;</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">start_node</span><span class="p">][</span><span class="n">cur_node</span><span class="p">]:</span>
            <span class="k">continue</span> 
        
        <span class="c1"># 2. explore next nodes in the graph</span>
        <span class="k">for</span> <span class="n">weight</span><span class="p">,</span> <span class="n">nxt_node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">cur_node</span><span class="p">]:</span>
            <span class="n">dis</span> <span class="o">=</span> <span class="n">cur_dis</span> <span class="o">+</span> <span class="n">weight</span>
            <span class="k">if</span>  <span class="n">dis</span> <span class="o">&lt;</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">start_node</span><span class="p">][</span><span class="n">nxt_node</span><span class="p">]:</span>
                <span class="n">shortest_path</span><span class="p">[</span><span class="n">start_node</span><span class="p">][</span><span class="n">nxt_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">dis</span> 
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="n">dis</span><span class="p">,</span> <span class="n">nxt_node</span><span class="p">))</span>
    <span class="c1"># print(shortest_path)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process_400</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">trip_pq</span>

    <span class="k">while</span> <span class="n">trip_pq</span><span class="p">:</span>
        <span class="n">cur_trip</span> <span class="o">=</span> <span class="n">trip_pq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># 이미 cmd[0]== 300에 의해 삭제된 여행 상품인지 확인</span>
        <span class="c1"># lazy deletion  </span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exist_trip_id</span><span class="p">[</span><span class="n">cur_trip</span><span class="o">.</span><span class="n">id</span><span class="p">]:</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">trip_pq</span><span class="p">)</span>
            <span class="k">continue</span> 

        <span class="c1"># 존재하는 상품이면, 판매 불가 상품인지 확인 </span>
        <span class="k">if</span> <span class="n">cur_trip</span><span class="o">.</span><span class="n">get_cost</span><span class="p">()</span> <span class="o">==</span> <span class="n">MAX</span> <span class="ow">or</span> <span class="n">cur_trip</span><span class="o">.</span><span class="n">get_benefit</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 위의 조건을 다 만족하면, id를 출력한 뒤 관리 목록에서 제거 </span>
            <span class="nb">print</span><span class="p">(</span><span class="n">cur_trip</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">trip_pq</span><span class="p">)</span>
            <span class="c1"># NOTE: 해당 관리 목록에서 삭제해줘야함!!</span>
            <span class="n">exist_trip_id</span><span class="p">[</span><span class="n">cur_trip</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> 
    
    <span class="c1"># trip_pq에 아무원소도 없을 경우 </span>
    <span class="nb">print</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        
<span class="c1"># --------------- 전역 스코프 </span>
<span class="n">Q</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="c1"># 데이터 구조 INIT </span>
<span class="n">MAX</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>
<span class="n">shortest_path</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">trip_pq</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;Trip&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> 
<span class="n">exist_trip_id</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">cur_start_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># graph 는 아래서 </span>
<span class="k">class</span><span class="w"> </span><span class="nc">Trip</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">revenue</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dest_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">start_id</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">revenue</span> <span class="o">=</span> <span class="n">revenue</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">dest_id</span> <span class="o">=</span> <span class="n">dest_id</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">start_id</span> <span class="o">=</span> <span class="n">start_id</span> <span class="c1"># 변할 수 있음. </span>
        <span class="c1"># self.cost = MAX  # start 와 dest을 알면 shortest_path에 바로 접근해서 알 수 있고, 아래 get_benefit() 함수에서 그걸 구현해놓음. </span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">my_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_benefit</span><span class="p">()</span>
        <span class="n">other_b</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_benefit</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">my_b</span> <span class="o">==</span> <span class="n">other_b</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span> 
        <span class="k">return</span> <span class="n">my_b</span> <span class="o">&gt;</span> <span class="n">other_b</span> 
    
    <span class="k">def</span><span class="w"> </span><span class="nf">get_benefit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># Revenue - current_cost </span>
        <span class="k">global</span> <span class="n">shortest_path</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_id</span> <span class="ow">in</span> <span class="n">shortest_path</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">revenue</span> <span class="o">-</span> <span class="n">shortest_path</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start_id</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">dest_id</span><span class="p">]</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">get_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">global</span> <span class="n">shortest_path</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_id</span> <span class="ow">in</span> <span class="n">shortest_path</span> 
        <span class="k">return</span> <span class="n">shortest_path</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start_id</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">dest_id</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Trip(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">)&quot;</span>
    
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="p">):</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
    <span class="c1"># if cmd == [300, 3]:</span>
    <span class="c1">#     print(&#39;a&#39;)</span>
    <span class="k">if</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">100</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">M</span><span class="o">=</span><span class="n">cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
        <span class="n">exist_trip_id</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="mi">30001</span>
        <span class="n">graph_init</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span> <span class="c1"># m, [node1, end1, weight1,... ]</span>
        <span class="c1"># print(graph)</span>
        <span class="n">dijkstra</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># start node= 0 </span>
        <span class="c1"># print(shortest_path)</span>

    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">trip_pq</span><span class="p">,</span> <span class="n">Trip</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">revenue</span><span class="o">=</span><span class="n">cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">dest_id</span><span class="o">=</span><span class="n">cmd</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">start_id</span><span class="o">=</span><span class="n">cur_start_id</span><span class="p">))</span>
        <span class="n">exist_trip_id</span><span class="p">[</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># 해당 여행이 존재 </span>
        <span class="c1"># print(f&quot;Add Trip {cmd[1]}&quot;)</span>
        <span class="c1"># print(f&quot;  trip_pq: {trip_pq}&quot;)</span>
        <span class="c1"># print(f&quot;  exist_trip: {exist_trip_id[cmd[1]]}&quot;)</span>

    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">300</span><span class="p">:</span>
        <span class="n">cur_id</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">exist_trip_id</span><span class="p">[</span><span class="n">cur_id</span><span class="p">]:</span> <span class="c1"># 존재하면 </span>
            <span class="n">exist_trip_id</span><span class="p">[</span><span class="n">cur_id</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span> 

        <span class="c1"># print(f&quot;Delete Trip {cur_id}&quot;)</span>
        <span class="c1"># print(f&quot;  trip_pq: {trip_pq}&quot;)</span>
        <span class="c1"># print(f&quot;  exist_trip: {exist_trip_id[cur_id]}&quot;)</span>


    <span class="c1"># 최적의 여행 상품 판매 </span>
    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">400</span><span class="p">:</span>
        <span class="c1"># print(f&quot;여행 상품 판매&quot;)</span>
        <span class="n">process_400</span><span class="p">()</span>
        <span class="c1"># print(f&quot;  trip_pq: {trip_pq}&quot;)</span>



    <span class="c1"># 여행 상품의 출발지 변경 </span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># cmd[0] == 500:</span>
        <span class="c1"># print(f&quot;-------출발지 변경&quot;)</span>
        <span class="c1"># print(f&quot;before: {trip_pq}&quot;)</span>
        <span class="c1">##### global로 start_id 를 변경해줘야 나중에 200으로 들어왔을 때, 해당 start_id에 대해 task가 정렬됨. </span>
        <span class="n">cur_start_id</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">new_trip_pq</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># 1. 새로운 출발점에 대한 shortest_path 계산 먼저 해야 cost 계산에 의해 heapq에서 정렬됨. </span>
        <span class="n">dijkstra</span><span class="p">(</span><span class="n">cur_start_id</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cur_trip</span> <span class="ow">in</span> <span class="n">trip_pq</span><span class="p">:</span>
            <span class="c1"># 여기서도 lazy deletion해준다. </span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">exist_trip_id</span><span class="p">[</span><span class="n">cur_trip</span><span class="o">.</span><span class="n">id</span><span class="p">]:</span>
                <span class="k">continue</span> 
            <span class="n">cur_trip</span><span class="o">.</span><span class="n">start_id</span> <span class="o">=</span> <span class="n">cur_start_id</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">new_trip_pq</span><span class="p">,</span> <span class="n">cur_trip</span><span class="p">)</span>

        <span class="n">trip_pq</span> <span class="o">=</span> <span class="n">new_trip_pq</span><span class="p">[:]</span>
        <span class="c1"># debug </span>
        <span class="c1"># print(f&quot;start node {cur_start_id}: {trip_pq}&quot;)</span>
        <span class="c1"># print([exist_trip_id[cur_trip.id] for cur_trip in trip_pq])</span>
        <span class="c1"># print(f&quot;-------출발지 변경 끝&quot;)</span>
</pre></div>
</div>
</div>
</section>
<section id="id7">
<h3>해적 선장 코디<a class="headerlink" href="#id7" title="Link to this heading">#</a></h3>
<p>해당 문제는 제일 우선순위가 높은 1개를 뽑는 것이 아닌, 조건에 맞는 최대 5개의 선박을 고를 수 있다는 것에 있다.</p>
<div class="dropdown admonition">
<p class="admonition-title">explanation</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">- &#39;코디&#39;라는 이름의 선장이 `대형 선박` 1개을 침몰시키려고 한다. </span>
<span class="sd">- 총 T개의 명령 </span>
<span class="sd">- &#39;코디&#39;는 여러척의 공격할 수 있는 선박을 가지고 있다. </span>
<span class="sd">- 각 명령은 1시간 단위로 실행된다. i번째 명령이 수행된 뒤, 1시간이 지나면 i+1번째 명령이 수행된다. </span>


<span class="sd">필요한 자료 구조 </span>
<span class="sd">- class Ship </span>
<span class="sd">    - __lt__ : sort()에서 key에 사용될 함수 필요 이거 __lt__로 구현해도 되는건가?</span>
<span class="sd">    - __init__: id, 재장전 시간 (r), 공격력 (p), status = 0 </span>
<span class="sd">    - 다른 변수들: 공격에 사용된 시간 (used_time)</span>
<span class="sd">    - 현재 시간이 t인데, abs(used_time - t) &gt;= r이면 status를 0으로 바꾸어야함. </span>
<span class="sd">- ship_pq: priority queue 최우선 선박순으로 나열</span>
<span class="sd">    - status </span>
<span class="sd">    - pw</span>
<span class="sd">    - id </span>
<span class="sd">- id_to_ship_dict: cmd 300때 Id에 따라서 선박에 바로 접근할 수 있도록 함. </span>
<span class="sd">    - object sharing 필요 (어디에서 해당 object안의 variable값을 바꾸어도 나중에 접근할때도 동일한 값이도록)</span>
<span class="sd">- used_ship_list: </span>
<span class="sd">    - cmd 400의 맨 위에서 재정비할 ship들이 있는 지 분석 </span>

<span class="sd">각 cmd뒤에 다른 cmd를 할 때 영향을 주는 것이 있는 지 확인 </span>

<span class="sd">아래의 명령의 순서를 확인했을 때, cmd 400이 들어오기 전에 `ship_lists`는 반드시 정렬되어 있어야한다. </span>

<span class="sd">- 200 -&gt; 200: 지원 요청 (`id_to_ship_dict`와 `ship_lists`에 추가) -&gt; 지원 요청  </span>
<span class="sd">- 200 -&gt; 300: 지원 요청한 후, 함포 교체 `id_to_ship_dict` 에서 object안의 변수 바꾸면 됨. </span>
<span class="sd">- 200 -&gt; 400: 지원 요청 -&gt; 공격 명령</span>
<span class="sd">    - 공격 명령 전에, sort()안에서 지원 요청때도 다시 sort()가 필요함. 그럼 평균 O(30000log30000) ~ 3 * 1e5 걸림. </span>
<span class="sd">    - queue:</span>
<span class="sd">        - 지원 요청 200: O(logN)</span>
<span class="sd">        - 공격: 최대 5개인데, O(logN) 을 최대 N개 해야할 수도 있다. </span>
<span class="sd">        - 교체 후 다시 넣기 : O(logN), lazy check해야함. 나중에 공격전에</span>
<span class="sd">    - sort():</span>
<span class="sd">        - 지원 요청시 삽입 O(1)</span>
<span class="sd">        - 공격: sort()를 진행 NlogN -&gt; 최적의 Ship찾기 (O(1) 이도 마찬가지로 dictionary에 접근하여 list안의 원소를 바꿔준후, 다시 sort()를 하면 NlogN이 된다. </span>


<span class="sd">- 300 -&gt; 200: 교체 후 지원 요청 </span>
<span class="sd">    - 교체하고, 하나 추가하면 order가 바뀌어야하는데...? </span>
<span class="sd">- 300 -&gt; 300: 교체 후 또 교체  </span>
<span class="sd">- 300 -&gt; 400: 교체 후 공격 명령</span>
<span class="sd">    - queue: 문제는 어떤 Ship이 1 -&gt; 100000으로 공격력이 높아졌을 때, 다시 안 넣으면 우선순위 큐 맨 앞에 있지 않아서 다시 넣어야하고</span>
<span class="sd">        - NOTE: 이때 dictionary에 있는 Ship을 교체하면 sort() list안에 있는 객체도 바뀐다.</span>
<span class="sd">        - 다만, 객체의 정보가 바뀐다고 해서 queue안에 정렬순서가 바뀌지는 않게된다. 따라서, 새로운 객체를 다시 삽입 (logN)하고 </span>
<span class="sd">        - NOTE: 만약 공격 명령때 같은 id가 나오면 삭제한다. (logN)</span>
<span class="sd">        - 최대 5개를 뽑아야하지만, 최대 N=3*1e4라고 하면, 5000* NlogN (최대 N개에 대해서 pop을 함, 이 cmd는 최대 5000번이 주어짐)</span>
<span class="sd">            -&gt; 2*1e9 NOTE: 시간초과 </span>
<span class="sd">        - 그러면, 맨 앞의 원소들은 status=0이며, 우선순위가 높은 것으로 하면 5000 * NlogN이 아니라, 5000*5*logN으로 줄어든다. </span>

<span class="sd">    - sort:</span>
<span class="sd">        - 교체를 한후</span>
<span class="sd">        - 400 function안에서 sort()를 진행 NlogN 최대 5000번까지 주어짐. -&gt; N이 최대 3*1e4라고 하면,  2*1e9 NOTE: 시간초과 </span>
<span class="sd">        - 또한 sort()후 각 인덱스에서 최대 N=3*1e4개 중 status가 0인 선박을 찾고 등등 해야함. </span>
<span class="sd">        -&gt; 더 많이 걸림 </span>


<span class="sd">- 400 -&gt; 200: 공격 후 지원 요청 </span>
<span class="sd">- 400 -&gt; 300: 공격 후 교체 (공격력만 교체)</span>
<span class="sd">- 400 -&gt; 400: 공격 후 공격 </span>
<span class="sd">    - 생각해보니, 공격을 한 후에는 재점검 시간이 필요해서 다시 공격할 수 없음 </span>
<span class="sd">    - stauts를 재정비 (1)로 바꾸고, 이경우에는 사용할 수 없도록 해야함. </span>
<span class="sd">        - 이 때, status=1이지만, current_time - 공격시간 &gt;= r 이면 공격 가능함. </span>
<span class="sd">    - 따러 used_ships을 설정하면 시간 관리도 해야해서 로직이 복잡해짐. 재정비 시간이 지나면 다시 status를 하나하나 바꿔야해서 복잡해짐. </span>
<span class="sd">    - 공격때 사용한 ship들을 따로 list로 최대 len(5)로 관리하고, </span>
<span class="sd">    - 공격 때 queue에서 pop한 다음, 다시 Status를 1로 해서 insert한다. </span>
<span class="sd">    - 다만, 재정비시간이 1인 경우는 다음에 바로 사용할 수 있으며, </span>
<span class="sd">    - 또 공격이 계속 연달아 있는 경우에 대비하여, status들을 바로 바꿔줘야하는데, 이때 재정비 시간이 지나서 다시 공격할 수 있는 상황에서는 </span>
<span class="sd">        - status로 관리하게 되면 불편한 경우가 있다. </span>
<span class="sd">    - queue를 __lt__를 </span>
<span class="sd">        - status </span>
<span class="sd">        - 공격력 , Id </span>
<span class="sd">    - 공격때 사용된 ships들은 5*5000번 =&gt; 최대 3e4개일 수 있는데, </span>
<span class="sd">        - 이를 하나하나 돌아가면서, 재정비하면 status를 바꾸고 queue에 다시 삽입하면, O(3e4* log(4e4)) ~ 3e5 정도의 시간이 걸린다. </span>
<span class="sd">    </span>

<span class="sd">1. 공격 준비 (100 N id_1 p_1 r_1 id_2 p_2 r_2 ...... id_N p_N r_N)</span>
<span class="sd">- &#39;코디&#39;의 N척의 선박에 사격 준비를 지시 </span>
<span class="sd">- 각 ship은 id, power (공격력, p), 재장전 시간 (r), status (초기는 모두 사격대기)를 가짐 </span>
<span class="sd">    - status: 사격 대기 (INIT, 0) -&gt; 공격 후 재장전 1  (r시간이 경과하면 사격대기로 전환)</span>
<span class="sd">        - lazy check 해야할 것 같음. </span>
<span class="sd">    - 이를 위한 class Ship 이 필요함 </span>

<span class="sd">2. 지원 요청 (200 id p r)</span>
<span class="sd">- 추가 병력을 요청하여 1개의 새로운 선박이 합류됨 </span>
<span class="sd">- 새로 합류한 선반 (status = 사격 대기 0, 선박 번호 id, 공격력 p, 재장선 시간 r)</span>
<span class="sd">- 이 명령은 최대 30,000번까지 주어짐.</span>
<span class="sd">- id_to_ships와 ship_list 두개 다에 삽입 </span>

<span class="sd">3. 함포 교체 (300 id pw)</span>
<span class="sd">- 이 명령은 최대 10,000번까지 주어짐. 존재하지 않는 선박 번호 id가 주어지지 않음. </span>
<span class="sd">- id번의 선박의 함포를 교체 </span>
<span class="sd">    - id번의 선박에 바로 접근할 수 있어야함. </span>
<span class="sd">    - 문제는 1 &lt;= id &lt;= 1e9, 너무큰데...? memory limit이 128 MB인데, int가 4byte이면 32*10^6개의 밖에 list형성 불가 </span>
<span class="sd">    - 이때 명령의 개수가 최대 50,000개 이므로 dictionary로 저장하면, 2*1e5개 저장, Ship class도 하나당 9 byte라고 하면, 4.5 * 1e5이므로 </span>
<span class="sd">    - 일단 `id_to_ship_dict: dict[int, Ship]`으로 만듦. </span>
<span class="sd">    - 이때 id를 찾을 때 time complexity는 string이 아니라 int라서 O(1)? </span>
<span class="sd">- 교체 후 해당 선박의 공격력은 pw가 된다.</span>
<span class="sd">- 교체 된 선박은 바로 ships_lists에 넣어줘야 다음에 바로 공격 명령이 들어와도 사용가능하다. </span>
<span class="sd">    - 예전 Ships은 lazy check로 나중에 valid check를 할 수 있다. </span>
<span class="sd">    - dict에 있는 ships안의 정보만 바꾸면, queue안에 같은 id이고 같은 pw를 가진 object가 두 개가 존재하게 된다. 두번 넣었으므로. </span>
<span class="sd">    - 따라서, 같은 id인지 확인만 해주면 된다. </span>

<span class="sd">4. 공격 명령 (400)</span>
<span class="sd">- 최대 5000번까지 주어짐. 이 부분이 시간 복잡도의 최대 bottle neck일 것 같음. </span>
<span class="sd">- 사격 대기 (0) 상태인 선박 중 공격력이 가장 높은 선박 최대 5척에 일제 사격을 명령한다. </span>
<span class="sd">    - 최대 5척이므로 사용가능한 선박의 수가 그것보다 작을 경우에는 더 적을 수도 있다. </span>
<span class="sd">    - 재장전 중인 선박은 공격에 사용불가 </span>
<span class="sd">        - 해당 선박이 현재 시간이 공격 후 r시간이 지났으면 사격 대기로 바꿀 수 있음. </span>
<span class="sd">        - 만약 선박의 재장전 시간이 1초이면 1초에 공격했으면 2초때 바로 공격 가능 (즉, 시간 차이 &gt;= r 임.)</span>
<span class="sd">    - 우선순위 </span>
<span class="sd">        - 공격력이 높다. </span>
<span class="sd">        - 공격력이 같다면, 선박 번호 id가 작은 선박 </span>
<span class="sd">        - 총 피해가 최대가 되도록 선박을 고른다. (피해 = 사격에 참여한 선박들의 공격력 합)</span>
<span class="sd">    - 맨 앞의 5개를 꺼낼 때 sort()이면 O(1)이지만, heapq를 쓰면 O(5logN)시간이 걸림. </span>
<span class="sd">        - sort(): Tlog(T): 앞에 5개의 원소에 접근 및 마지막에 다시 sort해줄 때 Tlog(T)시간이 걸림 </span>
<span class="sd">            - sort()로 해야할 것 같음. </span>
<span class="sd">        - heapq: ~ 3 * 1e6 * 2 (제거하고 다시 사격대기로 전환해서 삽입시켜줘야함) 5T(logT)</span>
<span class="sd">- 사격에 참여한 선박들의 공격력 합만큼 대형 함선에 피해를 준다. </span>
<span class="sd">    - Total_attacked: int = 대형 함선이 가진 피해</span>
<span class="sd">- 사격한 선반은 즉시 재장전에 들어가며, 사격 시점을 포함해 r시간이 경과하면 다시 &#39;사격 대기(0)&#39; 상태로 전환된다. </span>

<span class="sd">- 공격 명령이 떨어지면, 아래의 3개 출력 </span>
<span class="sd">    - &#39;해당 차례&#39;의 총 피해량 </span>
<span class="sd">    - 사격에 참여한 선박 수(최대 5척)</span>
<span class="sd">    - 사격 우선순위에 따른 사격 선박들의 id </span>


<span class="sd">Algorithm for 400 </span>
<span class="sd">1-1. 사용한 ship들에 대해 재정비 시간이 만료된 ship들에 대해서 queue에 다시 삽입한다. </span>
<span class="sd">    - 이때 재정비된 Ships list에서 제거한다. </span>
<span class="sd">    - status 0, used_time = -1 인 친구들 다시 삽입 </span>
<span class="sd">2-1. queue의 맨 앞에서부터 &#39;최대&#39; 5개를 뽑는다. </span>
<span class="sd">    - 이번에 사용할 id와 같은 것이 있으면 pass 하면서 최대 5개를 뽑는다. </span>
<span class="sd">        - 이때는 중복된 object이므로 버린다. </span>
<span class="sd">    - 교체된 pw와 같은지 id_to_ships에서 정보를 확인하고 같지 않으면 pop -&gt; object sharing이라서 같은지 아닌지 확인안해도됨. </span>
<span class="sd">        - (어차피 status, pw, id순으로 되어 있기 때문에, 위의 스텝에서 정확히 재정비된 것들을 다시 넣었다면, 맨 앞의 5개가 맞음)</span>
<span class="sd">    -  다음 3개의 정보를 저장하고 출력한다. </span>
<span class="sd">        - &#39;해당 차례&#39;의 총 피해량 </span>
<span class="sd">        - 사격에 참여한 선박 수(최대 5척)</span>
<span class="sd">        - 사격 우선순위에 따른 사격 선박들의 id </span>
<span class="sd">3-1. 사용된 함선들은 used_ships에 저장한다. </span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">math</span> 

<span class="c1"># 공격 명령이 총 T번 (최대 5*1e4) 일때 우선순위 큐를 사용하면 cmd 4의 시간 복잡도  </span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="mf">1e3</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">30000</span>
<span class="c1"># print(T*5 * math.log(T)) # 3 * 1e6</span>
<span class="c1"># print(T * math.log(T))</span>
<span class="c1"># print(N * math.log(N)) # 3 * 1e5</span>
<span class="c1"># print(N*math.log(N) * T)</span>
<span class="nb">print</span><span class="p">(</span><span class="mf">1e4</span><span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">4e4</span><span class="p">))</span> <span class="c1"># 1 * 1e5</span>


<span class="c1"># class Ship:</span>
<span class="c1">#     def __init__(self, id: int, p: int, r:int):</span>
<span class="c1">#         self.id = id </span>
<span class="c1">#         self.p = p </span>
<span class="c1">#         self.r = r </span>
<span class="c1">#         self.status = 0 </span>
<span class="c1">#     def __repr__(self):</span>
<span class="c1">#         return f&quot;Ship({self.id} with p {self.p})&quot;</span>

<span class="c1"># my_ship1 = Ship(1, 2, 3)</span>
<span class="c1"># my_ship2 = Ship(2, 3, 4)</span>

<span class="c1"># ship_list = [my_ship1, my_ship2]</span>
<span class="c1"># ship_dict = {</span>
<span class="c1">#     my_ship1.id: my_ship1,</span>
<span class="c1">#     my_ship2.id: my_ship2</span>
<span class="c1"># }</span>
<span class="c1"># def change_ship(cur_ship, pw):</span>
<span class="c1">#     cur_ship.p = pw </span>

<span class="c1"># print(f&quot;Before {ship_list}&quot;)</span>
<span class="c1"># # change_ship(ship_list[1], 10)</span>
<span class="c1"># change_ship(ship_dict[1], 10)</span>
<span class="c1"># print(f&quot;After {ship_list}&quot;)</span>


<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 

<span class="k">class</span><span class="w"> </span><span class="nc">Ship</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">used_time</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># 사용되었던 시간 </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 대기 0, 재장전 1 </span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">status</span><span class="p">:</span> 
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">status</span> <span class="c1"># 대기하는 선박의 우선순위가 높음. </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">p</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">p</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span> 
    
    <span class="k">def</span><span class="w"> </span><span class="nf">can_change_to_ready_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_t</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># 재정비 시간 r이 지나면 재정비 가능 </span>
        <span class="k">return</span> <span class="n">cur_t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">used_time</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span> 
    
    <span class="k">def</span><span class="w"> </span><span class="nf">reinit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">used_time</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 

    <span class="c1"># def __repr__(self):</span>
    <span class="c1">#     return f&quot;Ship(id: {self.id})(p: {self.p})(r: {self.r})&quot;</span>

<span class="c1"># ship1 = Ship(1, 10, 3)</span>
<span class="c1"># ship2 = Ship(2, 1, 3)</span>
<span class="c1"># cur_t = 10 </span>
<span class="c1"># ships_pq = []</span>
<span class="c1"># used_ship_list = [ship1, ship2]</span>

<span class="c1"># used_ship_list_copy = used_ship_list[:]</span>
<span class="c1"># for used_ship in used_ship_list_copy:</span>
<span class="c1">#     if used_ship.can_change_to_ready_status(cur_t=cur_t):</span>
<span class="c1">#         used_ship.reinit()</span>
<span class="c1">#         heapq.heappush(ships_pq, used_ship)</span>
<span class="c1">#         # used_ship을 제거해야하는데 for loop돌고 있는 상황에서 제거하면 길이가 달라져서 안됨. </span>
<span class="c1">#         # 따라서 copy 를 만들어서 제거해줌 </span>
<span class="c1">#         # NOTE: 원본에서 제거해도 used_ship_list_copy는 그대로 인지 확인 </span>
<span class="c1">#         used_ship_list.remove(used_ship)</span>

<span class="n">ship1</span> <span class="o">=</span> <span class="n">Ship</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">ship2</span> <span class="o">=</span> <span class="n">Ship</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="n">my_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Ship</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">my_dict</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ship1</span> 
<span class="n">my_dict</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ship2</span>

<span class="n">pq</span> <span class="o">=</span> <span class="p">[</span><span class="n">ship2</span><span class="p">]</span>


<span class="n">cur_ship</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">pq</span><span class="p">)</span>
<span class="n">ship3</span> <span class="o">=</span> <span class="n">Ship</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1"># cur_ship = ship3  # 이렇게 하면 변수가 가리키는 것만 바뀌어서 안됨. </span>
<span class="n">my_dict</span><span class="p">[</span><span class="n">cur_ship</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">ship3</span> 

<span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">)</span>

<span class="n">my_list</span><span class="o">=</span> <span class="p">[]</span>

<span class="n">my_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">my_dict</span><span class="p">[</span><span class="n">cur_ship</span><span class="o">.</span><span class="n">id</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">my_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">[</span><span class="n">cur_ship</span><span class="o">.</span><span class="n">id</span><span class="p">])</span>

</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">object sharing</p>
<p>파이썬에서는 같은 Object를 List나 dictionary에 저장해두고,
dictionary 안의 object안의 variable을 변환해주면, 이를 가지고 있던 List 안의 같은 object도 변해있음을 확인할 수 있다.
이는 파이썬이 객체를 sharing하는 기능을 가졌기 때문에 가능하다. 아래 코드로 확인할 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Ship</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span> 
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Ship(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> with p </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="si">}</span><span class="s2">)&quot;</span>

<span class="n">my_ship1</span> <span class="o">=</span> <span class="n">Ship</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">my_ship2</span> <span class="o">=</span> <span class="n">Ship</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="n">ship_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">my_ship1</span><span class="p">,</span> <span class="n">my_ship2</span><span class="p">]</span>
<span class="n">ship_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">my_ship1</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="n">my_ship1</span><span class="p">,</span>
    <span class="n">my_ship2</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="n">my_ship2</span>
<span class="p">}</span>
<span class="k">def</span><span class="w"> </span><span class="nf">change_ship</span><span class="p">(</span><span class="n">cur_ship</span><span class="p">,</span> <span class="n">pw</span><span class="p">):</span>
    <span class="n">cur_ship</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">pw</span> 

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Before </span><span class="si">{</span><span class="n">ship_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="c1"># change_ship(ship_list[1], 10)</span>
<span class="n">change_ship</span><span class="p">(</span><span class="n">ship_dict</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After </span><span class="si">{</span><span class="n">ship_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">copy of a list</p>
<p>used_ship을 제거해야하는데 for loop돌고 있는 상황에서 제거하면 길이가 달라져서 안됨.  따라서 copy 를 만들어서 제거해줌
즉, 원본에서 제거해도 used_ship_list_copy는 그대로 인지 확인</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ship1</span> <span class="o">=</span> <span class="n">Ship</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">ship2</span> <span class="o">=</span> <span class="n">Ship</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">cur_t</span> <span class="o">=</span> <span class="mi">10</span> 
<span class="n">ships_pq</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">used_ship_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">ship1</span><span class="p">,</span> <span class="n">ship2</span><span class="p">]</span>

<span class="n">used_ship_list_copy</span> <span class="o">=</span> <span class="n">used_ship_list</span><span class="p">[:]</span>
<span class="k">for</span> <span class="n">used_ship</span> <span class="ow">in</span> <span class="n">used_ship_list_copy</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">used_ship</span><span class="o">.</span><span class="n">can_change_to_ready_status</span><span class="p">(</span><span class="n">cur_t</span><span class="o">=</span><span class="n">cur_t</span><span class="p">):</span>
        <span class="n">used_ship</span><span class="o">.</span><span class="n">reinit</span><span class="p">()</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">ships_pq</span><span class="p">,</span> <span class="n">used_ship</span><span class="p">)</span>
        <span class="c1"># used_ship을 제거해야하는데 for loop돌고 있는 상황에서 제거하면 길이가 달라져서 안됨. </span>
        <span class="c1"># 따라서 copy 를 만들어서 제거해줌 </span>
        <span class="c1"># NOTE: 원본에서 제거해도 used_ship_list_copy는 그대로 인지 확인 </span>
        <span class="n">used_ship_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">used_ship</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">여러 가지 데이터 구조안의 object 맞춰주기</p>
<p>이 문제의 경우 cmd 300에서 power를 바꿔주면, dictionary는 바로 업데이트할 수 있지만, ships_pq나 used_ship에서는 바로 바꾸기 힘들다.</p>
<p>따라서 lazy evaluation을 진행하는데,
문제는 heapq에 push할때 object sharing이 되어 있는 원소를 넣으면 둘은 완전히 동일한 값의 object이기 때문에 ships_pq 가 의도한대로 갱신되지 않는다.</p>
<p>예를 들어, ship(2, 3, 2)가 pw=13으로 제일 커져서 맨 위로 올라가야한느데, 이미 pq에 있는 ship(2, 3, 2)가 ship(2, 13, 2)로 바뀌고 순위는 변동이 없기 때문에 새로이 ship(2, 13, 2)을 넣어도 원하는대로 순위 변동이 일어나지 않는다.</p>
<p>따라서, 새로운 기존 Ship 정보를 바꾸지 않고, 새로운 object 생성 후 넣어준 후, dictionary값을 새로운 Ship으로 교체한다.</p>
<p>그리고 난후, pq나 list에서 정보를 뽑을 때, lazy deletion 만약, 해당 Ship의 power가 바뀌었거나 status가 이미 변했으면, dictionary 값을 통해 삭제하거나 무시한다.</p>
<p>아래는 dictionary값을 새로운 Ship으로 교체해야함을 알려준다. 기존 값을 바꾸면 두 가지 object가 다르므로 혼란이 온다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 

<span class="k">class</span><span class="w"> </span><span class="nc">Ship</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">used_time</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># 사용되었던 시간 </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 대기 0, 재장전 1 </span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">status</span><span class="p">:</span> 
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">status</span> <span class="c1"># 대기하는 선박의 우선순위가 높음. </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">p</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">p</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span> 
    
    <span class="k">def</span><span class="w"> </span><span class="nf">can_change_to_ready_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_t</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># 재정비 시간 r이 지나면 재정비 가능 </span>
        <span class="k">return</span> <span class="n">cur_t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">used_time</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span> 
    
    <span class="k">def</span><span class="w"> </span><span class="nf">reinit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">used_time</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 

<span class="n">ship1</span> <span class="o">=</span> <span class="n">Ship</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">ship2</span> <span class="o">=</span> <span class="n">Ship</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="n">my_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Ship</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">my_dict</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ship1</span> 
<span class="n">my_dict</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ship2</span>

<span class="n">pq</span> <span class="o">=</span> <span class="p">[</span><span class="n">ship2</span><span class="p">]</span>


<span class="n">cur_ship</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">pq</span><span class="p">)</span>
<span class="n">ship3</span> <span class="o">=</span> <span class="n">Ship</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1"># cur_ship = ship3  # 이렇게 하면 변수가 가리키는 것만 바뀌어서 안됨. </span>
<span class="n">my_dict</span><span class="p">[</span><span class="n">cur_ship</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">ship3</span> 

<span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">)</span>

<span class="n">my_list</span><span class="o">=</span> <span class="p">[]</span>

<span class="n">my_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">my_dict</span><span class="p">[</span><span class="n">cur_ship</span><span class="o">.</span><span class="n">id</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">my_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">[</span><span class="n">cur_ship</span><span class="o">.</span><span class="n">id</span><span class="p">])</span>

</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">solution</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span> 
<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 

<span class="c1"># sys.stdin = open(&#39;Input.txt&#39;)</span>
<span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span> 

<span class="k">class</span><span class="w"> </span><span class="nc">Ship</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">used_time</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># 사용되었던 시간 </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 대기 0, 재장전 1 </span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_used_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">used_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">used_time</span> <span class="o">=</span> <span class="n">used_time</span> 
    <span class="k">def</span><span class="w"> </span><span class="nf">set_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span> 

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">status</span><span class="p">:</span> 
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">status</span> <span class="c1"># 대기하는 선박의 우선순위가 높음. </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">p</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">p</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span> 
    
    <span class="k">def</span><span class="w"> </span><span class="nf">can_change_to_ready_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_t</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># 재정비 시간 r이 지나면 재정비 가능 </span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1"># 이미 사용된 상태여야한다. </span>
        <span class="k">return</span> <span class="n">cur_t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">used_time</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span> 
    
    <span class="k">def</span><span class="w"> </span><span class="nf">reinit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">used_time</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">process_100</span><span class="p">(</span><span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ships_info</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="k">global</span> <span class="n">ships_pq</span><span class="p">,</span> <span class="n">ship_id_to_dict</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="c1"># print(idx)</span>
        <span class="n">cur_id</span><span class="p">,</span> <span class="n">cur_pw</span><span class="p">,</span> <span class="n">cur_r</span> <span class="o">=</span> <span class="n">ships_info</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">ships_info</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ships_info</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">cur_ship</span> <span class="o">=</span> <span class="n">Ship</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">cur_id</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">cur_pw</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">cur_r</span><span class="p">)</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">ships_pq</span><span class="p">,</span> <span class="n">cur_ship</span><span class="p">)</span> <span class="c1"># object sharing </span>
        <span class="n">ship_id_to_dict</span><span class="p">[</span><span class="n">cur_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_ship</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">process_200</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">ship_id_to_dict</span><span class="p">,</span> <span class="n">ships_pq</span> 
    <span class="n">new_ship</span> <span class="o">=</span> <span class="n">Ship</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">)</span>
    <span class="c1"># object sharing </span>
    <span class="n">ship_id_to_dict</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_ship</span> <span class="c1"># id는 중복되지 않음 </span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">ships_pq</span><span class="p">,</span> <span class="n">new_ship</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">process_300</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">new_pw</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cur_t</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">ship_id_to_dict</span><span class="p">,</span> <span class="n">ships_pq</span>

    <span class="c1"># ship_id_to_dict[id].p = new_pw # object sharing이 되어 있어서 pq안에도 바뀜 </span>
    <span class="c1"># 300 명령 다음에 바로 400하는 경우, 재정렬이 안됨. 즉, 위에서 교체만 한다고해서, 재정렬이 안되기 때문에, 가장 우선순위가 높은 것이 앞에오도록 삽입해줘야함. </span>
    <span class="c1"># NOTE: 원소를 바로 넣는 것도 object sharing 임. </span>

    <span class="c1"># 교체했으면 dictionary에 있는 것과 현재 heapq로 넣는게 또 같아져버림. </span>
    <span class="c1"># 우선순위가 제대로 되어있게 하기 위해 새로운 것을 넣어줌. </span>
    <span class="c1"># NOTE: 이전에 있는 것이 잘못되어 있으면 버려야함. (lazy check)</span>
    <span class="c1"># 근데 이때 바뀔 ship이 사용상태가 0인지 1인지 모름 </span>
    <span class="n">new_ship</span> <span class="o">=</span> <span class="n">Ship</span><span class="p">(</span><span class="n">ship_id_to_dict</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">new_pw</span><span class="p">,</span> <span class="n">ship_id_to_dict</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span><span class="o">.</span><span class="n">r</span><span class="p">)</span>
    <span class="n">new_ship</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="n">ship_id_to_dict</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
    <span class="n">new_ship</span><span class="o">.</span><span class="n">set_used_time</span><span class="p">(</span><span class="n">ship_id_to_dict</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span><span class="o">.</span><span class="n">used_time</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">new_ship</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">new_ship</span><span class="o">.</span><span class="n">can_change_to_ready_status</span><span class="p">(</span><span class="n">cur_t</span><span class="p">):</span>
        <span class="n">new_ship</span><span class="o">.</span><span class="n">reinit</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">new_ship</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">ships_pq</span><span class="p">,</span> <span class="n">new_ship</span><span class="p">)</span> <span class="c1"># 이것도 object sharing인가? YES </span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># new_ship.status == 1:</span>
        <span class="n">used_ship_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_ship</span><span class="p">)</span> <span class="c1"># 추후에 lazy detection 필요 </span>

    <span class="n">ship_id_to_dict</span><span class="p">[</span><span class="n">ship_id_to_dict</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_ship</span>

<span class="k">def</span><span class="w"> </span><span class="nf">process_400</span><span class="p">(</span><span class="n">cur_t</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">used_ship_list</span><span class="p">,</span> <span class="n">ships_pq</span><span class="p">,</span> <span class="n">ship_id_to_dict</span>

    <span class="c1"># 이미 공격한 함선 중, 다시 재정비 할 수 있는 ship들을 ships_pq에 삽입 </span>
    <span class="n">used_ship_list_copy</span> <span class="o">=</span> <span class="n">used_ship_list</span><span class="p">[:]</span>
    <span class="k">for</span> <span class="n">used_ship</span> <span class="ow">in</span> <span class="n">used_ship_list_copy</span><span class="p">:</span>
        <span class="c1"># lazy deletion over cmd 300 </span>
        <span class="k">if</span> <span class="n">used_ship</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">ship_id_to_dict</span><span class="p">[</span><span class="n">used_ship</span><span class="o">.</span><span class="n">id</span><span class="p">]</span><span class="o">.</span><span class="n">status</span><span class="p">:</span>
            <span class="c1"># NOTE: 원본에서 제거해도 used_ship_list_copy는 그대로!</span>
            <span class="n">used_ship_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">used_ship</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="c1"># 이미 300에서 변한 경우에 ship_pq에 넣어줘서 괜찮음. </span>
        <span class="k">if</span> <span class="n">used_ship</span><span class="o">.</span><span class="n">p</span> <span class="o">!=</span> <span class="n">ship_id_to_dict</span><span class="p">[</span><span class="n">used_ship</span><span class="o">.</span><span class="n">id</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="p">:</span>
            <span class="n">used_ship_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">used_ship</span><span class="p">)</span>
            <span class="k">continue</span> 

            <span class="c1"># </span>

        <span class="k">if</span> <span class="n">used_ship</span><span class="o">.</span><span class="n">can_change_to_ready_status</span><span class="p">(</span><span class="n">cur_t</span><span class="o">=</span><span class="n">cur_t</span><span class="p">):</span>
            <span class="c1"># if used_ship.id == 6:</span>
            <span class="c1">#     print(&#39;a&#39;)</span>
            
            <span class="c1"># NOTE: 만약, used_ship.init()을 먼저 하고 heappush하면, 기존에 heapq에 있던 것도 똑같이 바뀌어서 동일한 값을가진 객체가 들어가므로 새롭게 갱신이 안됨. </span>
            <span class="n">new_ship</span> <span class="o">=</span> <span class="n">Ship</span><span class="p">(</span><span class="n">used_ship</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">used_ship</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">used_ship</span><span class="o">.</span><span class="n">r</span><span class="p">)</span>
            <span class="c1"># 이렇게 new_ship을 우선순위 큐에 넣으면 dictionay가 가진 Object와 priority_queue가 가진 object가 달라지게됨. </span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">ships_pq</span><span class="p">,</span> <span class="n">new_ship</span><span class="p">)</span> <span class="c1"># </span>
            <span class="c1"># used_ship.reinit() # dict에서 정보를 바꿔줌. </span>
            <span class="n">ship_id_to_dict</span><span class="p">[</span><span class="n">used_ship</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_ship</span>
            <span class="c1"># used_ship을 제거해야하는데 for loop돌고 있는 상황에서 제거하면 길이가 달라져서 안됨. </span>
            <span class="c1"># 따라서 copy 를 만들어서 제거해줌 </span>
            <span class="c1"># NOTE: 원본에서 제거해도 used_ship_list_copy는 그대로!</span>
            <span class="n">used_ship_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">used_ship</span><span class="p">)</span>


    <span class="n">will_be_used_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># O(1)으로 중복 찾기 위함 </span>
    <span class="n">will_be_used_list</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 우선순위대로 프린트 하기 위함 </span>
    <span class="n">will_not_be_used</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 조건이 안 된 것들을 저장하기 위함 </span>
    <span class="n">total_pw</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">ships_pq</span><span class="p">:</span> <span class="c1"># 5개 도달하기 전에 ships_pq가 비어있으면 종료 </span>
        <span class="n">cur_ship</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">ships_pq</span><span class="p">)</span>

        <span class="c1"># 오래된 것은 버려야함. (lazy check)</span>
        <span class="k">if</span> <span class="n">ship_id_to_dict</span><span class="p">[</span><span class="n">cur_ship</span><span class="o">.</span><span class="n">id</span><span class="p">]</span><span class="o">.</span><span class="n">p</span> <span class="o">!=</span> <span class="n">cur_ship</span><span class="o">.</span><span class="n">p</span><span class="p">:</span>
            <span class="k">continue</span> 

        <span class="k">if</span> <span class="n">cur_ship</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">will_be_used_set</span><span class="p">:</span>
            <span class="c1"># 중복된 object이므로 제거되어도 됨. </span>
            <span class="k">continue</span> 
        
        <span class="c1"># 최대 5개인데, 5개 중 맨 뒤에 2개가 이미 사용된 ships일수도 있잖아. </span>
        <span class="c1"># 하지만 사용하면 바로 빼서 그럴 일은 없을 것 같음. </span>
        <span class="k">if</span> <span class="n">cur_ship</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># 제거하진 않고, 나중에 다시 넣어줌. </span>
            <span class="n">will_not_be_used</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_ship</span><span class="p">)</span>

        
        <span class="c1"># 공격에 들어갈 것. dict에 있는 정보도 바뀌게 됨. </span>
        <span class="c1"># 이미 ships_pq에서는 사용되면 빠지게 됨. 즉, Ships_pq에는 대기 (status=0) 중인 선박만 존재 # NOTE: cmd 300에서 이미 사용되었던 ship이라도 pq에 들어갈 수 있음. </span>
        <span class="n">cur_ship</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">1</span> 
        <span class="n">cur_ship</span><span class="o">.</span><span class="n">used_time</span> <span class="o">=</span> <span class="n">cur_t</span>
        <span class="n">used_ship_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_ship</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="n">total_pw</span> <span class="o">+=</span> <span class="n">cur_ship</span><span class="o">.</span><span class="n">p</span> 
        <span class="n">will_be_used_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cur_ship</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="n">will_be_used_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_ship</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="c1"># heapq.heappop(ships_pq)</span>

        <span class="c1"># 최대 5개 까지 </span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">will_be_used_set</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">break</span> 
        
    <span class="nb">print</span><span class="p">(</span><span class="n">total_pw</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">will_be_used_set</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">will_be_used_list</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
    

    <span class="c1">### will_not_be_used를 다시 pq에 넣어줌 </span>
    <span class="k">for</span> <span class="n">ship</span> <span class="ow">in</span> <span class="n">will_not_be_used</span><span class="p">:</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">ships_pq</span><span class="p">,</span> <span class="n">ship</span><span class="p">)</span>

<span class="c1">#### global scope </span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">T</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    필요한 자료 구조</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ships_pq</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Ship</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># priority queue </span>
    <span class="n">ship_id_to_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Ship</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">used_ship_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Ship</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>

        <span class="k">if</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">100</span><span class="p">:</span> <span class="c1"># INIT </span>
            <span class="n">process_100</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>

        <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span> <span class="c1"># 지원 요청 </span>
            <span class="n">process_200</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">300</span><span class="p">:</span> <span class="c1"># 함포 교체 </span>
            <span class="nb">id</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">new_pw</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">process_300</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">new_pw</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># 400, 공격 명령 </span>
            <span class="n">process_400</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="dijkstra">
<h2>Dijkstra<a class="headerlink" href="#dijkstra" title="Link to this heading">#</a></h2>
<p>특정 시작점에서 다른 점으로의 최단 거리를 알고 싶은 경우, <em><strong>음수의 간선이 없는 경우</strong></em> dijkstra 알고리즘을 사용하여 계산할 수 있다.</p>
<section id="id8">
<h3>개구리의 여행<a class="headerlink" href="#id8" title="Link to this heading">#</a></h3>
<ol class="arabic simple">
<li><p>3D dijkstra algorithm을 사용할 수 있다. 즉, 공간적 위치 뿐만 아니라, (y, x, jump) 현재의 점프력에 따라서도 도착지점까지의 최단 거리 (시간)이 달라지기 때문이다. 따라서, Shortest_path dictionary와 priority queue에 넣는 정보 모두 3D 차원에서 고려, 확인해야한다.</p></li>
<li><p>시간 초과가 나는 경우, dijkstra algorithm에서 중간에, Destination에 도달했다면, 빨리 알고리즘을 종료시킴으로써, 해결할 수 있다. (다만 이경우에는 start_node가 동일한 경우 기존에 계산한 것에서 사용하지못하고, 다시 계산해야한다. )</p>
<ul class="simple">
<li><p>다익스트라는 <em><strong>우선순위 큐에서 pop되는 순간, 그 상태의 거리는 ‘그 상태로 가는 최단 거리’가 확정</strong></em> 이다.</p></li>
<li><p>나중에 다른 점프력 (d_y, d_x, j2)로 도달하는 경로들이 있을 수 있지만, 그 상태는 (d_y, d_x, j1)보다 더 작은 거리를 가지고 있어야하지만, pop()되어서 나온 것이 j1이면, 그 상태에서 최단 거리를 가지고 있기 때문에 고려하지 않아도 된다.</p></li>
</ul>
</li>
<li><p>전체 상태의 개수는 격자 칸수와 점프력의 가능한 값의 곱에 비례하며, 다익스트라 알고리즘을 통해 처리하므로 시간복잡도는 O(N^2 J^2 log(N^2 J^2)) ~ O(N^2 J^2 log(N J)) 가 된다.</p></li>
</ol>
<div class="dropdown admonition">
<p class="admonition-title">coding and decoding for each state</p>
<p>공간상으로 3D Matrix을 만드는 것이 가장 쉬운 접근법이지만, (y, x, jump)에 대하여 unique한 index를 만드는 함수를 구현하여 코드를 작성할 수도 있다.</p>
<div class="literal-block-wrapper docutils container" id="id9">
<div class="code-block-caption"><span class="caption-number">예시 45 </span><span class="caption-text">3D 공간 (행, 열, 점프력)을 하나의 stateID로 coding하는 함수. (row, col, jump)가 1-indexed이기 때문에, 0-indexed로 변환한 후 계산하고 있음에 주의하자.</span><a class="headerlink" href="#id9" title="Link to this code">#</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 각 상태는 (행, 열, 점프력)으로 저장된다. </span>
<span class="c1"># 상태를 하나의 정수 인덱스로 변환하기 위한 함수이다. </span>
<span class="c1"># 상태 인덱스는 MAX_JUMP_POWER * (row-1) </span>
<span class="k">def</span><span class="w"> </span><span class="nf">getStateId</span><span class="p">(</span><span class="n">row</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">col</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">jump</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">gridSize</span><span class="p">,</span> <span class="n">MAX_JUMP_POWER</span>
    <span class="c1"># 1-indexed (row, col, jump)</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    row에 gridSize 숫자를 곱하면, 그 숫자들이 gridSize만큼 벌어지고, 그것을 col-1의 크기만큼 채우면 Unique한 수를 만들 수 있다. </span>
<span class="sd">    이는 Jump라는 3번째 숫자가 있을때도 동일하게 적용될 수 있다. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">MAX_JUMP_POWER</span><span class="o">*</span><span class="p">(</span><span class="n">gridSize</span><span class="o">*</span><span class="p">(</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">jump</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>반면, 이렇게 unique index로 coding된 것들을 다시, (row, col, jump)로 계산할 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">decodeState</span><span class="p">(</span><span class="n">cur_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">tempState</span> <span class="o">=</span> <span class="n">cur_state</span> 
    <span class="n">currentJumpPower</span> <span class="o">=</span> <span class="p">(</span><span class="n">tempState</span><span class="p">)</span><span class="o">%</span><span class="n">MAX_GRID_SIZE</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># 점프력 값 복원 </span>
    <span class="n">tempState</span> <span class="o">//=</span> <span class="n">MAX_JUMP_POWER</span>
    <span class="n">currentCol</span> <span class="o">=</span> <span class="p">(</span><span class="n">tempState</span> <span class="o">%</span> <span class="n">gridSize</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># 열 복원 </span>
    <span class="n">tempState</span> <span class="o">//=</span> <span class="n">gridSize</span>
    <span class="n">currentRow</span> <span class="o">=</span> <span class="p">(</span><span class="n">tempState</span> <span class="o">%</span> <span class="n">gridSize</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># 행 복원</span>
     
    <span class="k">return</span> <span class="p">(</span><span class="n">currentRow</span><span class="p">,</span> <span class="n">currentCol</span><span class="p">,</span> <span class="n">currentJumpPower</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="tip admonition">
<p class="admonition-title">Tips for dijkstra alogrithm</p>
<p>dijkstra priority queue에 (dis, (y, x)) 정보만 들어가면, 같은 위치에서 점프력이 다를때 중복되어 알고리즘이 정확히 움직이는 것을 파악하기 어렵지만, (dis, (y, x, jump))까지 들어가면, 겹치지 않고, 해당 State에 대해 최단 거리를 구할 수 있게 되므로, 굳이, options들을 구할때 점프후까지 고려할 필요가 없다.</p>
<p>따라서, 위치 정보 이외에도 어떤 정보가 필요한지, 잘 고려하여 해당 정보도 포함하도록 넣어주어야한다.</p>
</div>
<div class="dropdown admonition">
<p class="admonition-title">sol1: Time Limit</p>
<p>아래는 Time limit이 걸렸으나, 로직 자체는 맞는 것 같다. 시간초과가 나는 부분은 <code class="docutils literal notranslate"><span class="pre">cal_options()</span></code>함수를 호출할 때 부분으로, graph에 갈 공간이 많을 수록 할 수 있는 점프 및 다양한 경로가 존재하게 되어 이를 찾는데 시간초과가 걸리는 것 같다.</p>
<p>현재 Time Limit이 나는 이유는, 다음에 갈 상태가 점프 후까지 계산을 해서 그런 것 같음.
check_ways() 함수는 for loop을 진행하는 함수인데, 점프 옵션 외에 점프력 감소/증가할때도 따지게 되므로, 시간 초과되는 것 같음.
너무 멀리내다보지 말고, 현재 상황까지만 보도록 코드를 다시 짜보자.</p>
<p>Tips:  dijkstra priority queue에 (dis, (y, x)) 정보만 들어가면, 같은 위치에서 점프력이 다를때 중복되어 알고리즘이 정확히 움직이는 것을 파악하기 어렵지만, (dis, (y, x, jump))까지 들어가면, 겹치지 않고, 해당 State에 대해 최단 거리를 구할 수 있게 되므로, 굳이, options들을 구할때 점프후까지 고려할 필요가 없다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span> 
<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 

<span class="c1"># sys.stdin = open(&#39;Input.txt&#39;)</span>
<span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">jump</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">=</span> <span class="n">jump</span>
        
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="si">}</span><span class="s2"> with jump </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">jump</span><span class="si">}</span><span class="s2">)&quot;</span>
    
<span class="k">def</span><span class="w"> </span><span class="nf">modified_dijkstra</span><span class="p">(</span><span class="n">s_y</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">s_x</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">d_y</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">d_x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">shortest_path</span><span class="p">,</span> <span class="n">options</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s_y</span><span class="p">,</span> <span class="n">s_x</span><span class="p">)</span> <span class="ow">in</span> <span class="n">shortest_path</span><span class="p">:</span>
        <span class="n">dis</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">shortest_path</span><span class="p">[(</span><span class="n">s_y</span><span class="p">,</span> <span class="n">s_x</span><span class="p">)][</span><span class="n">d_y</span><span class="p">][</span><span class="n">d_x</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">dis</span> <span class="k">if</span> <span class="n">dis</span> <span class="o">!=</span> <span class="n">MAX</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> 
        <span class="k">return</span> 
    <span class="c1"># 해당 시작 노드에서 계산한 shortest_path가 없는 경우 </span>
    <span class="n">shortest_path</span><span class="p">[(</span><span class="n">s_y</span><span class="p">,</span> <span class="n">s_x</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">MAX</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">N</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">N</span><span class="p">)]</span>
    <span class="n">shortest_path</span><span class="p">[(</span><span class="n">s_y</span><span class="p">,</span> <span class="n">s_x</span><span class="p">)][</span><span class="n">s_y</span><span class="p">][</span><span class="n">s_x</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> 

    <span class="n">q</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">s_y</span><span class="p">,</span> <span class="n">s_x</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span> <span class="c1"># dis, cur_locs, jump</span>
    <span class="c1"># min_dis = MAX </span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># options를 위한 방문 처리 셋 </span>
    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">cur_dis</span><span class="p">,</span> <span class="n">cur_locs</span><span class="p">,</span> <span class="n">cur_jump</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">cur_y</span> <span class="o">=</span> <span class="n">cur_locs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">cur_x</span> <span class="o">=</span> <span class="n">cur_locs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># NOTE: 같은 칸이라고 해도 Jump=1, jump5일때 그 이후에 갈 수 있는 다음 칸/비용이 달라지므로 점프력도 포함해야한다. </span>
        <span class="k">if</span> <span class="n">cur_dis</span> <span class="o">&gt;</span> <span class="n">shortest_path</span><span class="p">[(</span><span class="n">s_y</span><span class="p">,</span> <span class="n">s_x</span><span class="p">)][</span><span class="n">cur_y</span><span class="p">][</span><span class="n">cur_x</span><span class="p">][</span><span class="n">cur_jump</span><span class="p">]:</span>
            <span class="k">continue</span> 

        <span class="c1"># backtracking </span>
        <span class="c1"># print(f&#39;cur_locs: {cur_y}, {cur_x}: {options[cur_y][cur_x][cur_jump]}&#39;)</span>
        
        <span class="c1"># 현재 locs와 현재 점프력에서 nxt_node에는 (edge_weight, 연결된 Node위치, 연결된 Node위치까지 걸리는 점프력) 저장 </span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">cur_y</span><span class="p">,</span> <span class="n">cur_x</span><span class="p">,</span> <span class="n">cur_jump</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="n">options</span><span class="p">[</span><span class="n">cur_y</span><span class="p">][</span><span class="n">cur_x</span><span class="p">][</span><span class="n">cur_jump</span><span class="p">]</span> <span class="o">=</span> <span class="n">cal_options</span><span class="p">(</span><span class="n">cur_y</span><span class="p">,</span> <span class="n">cur_x</span><span class="p">,</span> <span class="n">cur_jump</span><span class="p">)</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">cur_y</span><span class="p">,</span> <span class="n">cur_x</span><span class="p">,</span> <span class="n">cur_jump</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">nxt_node</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">cur_y</span><span class="p">][</span><span class="n">cur_x</span><span class="p">][</span><span class="n">cur_jump</span><span class="p">]:</span>
            <span class="n">nxt_jump</span> <span class="o">=</span> <span class="n">nxt_node</span><span class="o">.</span><span class="n">jump</span> <span class="c1"># 다음 상태에서의 점프력</span>
            <span class="n">nxt_time</span> <span class="o">=</span> <span class="n">cur_dis</span> <span class="o">+</span> <span class="n">nxt_node</span><span class="o">.</span><span class="n">time</span> 
            
            <span class="k">if</span> <span class="n">nxt_time</span> <span class="o">&lt;</span> <span class="n">shortest_path</span><span class="p">[(</span><span class="n">s_y</span><span class="p">,</span> <span class="n">s_x</span><span class="p">)][</span><span class="n">nxt_node</span><span class="o">.</span><span class="n">y</span><span class="p">][</span><span class="n">nxt_node</span><span class="o">.</span><span class="n">x</span><span class="p">][</span><span class="n">nxt_jump</span><span class="p">]:</span>
                <span class="n">shortest_path</span><span class="p">[(</span><span class="n">s_y</span><span class="p">,</span> <span class="n">s_x</span><span class="p">)][</span><span class="n">nxt_node</span><span class="o">.</span><span class="n">y</span><span class="p">][</span><span class="n">nxt_node</span><span class="o">.</span><span class="n">x</span><span class="p">][</span><span class="n">nxt_jump</span><span class="p">]</span> <span class="o">=</span> <span class="n">nxt_time</span> 
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="n">nxt_time</span><span class="p">,</span> <span class="p">(</span><span class="n">nxt_node</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">nxt_node</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">nxt_jump</span><span class="p">))</span>

    <span class="c1"># 결과 출력 </span>
    <span class="n">min_dis</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">shortest_path</span><span class="p">[(</span><span class="n">s_y</span><span class="p">,</span> <span class="n">s_x</span><span class="p">)][</span><span class="n">d_y</span><span class="p">][</span><span class="n">d_x</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">min_dis</span> <span class="k">if</span> <span class="n">min_dis</span> <span class="o">!=</span> <span class="n">MAX</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">in_range</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">N</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">N</span> <span class="ow">and</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">N</span>

<span class="k">def</span><span class="w"> </span><span class="nf">check_ways</span><span class="p">(</span><span class="n">cur_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cur_x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dy</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">graph</span> 

    <span class="c1"># condition1, 2 에서 도착 위치의 돌 정보를 확인하므로, </span>
    <span class="c1"># 시작~끝의 &#39;경로&#39;에만 천적이 있는지 없는지 확인하면 됨. (도착위치는 exclusive)</span>

    <span class="c1"># dx나 dy가 0이면 range가 안돌아감. </span>
    <span class="k">if</span> <span class="n">dy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># dx방향으로만 검사 </span>
        <span class="nb">dir</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> 
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cur_x</span><span class="p">,</span> <span class="n">cur_x</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span> <span class="nb">dir</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;#&#39;</span> <span class="o">==</span> <span class="n">graph</span><span class="p">[</span><span class="n">cur_y</span><span class="p">][</span><span class="n">x</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">False</span> 
    <span class="k">elif</span> <span class="n">dx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">dir</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dy</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> 
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cur_y</span><span class="p">,</span> <span class="n">cur_y</span><span class="o">+</span><span class="n">dy</span><span class="p">,</span> <span class="nb">dir</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;#&#39;</span> <span class="o">==</span> <span class="n">graph</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">cur_x</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">False</span> 
    <span class="k">return</span> <span class="kc">True</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">make_jump</span><span class="p">(</span><span class="n">weight</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cur_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cur_x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cur_jump</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">graph</span> 

    <span class="n">DY</span> <span class="o">=</span> <span class="p">[</span><span class="n">cur_jump</span><span class="p">,</span> <span class="o">-</span><span class="n">cur_jump</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">DX</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cur_jump</span><span class="p">,</span> <span class="o">-</span><span class="n">cur_jump</span><span class="p">]</span>
    
    <span class="n">cur_options</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">DY</span><span class="p">,</span> <span class="n">DX</span><span class="p">):</span>
        <span class="n">nxt_y</span> <span class="o">=</span> <span class="n">cur_y</span> <span class="o">+</span> <span class="n">dy</span> 
        <span class="n">nxt_x</span> <span class="o">=</span> <span class="n">cur_x</span> <span class="o">+</span> <span class="n">dx</span> 
        
        <span class="k">if</span> <span class="n">in_range</span><span class="p">(</span><span class="n">nxt_y</span><span class="p">,</span> <span class="n">nxt_x</span><span class="p">):</span>
            <span class="n">condition1</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">nxt_y</span><span class="p">][</span><span class="n">nxt_x</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span> <span class="c1"># 도착위치에 돌이 있음</span>
            <span class="n">condition2</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">nxt_y</span><span class="p">][</span><span class="n">nxt_x</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;S&#39;</span> <span class="c1"># 도착위치가 미끄러운 돌이 아님 </span>
            <span class="n">condition3</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">nxt_y</span><span class="p">][</span><span class="n">nxt_x</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;#&#39;</span> <span class="c1"># 도착위치에 천적이 거주 </span>
            <span class="n">condition4</span> <span class="o">=</span> <span class="n">check_ways</span><span class="p">(</span><span class="n">cur_y</span><span class="p">,</span> <span class="n">cur_x</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span> <span class="c1"># 현재위치에서 경로까지 천적이 살지 않는지 </span>
            <span class="n">flag</span> <span class="o">=</span> <span class="n">condition1</span> <span class="ow">and</span> <span class="n">condition2</span> <span class="ow">and</span> <span class="n">condition3</span> <span class="ow">and</span> <span class="n">condition4</span>
            
            <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
                <span class="c1"># NOTE: edge의 정해진 weight에 대한, Node생성, 현재 점프력도 저장 </span>
                <span class="n">cur_options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">nxt_y</span><span class="p">,</span> <span class="n">nxt_x</span><span class="p">,</span> <span class="n">cur_jump</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">cur_options</span>

<span class="k">def</span><span class="w"> </span><span class="nf">cal_options</span><span class="p">(</span><span class="n">cur_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cur_x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cur_jump</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Node</span><span class="p">]:</span>
    <span class="c1"># 현재 위치와 점프력으로 &#39;다음에&#39; 갈 수 있는 (weight, nxt_y, nxt_x)의 정보 수집</span>
    <span class="n">can_reach</span> <span class="o">=</span> <span class="p">[]</span>  
    <span class="c1"># 1) 바로 점프  = 1</span>
    <span class="n">can_reach</span> <span class="o">+=</span> <span class="n">make_jump</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                           <span class="n">cur_y</span><span class="o">=</span><span class="n">cur_y</span> <span class="p">,</span> <span class="n">cur_x</span><span class="o">=</span><span class="n">cur_x</span><span class="p">,</span> <span class="n">cur_jump</span><span class="o">=</span><span class="n">cur_jump</span><span class="p">)</span>
    
    <span class="c1"># 2) 점프력 증가 후 점프 = k^2 + 1 </span>
    <span class="c1"># NOTE: 점프력을 1올릴 수 있다고 했는데, 이는 만약 1을 올려도 없으면, 제자리에서 또 점프력을 올릴 수 있음 </span>
    <span class="c1"># if 1&lt;= cur_jump &lt;= 4:</span>
    <span class="c1">#     elevated_jump = cur_jump + 1 </span>
    <span class="c1">#     can_reach += make_jump(weight=1+elevated_jump*elevated_jump, </span>
    <span class="c1">#                            cur_y= cur_y, cur_x=cur_x, cur_jump=elevated_jump)</span>
    <span class="k">if</span> <span class="mi">1</span><span class="o">&lt;=</span><span class="n">cur_jump</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">elevated_jump</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cur_jump</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
            <span class="c1"># 누적합 </span>
            <span class="n">weight</span> <span class="o">+=</span> <span class="p">(</span><span class="n">elevated_jump</span><span class="o">*</span><span class="n">elevated_jump</span><span class="p">)</span>
            <span class="n">can_reach</span> <span class="o">+=</span> <span class="n">make_jump</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="o">+</span><span class="n">weight</span><span class="p">,</span>
                                   <span class="n">cur_y</span> <span class="o">=</span> <span class="n">cur_y</span><span class="p">,</span> <span class="n">cur_x</span> <span class="o">=</span> <span class="n">cur_x</span><span class="p">,</span> <span class="n">cur_jump</span><span class="o">=</span><span class="n">elevated_jump</span><span class="p">)</span>

    <span class="c1"># 3) 점프력 감소 후 점프 = 1 + 1 </span>
    <span class="k">for</span> <span class="n">reduced_jump</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cur_jump</span><span class="p">):</span>
        <span class="n">can_reach</span> <span class="o">+=</span> <span class="n">make_jump</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">cur_y</span><span class="o">=</span><span class="n">cur_y</span> <span class="p">,</span> 
                               <span class="n">cur_x</span><span class="o">=</span><span class="n">cur_x</span><span class="p">,</span> <span class="n">cur_jump</span><span class="o">=</span><span class="n">reduced_jump</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">can_reach</span> 



<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
<span class="n">MAX</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>
<span class="c1">#### 필요한 자료구조 </span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">N</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">graph</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="c1"># print(graph)</span>
<span class="c1"># print(len(graph), len(graph[0]))</span>

<span class="c1"># 현재 위치 (tuple)에서 시작할때 각 도착지에 대해서 걸리는 최단 시간에 대한 정보 저장 </span>
<span class="c1"># 3D dijkstra, [y][x][jump]</span>
<span class="n">shortest_path</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="c1"># 현재 위치와 점프력으로 &#39;다음에&#39; 갈 수 있는 (weight, nxt_y, nxt_x)의 정보 수집 </span>
<span class="n">options</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="s2">&quot;Node&quot;</span><span class="p">]]]</span> <span class="c1"># [cur_y][cur_x][jump] -&gt; [(edge weight(걸리는 시간), next_y, next_x, 도달할때 점프력), 저장]</span>

<span class="n">options</span> <span class="o">=</span> <span class="p">[[[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">N</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">N</span><span class="p">)]</span>

<span class="n">Q</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="c1"># NOTE: 이렇게 다 만들고 풀면, 시간 초과 </span>
<span class="c1"># # 모든 시작 위치에 대해서 </span>
<span class="c1"># for cur_y in range(1, N+1):</span>
<span class="c1">#     for cur_x in range(1, N+1):</span>
<span class="c1">#         for cur_jump in range(1, 6): # jump는 1에서 5까지</span>
<span class="c1">#             # 다시 돌아갈 수도 있는거잖아...아닌가?</span>
<span class="c1">#             # if cur_y == 1 and cur_x == 1 and cur_jump != 1:</span>
<span class="c1">#             #     # 최초 위치에서는 cur_jump이 1밖에 없음. </span>
<span class="c1">#             #     continue </span>
<span class="c1">#             options[cur_y][cur_x][cur_jump] = cal_options(cur_y, cur_x, cur_jump) # options 미리 만들어놓기 </span>

<span class="c1"># print(options[6][2][1])</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="p">):</span>
    <span class="n">r1</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
    <span class="n">modified_dijkstra</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">Solution</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span> 
<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 

<span class="c1"># sys.stdin = open(&#39;Input.txt&#39;)</span>
<span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">jump</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">=</span> <span class="n">jump</span>
        
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="si">}</span><span class="s2"> with jump </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">jump</span><span class="si">}</span><span class="s2">)&quot;</span>
    
<span class="k">def</span><span class="w"> </span><span class="nf">modified_dijkstra</span><span class="p">(</span><span class="n">s_y</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">s_x</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">d_y</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">d_x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">shortest_path</span><span class="p">,</span> <span class="n">options</span>
    <span class="c1"># if (s_y, s_x) in shortest_path:</span>
    <span class="c1">#     dis = min(shortest_path[(s_y, s_x)][d_y][d_x])</span>
    <span class="c1">#     print(dis if dis != MAX else -1) </span>
    <span class="c1">#     return </span>
    <span class="c1"># 해당 시작 노드에서 계산한 shortest_path가 없는 경우 </span>
    <span class="n">shortest_path</span><span class="p">[(</span><span class="n">s_y</span><span class="p">,</span> <span class="n">s_x</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">MAX</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">N</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">N</span><span class="p">)]</span>
    <span class="n">shortest_path</span><span class="p">[(</span><span class="n">s_y</span><span class="p">,</span> <span class="n">s_x</span><span class="p">)][</span><span class="n">s_y</span><span class="p">][</span><span class="n">s_x</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> 

    <span class="n">q</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">s_y</span><span class="p">,</span> <span class="n">s_x</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span> <span class="c1"># dis, cur_locs, jump</span>
    <span class="c1"># min_dis = MAX </span>
    <span class="c1"># visited = set() # options를 위한 방문 처리 셋 </span>
    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">cur_dis</span><span class="p">,</span> <span class="n">cur_locs</span><span class="p">,</span> <span class="n">cur_jump</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">cur_y</span> <span class="o">=</span> <span class="n">cur_locs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">cur_x</span> <span class="o">=</span> <span class="n">cur_locs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># NOTE: 같은 칸이라고 해도 Jump=1, jump5일때 그 이후에 갈 수 있는 다음 칸/비용이 달라지므로 점프력도 포함해야한다. </span>
        <span class="k">if</span> <span class="n">cur_dis</span> <span class="o">&gt;</span> <span class="n">shortest_path</span><span class="p">[(</span><span class="n">s_y</span><span class="p">,</span> <span class="n">s_x</span><span class="p">)][</span><span class="n">cur_y</span><span class="p">][</span><span class="n">cur_x</span><span class="p">][</span><span class="n">cur_jump</span><span class="p">]:</span>
            <span class="k">continue</span> 
        
        <span class="k">if</span> <span class="n">cur_y</span> <span class="o">==</span> <span class="n">d_y</span> <span class="ow">and</span> <span class="n">cur_x</span> <span class="o">==</span> <span class="n">d_x</span><span class="p">:</span>
            <span class="n">shortest_path</span><span class="p">[(</span><span class="n">s_y</span><span class="p">,</span> <span class="n">s_x</span><span class="p">)][</span><span class="n">d_y</span><span class="p">][</span><span class="n">d_x</span><span class="p">][</span><span class="n">cur_jump</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_dis</span>
            <span class="k">break</span>
        <span class="c1"># backtracking </span>
        <span class="c1"># print(f&#39;cur_locs: {cur_y}, {cur_x}: {options[cur_y][cur_x][cur_jump]}&#39;)</span>
        
        <span class="c1"># 현재 locs와 현재 점프력에서 nxt_node에는 (edge_weight, 연결된 Node위치, 연결된 Node위치까지 걸리는 점프력) 저장 </span>
        
        <span class="c1"># if graph[cur_y][cur_x] == &#39;.&#39; and (cur_y, cur_x, cur_jump) not in visited:</span>
        <span class="c1">#     options[cur_y][cur_x][cur_jump] = cal_options(cur_y, cur_x, cur_jump)</span>
        <span class="c1">#     visited.add((cur_y, cur_x, cur_jump))</span>

        <span class="k">for</span> <span class="n">nxt_node</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">cur_y</span><span class="p">][</span><span class="n">cur_x</span><span class="p">][</span><span class="n">cur_jump</span><span class="p">]:</span>
            <span class="n">nxt_jump</span> <span class="o">=</span> <span class="n">nxt_node</span><span class="o">.</span><span class="n">jump</span> <span class="c1"># 다음 상태에서의 점프력</span>
            <span class="n">nxt_time</span> <span class="o">=</span> <span class="n">cur_dis</span> <span class="o">+</span> <span class="n">nxt_node</span><span class="o">.</span><span class="n">time</span> 
            
            <span class="k">if</span> <span class="n">nxt_time</span> <span class="o">&lt;</span> <span class="n">shortest_path</span><span class="p">[(</span><span class="n">s_y</span><span class="p">,</span> <span class="n">s_x</span><span class="p">)][</span><span class="n">nxt_node</span><span class="o">.</span><span class="n">y</span><span class="p">][</span><span class="n">nxt_node</span><span class="o">.</span><span class="n">x</span><span class="p">][</span><span class="n">nxt_jump</span><span class="p">]:</span>
                <span class="n">shortest_path</span><span class="p">[(</span><span class="n">s_y</span><span class="p">,</span> <span class="n">s_x</span><span class="p">)][</span><span class="n">nxt_node</span><span class="o">.</span><span class="n">y</span><span class="p">][</span><span class="n">nxt_node</span><span class="o">.</span><span class="n">x</span><span class="p">][</span><span class="n">nxt_jump</span><span class="p">]</span> <span class="o">=</span> <span class="n">nxt_time</span> 
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="n">nxt_time</span><span class="p">,</span> <span class="p">(</span><span class="n">nxt_node</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">nxt_node</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">nxt_jump</span><span class="p">))</span>

    <span class="c1"># 결과 출력 </span>
    <span class="n">min_dis</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">shortest_path</span><span class="p">[(</span><span class="n">s_y</span><span class="p">,</span> <span class="n">s_x</span><span class="p">)][</span><span class="n">d_y</span><span class="p">][</span><span class="n">d_x</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">min_dis</span> <span class="k">if</span> <span class="n">min_dis</span> <span class="o">!=</span> <span class="n">MAX</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">in_range</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">N</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">N</span> <span class="ow">and</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">N</span>

<span class="k">def</span><span class="w"> </span><span class="nf">check_ways</span><span class="p">(</span><span class="n">cur_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cur_x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dy</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">graph</span> 

    <span class="c1"># condition1, 2 에서 도착 위치의 돌 정보를 확인하므로, </span>
    <span class="c1"># 시작~끝의 &#39;경로&#39;에만 천적이 있는지 없는지 확인하면 됨. (도착위치는 exclusive)</span>

    <span class="c1"># dx나 dy가 0이면 range가 안돌아감. </span>
    <span class="k">if</span> <span class="n">dy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># dx방향으로만 검사 </span>
        <span class="nb">dir</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> 
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cur_x</span><span class="p">,</span> <span class="n">cur_x</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span> <span class="nb">dir</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;#&#39;</span> <span class="o">==</span> <span class="n">graph</span><span class="p">[</span><span class="n">cur_y</span><span class="p">][</span><span class="n">x</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">False</span> 
    <span class="k">elif</span> <span class="n">dx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">dir</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dy</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> 
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cur_y</span><span class="p">,</span> <span class="n">cur_y</span><span class="o">+</span><span class="n">dy</span><span class="p">,</span> <span class="nb">dir</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;#&#39;</span> <span class="o">==</span> <span class="n">graph</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">cur_x</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">False</span> 
    <span class="k">return</span> <span class="kc">True</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">make_jump</span><span class="p">(</span><span class="n">weight</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cur_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cur_x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cur_jump</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">graph</span> 

    <span class="n">DY</span> <span class="o">=</span> <span class="p">[</span><span class="n">cur_jump</span><span class="p">,</span> <span class="o">-</span><span class="n">cur_jump</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">DX</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cur_jump</span><span class="p">,</span> <span class="o">-</span><span class="n">cur_jump</span><span class="p">]</span>
    
    <span class="n">cur_options</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">DY</span><span class="p">,</span> <span class="n">DX</span><span class="p">):</span>
        <span class="n">nxt_y</span> <span class="o">=</span> <span class="n">cur_y</span> <span class="o">+</span> <span class="n">dy</span> 
        <span class="n">nxt_x</span> <span class="o">=</span> <span class="n">cur_x</span> <span class="o">+</span> <span class="n">dx</span> 
        
        <span class="k">if</span> <span class="n">in_range</span><span class="p">(</span><span class="n">nxt_y</span><span class="p">,</span> <span class="n">nxt_x</span><span class="p">):</span>
            <span class="n">condition1</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">nxt_y</span><span class="p">][</span><span class="n">nxt_x</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span> <span class="c1"># 도착위치에 돌이 있음</span>
            <span class="n">condition2</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">nxt_y</span><span class="p">][</span><span class="n">nxt_x</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;S&#39;</span> <span class="c1"># 도착위치가 미끄러운 돌이 아님 </span>
            <span class="n">condition3</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">nxt_y</span><span class="p">][</span><span class="n">nxt_x</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;#&#39;</span> <span class="c1"># 도착위치에 천적이 거주 </span>
            <span class="n">condition4</span> <span class="o">=</span> <span class="n">check_ways</span><span class="p">(</span><span class="n">cur_y</span><span class="p">,</span> <span class="n">cur_x</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span> <span class="c1"># 현재위치에서 경로까지 천적이 살지 않는지 </span>
            <span class="n">flag</span> <span class="o">=</span> <span class="n">condition1</span> <span class="ow">and</span> <span class="n">condition2</span> <span class="ow">and</span> <span class="n">condition3</span> <span class="ow">and</span> <span class="n">condition4</span>
            
            <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
                <span class="c1"># NOTE: edge의 정해진 weight에 대한, Node생성, 현재 점프력도 저장 </span>
                <span class="n">cur_options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">nxt_y</span><span class="p">,</span> <span class="n">nxt_x</span><span class="p">,</span> <span class="n">cur_jump</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">cur_options</span>

<span class="k">def</span><span class="w"> </span><span class="nf">cal_options</span><span class="p">(</span><span class="n">cur_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cur_x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cur_jump</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Node</span><span class="p">]:</span>
    <span class="c1"># 현재 위치와 점프력으로 &#39;다음에&#39; 갈 수 있는 (weight, nxt_y, nxt_x)의 정보 수집</span>
    <span class="n">can_reach</span> <span class="o">=</span> <span class="p">[]</span>  
    <span class="c1"># 1) 바로 점프  = 1</span>
    <span class="n">can_reach</span> <span class="o">+=</span> <span class="n">make_jump</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                           <span class="n">cur_y</span><span class="o">=</span><span class="n">cur_y</span> <span class="p">,</span> <span class="n">cur_x</span><span class="o">=</span><span class="n">cur_x</span><span class="p">,</span> <span class="n">cur_jump</span><span class="o">=</span><span class="n">cur_jump</span><span class="p">)</span>
    
    <span class="c1"># 2) 점프력 증가 후 점프 = k^2 + 1 </span>
    <span class="c1"># NOTE: 점프력을 1올릴 수 있다고 했는데, 이는 만약 1을 올려도 없으면, 제자리에서 또 점프력을 올릴 수 있음 </span>
    <span class="c1"># if 1&lt;= cur_jump &lt;= 4:</span>
    <span class="c1">#     elevated_jump = cur_jump + 1 </span>
    <span class="c1">#     can_reach += make_jump(weight=1+elevated_jump*elevated_jump, </span>
    <span class="c1">#                            cur_y= cur_y, cur_x=cur_x, cur_jump=elevated_jump)</span>
    <span class="k">if</span> <span class="mi">1</span><span class="o">&lt;=</span><span class="n">cur_jump</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">elevated_jump</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cur_jump</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
            <span class="c1"># 누적합 </span>
            <span class="n">weight</span> <span class="o">+=</span> <span class="p">(</span><span class="n">elevated_jump</span><span class="o">*</span><span class="n">elevated_jump</span><span class="p">)</span>
            <span class="c1"># can_reach += make_jump(weight=1+weight,</span>
            <span class="c1">#                        cur_y = cur_y, cur_x = cur_x, cur_jump=elevated_jump)</span>
            <span class="c1"># 점프력을 올리면, 점프력 상승만 하고, Weight 증가 but 그 자리에 가만히 있게 됨. </span>
            <span class="n">can_reach</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span>
                                  <span class="n">y</span><span class="o">=</span><span class="n">cur_y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">cur_x</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="n">elevated_jump</span><span class="p">))</span>

    <span class="c1"># 3) 점프력 감소 후 점프 = 1 + 1 </span>
    <span class="k">for</span> <span class="n">reduced_jump</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cur_jump</span><span class="p">):</span>
        <span class="c1"># can_reach += make_jump(weight=1+1, cur_y=cur_y , </span>
        <span class="c1">#                        cur_x=cur_x, cur_jump=reduced_jump)</span>
        <span class="n">can_reach</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                              <span class="n">y</span><span class="o">=</span><span class="n">cur_y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">cur_x</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="n">reduced_jump</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">can_reach</span> 



<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
<span class="n">MAX</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>
<span class="c1">#### 필요한 자료구조 </span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">N</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">graph</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="c1"># print(graph)</span>
<span class="c1"># print(len(graph), len(graph[0]))</span>

<span class="c1"># 현재 위치 (tuple)에서 시작할때 각 도착지에 대해서 걸리는 최단 시간에 대한 정보 저장 </span>
<span class="c1"># 3D dijkstra, [y][x][jump]</span>
<span class="n">shortest_path</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="c1"># 현재 위치와 점프력으로 &#39;다음에&#39; 갈 수 있는 (weight, nxt_y, nxt_x)의 정보 수집 </span>
<span class="n">options</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="s2">&quot;Node&quot;</span><span class="p">]]]</span> <span class="c1"># [cur_y][cur_x][jump] -&gt; [(edge weight(걸리는 시간), next_y, next_x, 도달할때 점프력), 저장]</span>

<span class="n">options</span> <span class="o">=</span> <span class="p">[[[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">N</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">N</span><span class="p">)]</span>

<span class="n">Q</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="c1"># NOTE: 이렇게 다 만들고 풀면, 시간 초과 </span>
<span class="c1"># # 모든 시작 위치에 대해서 </span>
<span class="k">for</span> <span class="n">cur_y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">cur_x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">cur_jump</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span> <span class="c1"># jump는 1에서 5까지</span>
            <span class="c1"># 다시 돌아갈 수도 있는거잖아...아닌가?</span>
            <span class="c1"># if cur_y == 1 and cur_x == 1 and cur_jump != 1:</span>
            <span class="c1">#     # 최초 위치에서는 cur_jump이 1밖에 없음. </span>
            <span class="c1">#     continue </span>
            <span class="k">if</span> <span class="n">graph</span><span class="p">[</span><span class="n">cur_y</span><span class="p">][</span><span class="n">cur_x</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
                <span class="n">options</span><span class="p">[</span><span class="n">cur_y</span><span class="p">][</span><span class="n">cur_x</span><span class="p">][</span><span class="n">cur_jump</span><span class="p">]</span> <span class="o">=</span> <span class="n">cal_options</span><span class="p">(</span><span class="n">cur_y</span><span class="p">,</span> <span class="n">cur_x</span><span class="p">,</span> <span class="n">cur_jump</span><span class="p">)</span> <span class="c1"># options 미리 만들어놓기 </span>

<span class="c1"># print(options[6][2][1])</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="p">):</span>
    <span class="n">r1</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
    <span class="n">modified_dijkstra</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="reachable-nodes-in-subdivided-graph">
<h3>Reachable Nodes In Subdivided Graph<a class="headerlink" href="#reachable-nodes-in-subdivided-graph" title="Link to this heading">#</a></h3>
<div class="dropdown admonition">
<p class="admonition-title">Solution</p>
<p>Time: 111ms  <br>
Memory: 25 MB <br></p>
<p>used: dict[(node1, node2), int]: for each edge, <code class="docutils literal notranslate"><span class="pre">used</span></code> dictionary stores the number of possible new nodes we can walk through within the <code class="docutils literal notranslate"><span class="pre">maxMoves</span></code>. maxMoves - shortest_dis to the cur node can be negative. For example, maxMoves=6 and the shortest path to the node 3 can be 9. and the <code class="docutils literal notranslate"><span class="pre">used</span></code> will store -3. (since -3 will be always smaller than the number of new nodes) &lt;- This is why when we get out values in <code class="docutils literal notranslate"><span class="pre">used</span></code> by using used.get() function, we need to do used.get((u, v), 0).</p>
<p>In the end, we calculate <code class="docutils literal notranslate"><span class="pre">ans</span> <span class="pre">+=</span> <span class="pre">min(w,</span> <span class="pre">used.get((u,</span> <span class="pre">v),</span> <span class="pre">0)</span> <span class="pre">+</span> <span class="pre">used.get((v,</span> <span class="pre">u),</span> <span class="pre">0))</span></code> for each edge.
Since the graph is undirected graph, we can walk from u to v and, also, from v to u.</p>
<p>Since the addition of two values should not be greater than w (the number of new nodes), we add <code class="docutils literal notranslate"><span class="pre">min</span></code> value to the final answer.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">collections</span> 
<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 

<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reachableNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span> <span class="c1"># how many new nodes there are on this edge </span>

        <span class="n">pq</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="n">used</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">pq</span><span class="p">:</span>
            <span class="n">d</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">pq</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span> <span class="k">continue</span>
            <span class="c1"># Each node is only visited once.  We&#39;ve reached</span>
            <span class="c1"># a node in our original graph.</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">nei</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># M - d is how much further we can walk from this node;</span>
                <span class="c1"># weight is how many new nodes there are on this edge.</span>
                <span class="c1"># v is the maximum utilization of this edge.</span>
                <span class="n">v</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">M</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span>
                <span class="n">used</span><span class="p">[</span><span class="n">node</span><span class="p">,</span> <span class="n">nei</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span> <span class="c1"># start_node = node, end_node = nei</span>

                <span class="c1"># d2 is the total distance to reach &#39;nei&#39; (neighbor) node</span>
                <span class="c1"># in the original graph.</span>
                <span class="n">d2</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">weight</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># (weight+1 = the number of edges)</span>
                <span class="k">if</span> <span class="n">d2</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">nei</span><span class="p">,</span> <span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># dict.get(key, value if there is no key)</span>
                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">pq</span><span class="p">,</span> <span class="p">(</span><span class="n">d2</span><span class="p">,</span> <span class="n">nei</span><span class="p">))</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">nei</span><span class="p">]</span> <span class="o">=</span> <span class="n">d2</span>

        <span class="c1"># At the end, each edge (u, v, w) can be used with a maximum</span>
        <span class="c1"># of w new nodes: a max of used[u, v] nodes from one side,</span>
        <span class="c1"># and used[v, u] nodes from the other.</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">used</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">used</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">ans</span>
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">Solution2</p>
<p>Time: 149ms
Memory: 26MB</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span> 
<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span> 

<span class="k">def</span><span class="w"> </span><span class="nf">modified_dijkstra</span><span class="p">(</span><span class="n">cur_node</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">maxMoves</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">graph</span><span class="p">,</span> <span class="n">shortest_path</span><span class="p">,</span> <span class="n">used</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">possible_reachable_nodes_num</span> <span class="o">=</span> <span class="n">maxMoves</span> <span class="o">-</span> <span class="p">(</span><span class="n">shortest_path</span><span class="p">[</span><span class="n">cur_node</span><span class="p">])</span>
    <span class="c1"># NOTE: possible reachable nodes num이 음수가 되면, 위에 Temp_num이 음수가 되어 </span>
    <span class="c1"># 로직이 틀려지므로 0으로 둔다. </span>
    <span class="c1"># possible reachable nodes num이 음수 = 0보다 멀리가면 안되고, 0과 가까운쪽의 노드로 가야함. </span>
    <span class="c1"># 근데 그쪽으로 가면, 어차피 이전에 Dijkstra에서 그쪽 노드에서 이미 계산했을 것이기 때문에, 그냥 지나치면 된다. </span>
    <span class="n">possible_reachable_nodes_num</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">possible_reachable_nodes_num</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">possible_reachable_nodes_num</span>
    
    <span class="k">for</span> <span class="n">nxt_node</span><span class="p">,</span> <span class="n">num_1</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">cur_node</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">cur_node</span> <span class="o">&lt;</span> <span class="n">nxt_node</span><span class="p">:</span>
            <span class="n">node1</span><span class="o">=</span> <span class="n">cur_node</span><span class="p">;</span> <span class="n">node2</span><span class="o">=</span><span class="n">nxt_node</span> 
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node1</span> <span class="o">=</span> <span class="n">nxt_node</span><span class="p">;</span> <span class="n">node2</span><span class="o">=</span><span class="n">cur_node</span> 
        
        <span class="n">exisiting_node_nums</span> <span class="o">=</span> <span class="n">used</span><span class="p">[(</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">exisiting_node_nums</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span> 

        <span class="n">reachable_nodes_num</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">exisiting_node_nums</span><span class="p">,</span> <span class="n">possible_reachable_nodes_num</span><span class="p">)</span>
        <span class="n">temp_num</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">used</span><span class="p">[(</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">)],</span> <span class="n">reachable_nodes_num</span><span class="p">)</span>
        <span class="n">used</span><span class="p">[(</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">)]</span> <span class="o">-=</span> <span class="n">temp_num</span>
        <span class="n">cnt</span> <span class="o">+=</span> <span class="n">temp_num</span>
    <span class="k">return</span> <span class="n">cnt</span> 

<span class="n">MAX</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reachableNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">maxMoves</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">global</span> <span class="n">graph</span><span class="p">,</span> <span class="n">shortest_path</span><span class="p">,</span> <span class="n">used</span>
        <span class="c1"># Step 1: graph Initialization with new edge weight </span>
        <span class="c1"># NOTE: graph와 dijkstra 의 결과인 SHORTESt path모두 dictionary로 저장해, </span>
        <span class="c1"># memory efficient 하게 만든다. </span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">used</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="c1"># undirected graph </span>
            <span class="n">graph</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">used</span><span class="p">[(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        
        <span class="c1">## Step 2: dijkstra Algorithm </span>
        <span class="n">dijkstra_pq</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="c1"># start_dis, start_node </span>
        <span class="c1"># modified_dijkstra_pq = []</span>
        <span class="c1"># n수가 많아지면, [MAX]*n은 좋지 않음. dictionary로 만듦. </span>
        <span class="n">shortest_path</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">shortest_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># start node </span>
         
        <span class="k">while</span> <span class="n">dijkstra_pq</span><span class="p">:</span>
            <span class="n">cur_dis</span><span class="p">,</span> <span class="n">cur_node</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">dijkstra_pq</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">cur_dis</span> <span class="o">&gt;</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">cur_node</span><span class="p">]:</span>
                <span class="k">continue</span> 

            <span class="c1"># each node is only visited once. we&#39;ve reached a node in our original graph </span>
            <span class="k">if</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">cur_node</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">maxMoves</span><span class="p">:</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span> 

            <span class="c1"># 최단 거리가 계산된 노드부터, 이어져 있는 edge들에 대하여 New graph에 있는</span>
            <span class="c1"># reachable nodes들의 개수를 더해준다. </span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">modified_dijkstra</span><span class="p">(</span><span class="n">cur_node</span><span class="p">,</span> <span class="n">maxMoves</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">nxt_node</span><span class="p">,</span> <span class="n">nxt_weight</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">cur_node</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># nxt_node=nxt_state.nxt_node; nxt_weight = nxt_state.weight</span>
                <span class="n">nxt_dis</span> <span class="o">=</span> <span class="n">cur_dis</span> <span class="o">+</span> <span class="n">nxt_weight</span> 
                
                <span class="c1"># MAX로 기본 값 세팅안되어있어서, 없으면 MAX값이라 됨. </span>
                <span class="k">if</span> <span class="n">nxt_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">shortest_path</span> <span class="ow">or</span> <span class="n">nxt_dis</span> <span class="o">&lt;</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">nxt_node</span><span class="p">]:</span>
                    <span class="n">shortest_path</span><span class="p">[</span><span class="n">nxt_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">nxt_dis</span> 
                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">dijkstra_pq</span><span class="p">,</span> <span class="p">(</span><span class="n">nxt_dis</span><span class="p">,</span> <span class="n">nxt_node</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">total</span> 
    

<span class="n">sol</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="c1"># edges = [[0,1,10],[0,2,1],[1,2,2]]; maxMoves = 6; n = 3 # 13 </span>
<span class="c1"># edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]]; maxMoves = 10; n = 4 # 23 </span>
<span class="c1"># edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]]; maxMoves = 17; n = 5 # 1 </span>
<span class="n">edges</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]];</span> <span class="n">maxMoves</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span> <span class="c1"># 13</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">reachableNodes</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">maxMoves</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
</div>
</section>
<section id="second-minimum-time-to-reach-destination">
<h3>Second Minimum  Time to Reach Destination<a class="headerlink" href="#second-minimum-time-to-reach-destination" title="Link to this heading">#</a></h3>
<div class="dropdown admonition">
<p class="admonition-title">Solution Time Limit</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span> 
<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span> 
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span> 

<span class="n">MAX</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>

<span class="sd">&#39;&#39;&#39;Time complexity</span>
<span class="sd">원래의 Dijkstra 는 O(E+V logV) 이지만, </span>
<span class="sd">Second shortest path를 찾는 경우에는, 달라짐. </span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="k">def</span><span class="w"> </span><span class="nf">dijkstra</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">change</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
    <span class="n">MAX</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">)]</span>
    <span class="n">shortest_path</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">shortest_path</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">cur_time</span><span class="p">,</span> <span class="n">cur_node</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="c1"># cur_idx: 횟수, 시간 계산을 위해 사용됨.</span>

        <span class="c1"># NOTE: Dijkstra에서 visited check하는 방식 </span>
        <span class="c1"># second shortest path를 찾기 전까지 버리는 element가 없음. </span>
        <span class="c1"># 노드 n에 도달하기 전에, 다른 노드들에 도착할 때도 기다리고 다른 곳으로 가야할 때가 있음. </span>
        <span class="c1"># N이 아닌 다른 노드들에 대해서는 3, 4 번째 계속 구하다가, 노드가 n인 경우에만 2번째까지 구하면 됨. </span>
        <span class="n">temp_shortest_path</span> <span class="o">=</span> <span class="n">shortest_path</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cur_node</span><span class="p">,</span> <span class="p">[])</span>

        <span class="c1"># NOTE: dijkstra 종료 조건: n node에서 마무리 </span>
        <span class="c1"># if cur_node == n:</span>
        <span class="c1">#     print(cur_node)</span>
        <span class="c1"># 해당 최종 노드로 들어오는 값이 동일한 경우에는, 맨 마지막을 반환해야함. &quot;Strictly larger than the minimum value&quot;</span>
        <span class="k">if</span> <span class="n">cur_node</span> <span class="o">==</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">temp_shortest_path</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">temp_shortest_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># second shortest path to node n </span>
        
        <span class="c1"># cur_signal 계산 </span>
        <span class="n">cur_idx</span><span class="p">,</span> <span class="n">cur_signal</span> <span class="o">=</span> <span class="n">calculate_signal</span><span class="p">(</span><span class="n">cur_time</span><span class="p">,</span> <span class="n">change</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        조건 (갈 수 있는 옵션 중 제한 조건):</span>
<span class="sd">        - 현재 시그널이 초록색: 바로 움직여야함. 어디로든 움직일 수 있음. (enter하는 것은 언제나 가능)</span>
<span class="sd">        - 현재 시그널이 빨강색: 떠날 수 없음. (Signal이 초록색인 경우에만 vertex를 움직일 수 있음.)</span>
<span class="sd">            -&gt; 이 경우 기다려야하는데, 다음 시그널이 초록으로 바뀌는 시간까지만 기다리면 됨. </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># 시그널이 빨간색인 경우 떠날 수 없음. 이 경우 다음 시그널인 초록으로 바뀌는 시간까지 버티면 됨.</span>
        <span class="c1"># 기다리는 시간은 shortest_path를 Update해주지 않음. 다음 노드로 가는 경우에만 업데이트 함.</span>
        <span class="k">if</span> <span class="n">cur_signal</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">((</span><span class="n">cur_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">change</span><span class="p">,</span> <span class="n">cur_node</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># 시그널이 초록색인 경우 어느곳으로라도 움직여야함.</span>
            <span class="k">for</span> <span class="n">nxt_node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">cur_node</span><span class="p">]:</span> 
                <span class="n">nxt_time</span> <span class="o">=</span> <span class="n">cur_time</span> <span class="o">+</span> <span class="n">time</span> 

                <span class="c1"># if n == nxt_node: </span>
                <span class="n">shortest_path</span><span class="p">[</span><span class="n">nxt_node</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nxt_time</span><span class="p">)</span> <span class="c1"># backtracking </span>
                <span class="c1"># if n != nxt_node: # memory 아끼기 </span>
                <span class="c1">#     shortest_path[nxt_node][-1] = nxt_time </span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="n">nxt_time</span><span class="p">,</span> <span class="n">nxt_node</span><span class="p">))</span>
                
    

<span class="k">def</span><span class="w"> </span><span class="nf">calculate_signal</span><span class="p">(</span><span class="n">cur_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">change</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">cur_time</span> <span class="o">/</span> <span class="n">change</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">secondMinimum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">change</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">global</span> <span class="n">graph</span> 
        <span class="c1"># create graph </span>
        <span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">dijkstra</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">change</span><span class="p">)</span>

        
<span class="n">sol</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span> <span class="n">edges</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]];</span> <span class="n">time</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span> <span class="n">change</span><span class="o">=</span><span class="mi">5</span> <span class="c1"># 13 </span>
<span class="c1"># n=2; edges=[[1,2]]; time=3; change=2 # 11 </span>
<span class="c1"># n=7; edges=[[1,2],[1,3],[2,5],[2,6],[6,5],[5,7],[3,4],[4,7]]; time=4; change=7 # 22</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">secondMinimum</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">change</span><span class="p">))</span>

<span class="c1"># MAX_N = 1e4 </span>
<span class="c1"># MAX_edges = 2*1e4 </span>
<span class="c1"># print((MAX_N + MAX_edges) * math.log(MAX_N)) # ~ 3 * 10^5 </span>
</pre></div>
</div>
</div>
<div class="dropdown admonition">
<p class="admonition-title">Solution</p>
<p>When a signal is red, since we don’t move to the next node, we don’t push (time_taken, nxt_node) in the queue. We directly add them when we make a move to the nextnode.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span> 
<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span> 
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span> 
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span> 

<span class="n">MAX</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">dijkstra</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">change</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
    <span class="n">MAX</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">)]</span>
    <span class="n">shortest_path</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MAX</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">shortest_path</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">cur_time</span><span class="p">,</span> <span class="n">cur_node</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="c1"># cur_idx: 횟수, 시간 계산을 위해 사용됨.</span>
        <span class="n">freq</span><span class="p">[</span><span class="n">cur_node</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> 
        <span class="c1"># NOTE: Dijkstra에서 visited check하는 방식 </span>
        <span class="c1"># second shortest path를 찾기 전까지 버리는 element가 없음. </span>
        <span class="c1"># 노드 n에 도달하기 전에, 다른 노드들에 도착할 때도 기다리고 다른 곳으로 가야할 때가 있음. </span>
        <span class="c1"># N이 아닌 다른 노드들에 대해서는 3, 4 번째 계속 구하다가, 노드가 n인 경우에만 2번째까지 구하면 됨. </span>

        <span class="c1"># NOTE: dijkstra 종료 조건: n node에서 마무리 </span>
        <span class="k">if</span> <span class="n">cur_node</span> <span class="o">==</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">freq</span><span class="p">[</span><span class="n">cur_node</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># second shortest path to node n </span>
        
        <span class="c1"># cur_signal 계산 </span>
        <span class="n">cur_idx</span><span class="p">,</span> <span class="n">cur_signal</span> <span class="o">=</span> <span class="n">calculate_signal</span><span class="p">(</span><span class="n">cur_time</span><span class="p">,</span> <span class="n">change</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        조건 (갈 수 있는 옵션 중 제한 조건):</span>
<span class="sd">        - 현재 시그널이 초록색: 바로 움직여야함. 어디로든 움직일 수 있음. (enter하는 것은 언제나 가능)</span>
<span class="sd">        - 현재 시그널이 빨강색: 떠날 수 없음. (Signal이 초록색인 경우에만 vertex를 움직일 수 있음.)</span>
<span class="sd">            -&gt; 이 경우 기다려야하는데, 다음 시그널이 초록으로 바뀌는 시간까지만 기다리면 됨. </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># 시그널이 빨간색인 경우 떠날 수 없음. 이 경우 다음 시그널인 초록으로 바뀌는 시간까지 버티면 됨.</span>
        <span class="c1"># 기다리는 시간은 shortest_path를 Update해주지 않음. 다음 노드로 가는 경우에만 업데이트 함.</span>
        <span class="k">if</span> <span class="n">cur_signal</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># heapq.heappush(q, ((cur_idx+1) * change, cur_node))</span>
            <span class="c1"># (cur_idx+1) * change= green으로 바꾸는 시간 </span>
            <span class="c1"># + time = 다음 노드로 넘어가는 시간 </span>
            <span class="n">nxt_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">cur_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">change</span> <span class="o">+</span> <span class="n">time</span> 
        <span class="k">else</span><span class="p">:</span> <span class="c1"># 시그널이 초록색인 경우 어느곳으로라도 움직여야함.</span>
            <span class="n">nxt_time</span> <span class="o">=</span> <span class="n">cur_time</span> <span class="o">+</span> <span class="n">time</span> 

        <span class="k">for</span> <span class="n">nxt_node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">cur_node</span><span class="p">]:</span>  
            <span class="c1"># Ignore nodes that have already popped out twice, we are not interested in</span>
            <span class="c1"># visiting them again.</span>
            <span class="k">if</span> <span class="n">freq</span><span class="p">[</span><span class="n">nxt_node</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">continue</span> 
            <span class="c1"># 해당 최종 노드로 들어오는 값이 동일한 경우에는, 맨 마지막을 반환해야함. </span>
            <span class="c1"># 즉, &quot;Strictly larger than the minimum value&quot;</span>
            <span class="c1"># 따라서, 동일 값이 있다면 무시하고 넘어가야함. </span>
            <span class="k">if</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">nxt_node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nxt_time</span><span class="p">:</span>
                <span class="n">shortest_path</span><span class="p">[</span><span class="n">nxt_node</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>  <span class="n">shortest_path</span><span class="p">[</span><span class="n">nxt_node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="c1"># backtracking </span>
                <span class="n">shortest_path</span><span class="p">[</span><span class="n">nxt_node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nxt_time</span> 
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="n">nxt_time</span><span class="p">,</span> <span class="n">nxt_node</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">nxt_node</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nxt_time</span> <span class="ow">and</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">nxt_node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nxt_time</span><span class="p">:</span>
                <span class="n">shortest_path</span><span class="p">[</span><span class="n">nxt_node</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nxt_time</span> 
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="n">nxt_time</span><span class="p">,</span> <span class="n">nxt_node</span><span class="p">))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">calculate_signal</span><span class="p">(</span><span class="n">cur_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">change</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    (change* idx &lt;= time &lt; change*(idx+1)) 안에서 그린/레드 시그널이 바뀜. </span>
<span class="sd">    idx % 2 == 0일때는 그린, idx % 2 != 0 일때 레드 </span>
<span class="sd">    따라서, </span>
<span class="sd">    idx &lt;= time/change &lt; idx + 1 </span>
<span class="sd">    이므로, </span>
<span class="sd">    idx = floor(time/change)로 표현가능. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># idx = math.floor(cur_time / change)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">cur_time</span> <span class="o">//</span> <span class="n">change</span><span class="p">)</span> <span class="c1"># 위와 동일 // == math.floor </span>
    <span class="k">return</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">secondMinimum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">change</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">global</span> <span class="n">graph</span> 
        <span class="c1"># create graph </span>
        <span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">dijkstra</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">change</span><span class="p">)</span>

        
<span class="n">sol</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span> <span class="n">edges</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]];</span> <span class="n">time</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span> <span class="n">change</span><span class="o">=</span><span class="mi">5</span> <span class="c1"># 13 </span>
<span class="c1"># n=2; edges=[[1,2]]; time=3; change=2 # 11 </span>
<span class="c1"># n=7; edges=[[1,2],[1,3],[2,5],[2,6],[6,5],[5,7],[3,4],[4,7]]; time=4; change=7 # 22</span>
<span class="n">n</span><span class="o">=</span><span class="mi">12</span><span class="p">;</span> <span class="n">edges</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">],[</span><span class="mi">8</span><span class="p">,</span><span class="mi">11</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">12</span><span class="p">]];</span> <span class="n">time</span><span class="o">=</span><span class="mi">60</span><span class="p">;</span> <span class="n">change</span><span class="o">=</span><span class="mi">600</span> <span class="c1"># 22</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">secondMinimum</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">change</span><span class="p">))</span>

<span class="c1"># MAX_N = 1e4 </span>
<span class="c1"># MAX_edges = 2*1e4 </span>
<span class="c1"># print((MAX_N + MAX_edges) * math.log(MAX_N)) # ~ 3 * 10^5 </span>
</pre></div>
</div>
</div>
</section>
<section id="minimum-weighted-subgraph-with-the-required-paths">
<h3>Minimum Weighted Subgraph With the Required Paths<a class="headerlink" href="#minimum-weighted-subgraph-with-the-required-paths" title="Link to this heading">#</a></h3>
<p>The idea is the following: paths from <code class="docutils literal notranslate"><span class="pre">s1</span></code> to dest and from <code class="docutils literal notranslate"><span class="pre">s2</span></code> to <code class="docutils literal notranslate"><span class="pre">dest</span></code> can have common point <code class="docutils literal notranslate"><span class="pre">x</span></code>. Then we need to reach:</p>
<ol class="arabic simple">
<li><p>From s1 to x, for this we use Dijkstra</p></li>
<li><p>From s2 to x, same.</p></li>
<li><p>From x to dest, for this we use Dijkstra on the reversed graph.</p></li>
<li><p>Finally, we check all possible x.</p></li>
</ol>
<p>Remark</p>
<ul class="simple">
<li><p>In python it was quite challenging to get AC, and I need to look for faster implementation of Dijkstra, however complexity is still the same, it depends on implementation details.</p></li>
</ul>
<p>Complexity</p>
<ul class="simple">
<li><p>It is O(n*log E) for time and O(n) for space.</p></li>
</ul>
<div class="dropdown admonition">
<p class="admonition-title">Solution</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span> 
<span class="kn">from</span><span class="w"> </span><span class="nn">heapq</span><span class="w"> </span><span class="kn">import</span> <span class="n">heappop</span><span class="p">,</span> <span class="n">heappush</span> 

<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">minimumWeight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">dest</span><span class="p">):</span>
        <span class="n">G1</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">G2</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">G1</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
            <span class="n">G2</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">Dijkstra</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
            <span class="n">q</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">K</span><span class="p">)],</span> <span class="p">{}</span>
            <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
                <span class="n">time</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
                    <span class="n">t</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
                    <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                        <span class="n">heappush</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="n">time</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        
        <span class="n">arr1</span> <span class="o">=</span> <span class="n">Dijkstra</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
        <span class="n">arr2</span> <span class="o">=</span> <span class="n">Dijkstra</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
        <span class="n">arr3</span> <span class="o">=</span> <span class="n">Dijkstra</span><span class="p">(</span><span class="n">G2</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
        
        <span class="n">ans</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">arr1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr3</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">ans</span> <span class="k">if</span> <span class="n">ans</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
    
<span class="n">sol</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="n">edges</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">]];</span> <span class="n">src1</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">src2</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">dest</span><span class="o">=</span><span class="mi">5</span> <span class="c1"># 9</span>
<span class="c1"># n = 3; edges=[[0,1,1],[2,1,1]]; src1=0; src2=1; dest=2 # -1 </span>
<span class="c1"># n = 8; edges=[[4,7,24],[1,3,30],[4,0,31],[1,2,31],[1,5,18],[1,6,19],[4,6,25],[5,6,32],[0,6,50]]; src1=4; src2=1; dest=6 # 44 </span>
<span class="c1"># n = 5; edges=[[0,2,1],[0,3,1],[2,4,1],[3,4,1],[1,2,1],[1,3,10]]; src1=0; src2=1; dest=4 # 3 </span>
<span class="nb">print</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">minimumWeight</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">src1</span><span class="p">,</span> <span class="n">src2</span><span class="p">,</span> <span class="n">dest</span><span class="p">))</span>
</pre></div>
</div>
</div>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./_pages/practice"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="4_DPPS.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">이전</p>
        <p class="prev-next-title">Lecture 4-2. DP 실습</p>
      </div>
    </a>
    <a class="right-next"
       href="6_sortPS.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">다음</p>
        <p class="prev-next-title">Lecture 6-2. Sorting</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> 내용
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#priority-queue-kit">Priority Queue, 고득점 Kit</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">더 맵게</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">디스크 컨트롤러</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">이중우선순위큐</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#priority-queue">Priority Queue</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">가로등 설치</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">코드 트리 채점기</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">코드 트리 투어</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">해적 선장 코디</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#dijkstra">Dijkstra</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">개구리의 여행</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reachable-nodes-in-subdivided-graph">Reachable Nodes In Subdivided Graph</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#second-minimum-time-to-reach-destination">Second Minimum  Time to Reach Destination</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#minimum-weighted-subgraph-with-the-required-paths">Minimum Weighted Subgraph With the Required Paths</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
으로 Daye Lee
</p>

  </div>
  
  <div class="footer-item">
    

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>