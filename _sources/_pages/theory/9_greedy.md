---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.5
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# Lecture 9-1. Greedy 

그리디 알고리즘은 당장 좋은 것만 선택하는 알고리즘이다. 국내 알고리즘 교재에서 단어 그래도 번역하여 '탐욕법'으로 소개된다. 이름에서 알 수 있듯이, 탐욕적이라는 말은 ***'현재 상황에서 지금 당장 좋은 것만 고르는 방법'*** 을 의미한다. 그리디 알고리즘에서는 매 순간 가장 좋아 보이는 것만 선택하며, 현재의 선택이나 나중에 미칠 영향에 대해서는 고려하지 않는다. 

앞서 배운 다익스트라 (dijkstra algorithm)이나 MST를 찾는 Kruskal 알고리즘은 greedy 접근법을 사용한다. 그리디 알고리즘 자체가 문제 출제의 폭이 매우 넓기 때문에, 다익스트라 알고리즘과 같은 특이 케이스를 제외하고는 단순 암기를 통해 모든 문제에 대처하기는 어렵다. 

특히, 그리디 알고리즘 유형 문제는 매우 다양해서, 암기하기 보다 많은 유형을 접해보고 문제를 풀어보며 훈련을 해야한다. 향후 등장할 문제를 풀어보면 이해할 수 있을 것이다. 

보통 코딩 테스트에서 출제되는 그리디 알고리즘 유형의 문제는 단순히 현재 상황에서 가장 좋아 보이는 것만 선택해도 문제를 풀 수 있는지를 파악할 수 있어야한다. 그리디 알고리즘은 기준에 따라 좋은 것을 선택하는 알고리즘이므로 문제에서 **'가장 큰 순서대로'** , **'가장 작은 순서대로'** 와 같은 기준을 알게 모르게 제시해준다. 대체로 이 기준은 정렬 알고리즘을 사용했을 때 만족시킬 수 있으므로 그리디 알고리즘 문제는 정렬 알고리즘과 짝을 이뤄 출제된다. 

아래에서는 '거스름돈' 문제를 예로 그리디 알고리즘을 설명하겠다. '거스름돈' 문제는 그리디 알고리즘을 대표하는 문제이다. 

**예제** <br>

당신은 음식점의 계산을 도와주는 점원이다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정한다. 손님에게 거슬러 줘야 할 돈이 N원일 때 거슬러줘야 할 동전의 최소 개수를 구하라. 단, 거슬러 줘야 할 돈 N은 항상 10의 배수이다. 

**문제 해설** <br>

***'가장 큰 화폐 단위부터' 돈을 거슬러주면*** 된다. N원을 거슬러 줘야 할 때, 가장 먼저 500원으로 거슬러 줄 수 있을 만큼 거슬러 준다. 그다음 100원, 50원, 10원짜리 동전을 차례대로 거슬러 줄 수 있을 만큼 거슬러 주면 최소의 동전 개수로 모두 거슬러 줄 수 있다. 

예를 들어, 입력으로 주어진 N이 1,260이라면, 손님이 받은 동전의 최소 개수는 가장 큰 동전부터 최대로 거슬러 줄 수 있는 개수를 지불해주면 된다. 

| 화폐 단위 | 500 | 100 | 50 | 10 |
|---|---|---|---|---|
|손님이 받은 개수 | 2| 2 | 1 | 1 |

따라서, N이 1,260일 때 손님이 받은 동전의 최소 개수는 6개이다. 해당 풀이를 파이썬 알고리즘으로 풀면 다음과 같다. 

````{admonition} Solution 
:class: dropdown 

```{code-block} python
n = 1260 
count = 0 

# Check the largest denomination (화폐 단위) first 
coin_types = [500, 100, 50, 10]

for coin in coin_types:
    count += n // coin # Count how many coins are needed for this denomination
    n %= coin  # Update the remaining amount after giving change

print(count)
```
````

위의 코드는 화폐의 종류가 K개라고 할 때 시간복잡도는 O(K)이다. 

## 그리디 알고리즘의 정당성 

그리디 알고리즘으로 문제의 해법을 찾았을 때는 그 해법이 정당한지 ***검토*** 해야 한다. 거스름돈 문제를 그리디 알고리즘으로 해결할 수 있는 이유는 ***"가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문이다"*** 예를 들어 800원을 거슬러 줘야 하는데, 화폐 단위가 500원, 400원, 100원인 경우를 생각해보자. 이 경우에 그리디 알고리즘으로는 4개의 동전 (500원 + 100원 + 100원 + 100원)을 거슬러 줘야 한다고 나오는데, 최적의 해는 2개의 동전 (400원 + 400원)을 거슬러 주는 것이다. 대부분의 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야한다. 

어떤 코딩 테스트 문제를 만났을 때, 바로 문제 유형을 파악하기 어렵다면 그리디 알고리즘을 의심하고, 문제를 해결할 수 있는 탐욕적인 해결법이 존재하는지 고민해보자. 만약 오랜 시간을 고민해도 그리디 알고리즘으로 해결 방법을 찾을 수 없다면, 다이나믹 프로그래밍이나 그래프 알고리즘 등으로 문제를 해결할 수 있는지를 재차 고민해보는 것도 한 방법이다. 

## 실전 문제 

### Assign Cookies 

[문제 링크](https://leetcode.com/problems/assign-cookies/description/?envType=problem-list-v2&envId=greedy)

### Array Partition 

[문제 링크](https://leetcode.com/problems/array-partition/description/?envType=problem-list-v2&envId=greedy)

### Can Place Flowers 

[문제 링크](https://leetcode.com/problems/can-place-flowers/description/?envType=problem-list-v2&envId=greedy)