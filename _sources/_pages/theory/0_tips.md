---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.5
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# 문제 풀이 순서 팁 (Tips)

0. (사전) 코딩테스트 IDE 준비 
    - 필수. 빠른 입출력 세팅 (sys.stdin.readline 등), 자주 쓰이는 함수 (예: dfs/bfs, 이분탐색) 미리 준비해두면 좋습니다. 
    - 다만, 온라인 IDE 환경과 로컬 IDE가 다르므로 실제 환경에 맞게 미리 연습해두는 게 핵심입니다. (debug 단축키 확인)

1. 복잡도 파악 및 필요한 데이터 구조 파악 
    - 문제에서 요구하는 찾기, 삭제, 삽입 등의 operation을 진행할 때, 데이터의 개수와 비교하여 어떤 데이터 구조로 설정해야할 지 생각해야한다. 
      - 예를 들어, dictionary는 key에 str, int 등의 다양한 데이터 타입을 받을 수 있지만,  
        - **key가 문자열(str)**인 경우:  
          - 해시 계산과 비교에 **O(len(key))** 시간이 든다.  
          - 최대 길이가 긴 문자열을 계속 키로 쓰면, 상수항이 커진다.
        - **key가 0 ~ N-1 범위의 int**이고, **중간 값 없이 빽빽하게** 존재한다면:  
          - `dict` 대신 `list`로 바로 인덱싱하는 것이 훨씬 빠르고 메모리도 덜 든다. (`a[x]`가 진짜 O(1) 배열 접근)
    - 문제를 읽고 **제약 조건(입력 크기, 시간 제한)** 먼저 확인 $\rightarrow$ 바로 시간복잡도 상한을 설정해야 합니다. 
      - 파이썬 기준으로, **1초에 약 $10^7$ 번 연산** 정도를 안전하게 본다고 생각하면 된다.  
        - 예: $N = 10^5$ 이면, $O(N \log N)$ 은 대략 $10^5 \times 17 \approx 1.7 \times 10^6$ → 충분히 여유.  
        - 예: $N = 5000$ 이고 $O(N^2)$이면 $2.5 \times 10^7$ → 1초 기준 살짝 위험/언저리.
      - C/Java의 경우 primitive int 기준 4 byte이지만, **파이썬의 int는 객체(object)**라서 4 byte가 아니다. 
        - 파이썬의 모든 것(숫자, 문자열, 리스트 원소 등)은  
          ***객체(Object) = 포인터 + 타입정보 + 길이정보 + 실제 값***  
          구조로 저장되어, **객체 오버헤드**가 붙는다.
        - 작은 정수 하나(`int`)는 대략 **28 bytes** 정도를 차지하고, 리스트 안에 들어가면 포인터까지 포함해 **원소 하나당 약 36 bytes** 정도로 생각하면 된다.
    - **풀이 아이디어 $\rightarrow$ 복잡도 $\rightarrow$ 자료구조** 선택을 메모하는 습관 추천
    - 또한, ***구현*** 문제의 경우, 여러 개의 command에 대해 다른 작업을 해야하는 경우, 해당 command를 작업하고 다른 command를 할 때, 어떤 영향을 주는 게 있는지, 어떤 작업을 처리해야하는지 유기적으로 보면서 알고리즘을 구현해야 한다. 
    - 또한, 하나의 cmd가 복잡한 경우 조건을 다 적은 후, 실제 algorithm을 순서대로 적어서 빠짐없이 하도록 한다. 예를 들어 아래처럼 미리 작성해놓으면 실제 구현 시에 편하다. 

```text
Algorithm 
1-1. pq에서 맨 위의 Task를 뽑는다. (아직 제거x) (이득이 최대이고, id가 가장 작은 상품 순으로 뽑힘.)
2-1. 이미 3.에 의해 삭제된 여행 상품인지 확인한다. (O(1))
2-2. 존재하는 상품이면, 판매 불가 상품인지 확인한다. (O(1))
3-1. 위의 조건을 만족하면, id를 출력한 뒤 관리 목록에서 제거한다. (log30000 ~ 10)
3-3. pq의 모든 상품을 다 돌았는데도 불구하고, 판매가능한 상품이 없으면, -1를 출력하고, 관리 목록에서 제거하지 않는다.  
```
 
```{admonition} N에 따른 시간 복잡도 계산 및 알고리즘 선택 
:class: dropdown 

제한 시간이 1초 기준으로 입력 값의 범위가 다음과 같을 때 (언어, 채점 환경에 따라 달라질 수 있음)

* **(대략적인 감)** 파이썬 기준 1초에 $\sim 10^7$ 연산 정도로 생각하면 된다.

  * $O(N)$:

    * $N \le 10^7$ 정도면 단순 루프 1번은 가능 (상수항이 크면 더 줄어든다고 생각).
  * $O(N \log N)$:

    * $N \le 10^5 \sim 2 \times 10^5$ 는 대부분 안전.
    * 예: $N = 2 \times 10^5$ 이면 $N \log N \approx 2 \times 10^5 \times 18 \approx 3.6 \times 10^6$.
  * $O(N^2)$:

    * $N \le 3000$ 정도면 여유,
    * $N \approx 5000$ 이면 $2.5 \times 10^7$ 근처라 **파이썬에선 위험/언저리**.
    * $N \ge 10^4$에서 $O(N^2)$은 대부분 시간 초과라고 보면 된다.

간단히 암기용으로 정리하면:

* N의 범위가 ~500 : 시간 복잡도 O(N^3) 로 풀 수 있다.
* N의 범위가 ~2000 : 시간 복잡도 O(N^2) 로 풀 수 있다.
* N의 범위가 ~100,000 : 시간 복잡도 O(NlogN) 로 풀 수 있다.
* N의 범위가 ~10,000,000 : 시간 복잡도 O(N) 로 풀 수 있다.

**문자열(str) 처리 시간 감각**

* 문자열 길이를 $L$이라고 할 때,

  * 한 번 전체를 도는 연산(예: `for ch in s`, `s.count('a')`, `hash(s)` 등)은 **O(L)**.
  * 딕셔너리에서 문자열 키를 찾는 것도 해시 계산/비교 때문에 **평균 O(1)**이지만,
    내부적으로는 **문자열 길이 $L$에 비례하는 작업**이 포함됨.
* 예: 전체 입력 문자열 길이 총합이 $10^6$ 이하면, 문자열 전체를 여러 번 도는 수준의 알고리즘도 대부분 1초 내에 가능하다.

```

```{admonition} N에 따른 메모리 C/C++
:class: dropdown 

* `int` (4B)

  * 원소 1,000,000개 기준 → 약 4MB
  * 256MB라면

    * $256 \text{MB} \approx 256 \times 10^6 \text{B}$
    * $256 \times 10^6 / 4 \approx 64 \times 10^6$ 개의 `int` 저장 가능 (약 $6.4 \times 10^7$개)
* `long long` / `double` (8B)

  * 1,000,000개 기준 → 약 8MB
* `char` / `bool` (1B)

  * 1,000,000개 기준 → 약 1MB

```

```{admonition} N에 따른 메모리 (Python)
:class: dropdown 

### 메모리 (파이썬) – 감으로 계산하는 법

* 코테에서 제공하는 메모리 제한은 보통 **512MB** 수준.
* 파이썬은 객체 오버헤드가 커서, **실제로는 200~300MB 안에서 끝나는 풀이**를 목표로 하는 게 안전하다.

#### 1. `int` 와 `list[int]`

* 작은 정수 하나(`int`) ~ 28 bytes
* 리스트 안에 들어가면:

  * 리스트는 **포인터 배열**을 들고 있고,
  * 포인터가 원소당 8 bytes
  * → **리스트 안의 int 1개 ≈ 28 + 8 ≈ 36 bytes**로 생각.

**대략 공식**

* 원소가 $N$개인 `list[int]`의 메모리
  $\approx 36 \times N$ bytes
  $\approx 0.036 \times N$ MB

**예시**

* `N = 1_000_000` (`10^6`)

  * $36 \times 10^6 \text{B} \approx 36 \text{MB}$
  * 즉, **정수 100만 개짜리 리스트 ≈ 36MB**
* 2차원 배열 `N x N` 이고, 각 원소가 `int`일 때:

  * 메모리 $\approx 36 \times N^2$ bytes
  * 예: `N = 1500`

    * $1500^2 = 2.25 \times 10^6$
    * $36 \times 2.25 \times 10^6 \approx 81 \times 10^6$ bytes ≈ **81MB**
    * 파이썬에서 이 정도 2D 배열 하나만 써도 꽤 무겁다.

실전 감각:

* **정수 리스트는 300만 개 (약 100MB) 이하**를 목표로 잡으면 안전한 편.
* 2D 배열은 **$N^2$가 수백만** 수준이면 이미 수십 MB를 먹기 때문에,
  제한 메모리/다른 변수들을 고려하면 `N = 1500 ~ 2000` 정도가 한계에 가깝다고 생각하면 된다.

#### 2. 문자열(`str`)

파이썬 문자열은

* **고정 오버헤드** + **문자 개수만큼 1 byte씩** 정도로 저장된다고 보면 된다.

간단히:

* 길이가 $L$인 문자열 1개 → 대략 $(50 + L)$ bytes 정도
* `sys.getsizeof("a" * 1_000_000)` ≈ 1,000,049 bytes → 거의 1MB 수준

즉,

* **총 문자 수 합이 $10^7$ (1천만)** 이라면,

  * 문자열만으로 약 10MB + 오버헤드 몇 MB → 여유 있음.
* 문자열이 메모리를 터뜨리는 경우는 보통

  * 아주 긴 문자열을 **여러 개** 쌓아두거나,
  * 거대한 문자열 리스트를 만들 때이다.

#### 3. `set`, `dict`

* 해시 테이블 구조라서 **리스트보다 상당히 무겁다**.
* 대충 감각:

  * `dict` / `set` 안에 `int`를 $N$개 넣으면

    * 정수 객체: $28 \times N$ bytes
    * 해시 버킷/포인터 등: 대략 그 수준 이상 추가
    * → **$N = 10^6$ (백만 개)**면 **수십 MB ~ 100MB 수준**까지 갈 수 있다고 생각하면 된다.
* 실전 안전선:

  * 코테에서 **`set` / `dict`에는 30만 ~ 50만 개 정도까지** 를,

    * 그 이상은 “많이 무겁다”라고 생각하고 설계하는 게 좋다.

---

### 실전에서 쓸 수 있는 간단 규칙 (파이썬)

* **정수 배열**

  * `list[int]` 크기 $N$ → 메모리 ≈ $0.036 \times N$ MB
  * $N = 1 \times 10^6$ → 약 36MB
* **2차원 정수 배열**

  * $N \times N$ → 메모리 ≈ $0.036 \times N^2$ MB
* **문자열**

  * 전체 문자 수 합이 $L$이면, 문자열 전체 메모리 ≈ $(L + 약간의 오버헤드)$ bytes
  * $L = 10^7$ → 약 10MB + overhead → 대체로 괜찮음
* **set/dict**

  * 원소 수가 수십만 단위면 이미 메모리를 꽤 쓰고 있다.
  * 백만 단위면 “100MB 근처 갈 수 있다” 정도 감각으로 조심.

```

```{admonition} 스택 (재귀함수)
:class: dropdown 

### 스택(1MB 내외) 주의

* 재귀 깊이 한계: 프레임당 수십~수백 B + 지역변수.
* C++:

  * 함수 안에 **큰 지역 배열** 만들지 말 것.
  * 재귀 DFS는 $10^5$ 노드 이상에서 스택 오버플로우 위험 → 반복(스택 컨테이너) DFS/BFS로 전환.
* Python:

  * 프레임 오버헤드가 더 크고, 기본 재귀 제한도 ≈ 1000 정도.
  * **재귀는 웬만하면 지양**하고, 반복문 + 명시적인 스택/큐 자료구조 사용.
* 규칙: 큰 배열/리스트는 **전역/힙에** 두고, 재귀 함수 로컬에 큰 구조를 두지 않는다.

```

1. 에지 케이스 (edge case) 정리 
   - 중요 단계! 
     - 크기: N=0,1 / N 최대
     - 값: 음수, 0, 최대값, 오버플로우 경계
     - 중복: 모두 동일 / 모두 다름 / 동점 다수
     - 정렬: 정렬/역정렬/지그재그
     - 포맷: 공백·개행·빈 줄 / 대소문자 / 선행 0
     - 구조: 비연결 그래프 / 사이클 / 자기루프 / 멀티엣지
     - 경계: 구간 끝이 맞닿음, 포함/미포함([ ], ( ))
     - 결과 없음/여러 개/타이브레이크 요구
     - 시간: 최악 입력 패턴(슬라이딩윈도우가 매번 실패, 이분탐색이 전부 False/전부 True 등)

2. 코드 짜기 및 디버깅
   - 기본 구조 먼저 (입력 처리 $\rightarrow$ 로직 함수화 $\rightarrow$ 출력)
   - 디버깅하기 편하게 **단계별로 프린트** 넣었다가 제출 직전 삭제 
     - 디버깅하면서 그때그때 바뀌는 것을 확인하는 것도 좋지만, 
     - 별도의 file (touch rotation.py)을 만들어서 print로 변경 전, 변경 후 원하는 결과와 같은지 확인해보는 것이 빠르다. 
     - **출력 형식 오류 (띄어쓰기, 개행)** 체크 필수. 
   - 특히 구현 문제는 `작은 함수 단위`로 쪼개는 게 실수 줄이는 데 도움 됩니다. 

3. 디버깅 
   1. 시간 초과 시: 입력 방식, 자료구조, 알고리즘 복잡도 재확인 
   2. 틀렸습니다 시: 정리해둔 에지 케이스를 넣어서 로컬에서 재현해보기 


문제 모음집 

1. [프로그래머스 고득점 Kit](https://school.programmers.co.kr/learn/challenges?tab=algorithm_practice_kit)
2. 코드 트리 삼성 기출 문제 